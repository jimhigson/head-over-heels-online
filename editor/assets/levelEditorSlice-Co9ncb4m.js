import{a5 as M,a6 as ae,a7 as D,a8 as O,a9 as G,aa as A,ab as q,ac as Ye,ad as yo,ae as ne,af as Ve,ag as Ke,ah as po,ai as go,aj as ho,ak as Io,al as vo,am as L,an as xo,ao as Se,ap as U,aq as Ze,ar as wo,as as bo,at as Qe,au as Ro,av as eo,aw as Eo,ax as zo,ay as ko}from"./index-FSqPpIPM.js";var Y={},V={},Ce;function Ao(){if(Ce)return V;Ce=1;function e(l,u){var i;if(typeof Symbol>"u"||l[Symbol.iterator]==null){if(Array.isArray(l)||(i=o(l))||u){i&&(l=i);var f=0,a=function(){};return{s:a,n:function(){return f>=l.length?{done:!0}:{done:!1,value:l[f++]}},e:function(y){throw y},f:a}}throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}var s=!0,m=!1,p;return{s:function(){i=l[Symbol.iterator]()},n:function(){var y=i.next();return s=y.done,y},e:function(y){m=!0,p=y},f:function(){try{!s&&i.return!=null&&i.return()}finally{if(m)throw p}}}}function o(l,u){if(l){if(typeof l=="string")return t(l,u);var i=Object.prototype.toString.call(l).slice(8,-1);if(i==="Object"&&l.constructor&&(i=l.constructor.name),i==="Map"||i==="Set")return Array.from(l);if(i==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return t(l,u)}}function t(l,u){(u==null||u>l.length)&&(u=l.length);for(var i=0,f=new Array(u);i<u;i++)f[i]=l[i];return f}var r=M(),n=r.ensureIterable;function c(l){var u=[],i=e(l),f;try{for(i.s();!(f=i.n()).done;){var a=f.value;u.push(a)}}catch(s){i.e(s)}finally{i.f()}return u}V.__toArray=c;function d(l){return c(n(l))}return V.toArray=d,V}var Pe;function So(){if(Pe)return Y;Pe=1;var e=ae(),o=e.mark(d),t=M(),r=t.iterableCurry,n=Ao(),c=n.__toArray;function d(u,i){var f;return e.wrap(function(s){for(;;)switch(s.prev=s.next){case 0:if(f=Array.isArray(u)?u:c(u),f.length){s.next=3;break}return s.abrupt("return");case 3:if(!i--){s.next=7;break}return s.delegateYield(f,"t0",5);case 5:s.next=3;break;case 7:case"end":return s.stop()}},o)}Y.__cycleTimes=d;var l=r(d);return Y.cycleTimes=l,Y}var K={},Te;function Co(){if(Te)return K;Te=1;var e=ae(),o=e.mark(l);function t(i,f){var a;if(typeof Symbol>"u"||i[Symbol.iterator]==null){if(Array.isArray(i)||(a=r(i))||f){a&&(i=a);var s=0,m=function(){};return{s:m,n:function(){return s>=i.length?{done:!0}:{done:!1,value:i[s++]}},e:function(h){throw h},f:m}}throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}var p=!0,g=!1,y;return{s:function(){a=i[Symbol.iterator]()},n:function(){var h=a.next();return p=h.done,h},e:function(h){g=!0,y=h},f:function(){try{!p&&a.return!=null&&a.return()}finally{if(g)throw y}}}}function r(i,f){if(i){if(typeof i=="string")return n(i,f);var a=Object.prototype.toString.call(i).slice(8,-1);if(a==="Object"&&i.constructor&&(a=i.constructor.name),a==="Map"||a==="Set")return Array.from(i);if(a==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a))return n(i,f)}}function n(i,f){(f==null||f>i.length)&&(f=i.length);for(var a=0,s=new Array(f);a<f;a++)s[a]=i[a];return s}var c=M(),d=c.iterableCurry;function l(i,f){var a,s,m,p;return e.wrap(function(y){for(;;)switch(y.prev=y.next){case 0:a=0,s=t(i),y.prev=2,s.s();case 4:if((m=s.n()).done){y.next=11;break}if(p=m.value,!f(p,a++)){y.next=9;break}return y.next=9,p;case 9:y.next=4;break;case 11:y.next=16;break;case 13:y.prev=13,y.t0=y.catch(2),s.e(y.t0);case 16:return y.prev=16,s.f(),y.finish(16);case 19:case"end":return y.stop()}},o,null,[[2,13,16,19]])}K.__filter=l;var u=d(l);return K.filter=u,K}var Z={},Fe;function Po(){if(Fe)return Z;Fe=1;var e=M(),o=e.iterableCurry,t=So(),r=t.__cycleTimes;function n(d){return r(d,1/0)}Z.__cycle=n;var c=o(n);return Z.cycle=c,Z}var Q={},Oe;function To(){if(Oe)return Q;Oe=1;var e=ae(),o=e.mark(l);function t(i,f){var a;if(typeof Symbol>"u"||i[Symbol.iterator]==null){if(Array.isArray(i)||(a=r(i))||f){a&&(i=a);var s=0,m=function(){};return{s:m,n:function(){return s>=i.length?{done:!0}:{done:!1,value:i[s++]}},e:function(h){throw h},f:m}}throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}var p=!0,g=!1,y;return{s:function(){a=i[Symbol.iterator]()},n:function(){var h=a.next();return p=h.done,h},e:function(h){g=!0,y=h},f:function(){try{!p&&a.return!=null&&a.return()}finally{if(g)throw y}}}}function r(i,f){if(i){if(typeof i=="string")return n(i,f);var a=Object.prototype.toString.call(i).slice(8,-1);if(a==="Object"&&i.constructor&&(a=i.constructor.name),a==="Map"||a==="Set")return Array.from(i);if(a==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a))return n(i,f)}}function n(i,f){(f==null||f>i.length)&&(f=i.length);for(var a=0,s=new Array(f);a<f;a++)s[a]=i[a];return s}var c=M(),d=c.iterableCurry;function l(i,f){var a,s,m,p;return e.wrap(function(y){for(;;)switch(y.prev=y.next){case 0:a=0,s=t(i),y.prev=2,s.s();case 4:if((m=s.n()).done){y.next=11;break}if(p=m.value,!(a++>=f)){y.next=9;break}return y.next=9,p;case 9:y.next=4;break;case 11:y.next=16;break;case 13:y.prev=13,y.t0=y.catch(2),s.e(y.t0);case 16:return y.prev=16,s.f(),y.finish(16);case 19:case"end":return y.stop()}},o,null,[[2,13,16,19]])}Q.__drop=l;var u=d(l);return Q.drop=u,Q}var ee={},oe={},$e;function Fo(){if($e)return oe;$e=1;var e=M(),o=e.iterableCurry,t=e.callReturn;function r(c,d){var l=c[Symbol.iterator](),u=l.next(),i=u.value,f=u.done;return f?d:(t(l),i)}oe.__firstOr=r;var n=o(r,{reduces:!0});return oe.firstOr=n,oe}var We;function Oo(){if(We)return ee;We=1;var e=M(),o=e.iterableCurry,t=Fo(),r=t.__firstOr;function n(d){return r(d,void 0)}ee.__first=n;var c=o(n,{reduces:!0});return ee.first=c,ee}var te={},_e;function $o(){if(_e)return te;_e=1;var e=ae(),o=e.mark(l);function t(i,f){var a;if(typeof Symbol>"u"||i[Symbol.iterator]==null){if(Array.isArray(i)||(a=r(i))||f){a&&(i=a);var s=0,m=function(){};return{s:m,n:function(){return s>=i.length?{done:!0}:{done:!1,value:i[s++]}},e:function(h){throw h},f:m}}throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}var p=!0,g=!1,y;return{s:function(){a=i[Symbol.iterator]()},n:function(){var h=a.next();return p=h.done,h},e:function(h){g=!0,y=h},f:function(){try{!p&&a.return!=null&&a.return()}finally{if(g)throw y}}}}function r(i,f){if(i){if(typeof i=="string")return n(i,f);var a=Object.prototype.toString.call(i).slice(8,-1);if(a==="Object"&&i.constructor&&(a=i.constructor.name),a==="Map"||a==="Set")return Array.from(i);if(a==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a))return n(i,f)}}function n(i,f){(f==null||f>i.length)&&(f=i.length);for(var a=0,s=new Array(f);a<f;a++)s[a]=i[a];return s}var c=M(),d=c.iterableCurry;function l(i,f){var a,s,m,p;return e.wrap(function(y){for(;;)switch(y.prev=y.next){case 0:if(f!==0){y.next=2;break}return y.abrupt("return");case 2:a=0,s=t(i),y.prev=4,s.s();case 6:if((m=s.n()).done){y.next=14;break}return p=m.value,y.next=10,p;case 10:if(++a!==f){y.next=12;break}return y.abrupt("break",14);case 12:y.next=6;break;case 14:y.next=19;break;case 16:y.prev=16,y.t0=y.catch(4),s.e(y.t0);case 19:return y.prev=19,s.f(),y.finish(19);case 22:case"end":return y.stop()}},o,null,[[4,16,19,22]])}te.__take=l;var u=d(l);return te.take=u,te}var le,Me;function Wo(){return Me||(Me=1,le=Po().cycle),le}var _o=Wo();const Mo=D(_o);var de,qe;function qo(){return qe||(qe=1,de=To().drop),de}var No=qo();const Bo=D(No);var fe,Ne;function Ho(){return Ne||(Ne=1,fe=Co().filter),fe}var Jo=Ho();const Lo=D(Jo);var ue,Be;function jo(){return Be||(Be=1,ue=Oo().first),ue}var Xo=jo();const Ie=D(Xo);var me,He;function Do(){return He||(He=1,me=$o().take),me}var Go=Do();const Uo=D(Go),T=e=>e.campaignInProgress.rooms[e.currentlyEditingRoomId],ve=(e,o)=>e.campaignInProgress.rooms[o],oo=(e,o,t)=>e.campaignInProgress.rooms[t??e.currentlyEditingRoomId]?.items[o],Yo=(e,o)=>e.selectedJsonItemIds.includes(o),H=e=>{const o=structuredClone(O(T(e))),{history:t}=e;t.redo=[],t.undo.push(o)},Vo={undo(e){const o=e,{campaignInProgress:t,history:{undo:r,redo:n},currentlyEditingRoomId:c}=o;r.length!==0&&(n.push(t.rooms[c]),t.rooms[c]=r.pop())},redo(e){const o=e,{campaignInProgress:t,history:{redo:r,undo:n},currentlyEditingRoomId:c}=o;r.length!==0&&(n.push(t.rooms[c]),t.rooms[c]=r.pop())}},Ko={selectCanUndo:e=>e.history.undo.length>0,selectCanRedo:e=>e.history.redo.length>0},ye={x:1,y:0,z:0},pe={x:-1,y:0,z:0},ge={x:0,y:-1,z:0},he={x:0,y:1,z:0},j={away:he,left:ye,right:pe,towards:ge,down:{x:0,y:0,z:-1},up:{x:0,y:0,z:1},awayRight:G(A(he,pe)),towardsRight:G(A(ge,pe)),towardsLeft:G(A(ge,ye)),awayLeft:G(A(he,ye))},Jr={w:16,d:16,h:12},ie={x:16,y:16,z:12},Zo=(e,o,t)=>{if(o==="*")return!0;const r=t.meta.subRooms[o];return e.x>=r.physicalPosition.from.x&&e.y>=r.physicalPosition.from.y&&e.x<=r.physicalPosition.to.x&&e.y<=r.physicalPosition.to.y},Qo=({position:e},o,t)=>Zo(e,o,t),re=(e,o,t,r)=>o.some(n=>n.config.direction===e)?"doorway":t===void 0?"wall":Object.values(t).some(({gridPosition:n})=>po(j[e],go(n,r)))?"open":"wall";function*B(e){try{yield*et(e)}catch(o){const t=o;throw new Error(`
  error in recursion ${e.roomId}/${e.subRoomId??"*"}`,{cause:t})}}function*et({roomId:e,subRoomId:o="*",campaign:t,visited:r={},vectorFromPrevious:n,previousRoomGridPosition:c=ne}){if(e==="nowhere"||r[e]?.[o])return;r[e]===void 0&&(r[e]={}),r[e][o]=!0;const d=t.rooms[e];if(d===void 0)throw new Error(`no room in the campaign with id="${e}"`);const l=[...q(Ye(d.items)).filter(m=>m.type==="door").filter(m=>Qo(m,o,d))],u=A(c,n===void 0?yo:n),i=d.meta?.subRooms;if(i){if(o==="*")throw new Error(`subRoomId '*' means 'all' and is not allowed for big rooms. Must be one of the sub-rooms in ${e}: ${Object.keys(i)}`);if(!i[o])throw new Error(`Sub-room ${o} not found in room ${e}. Available sub-rooms: ${Object.keys(i)}`)}const f=i?.[o].gridPosition,a={left:re("left",l,i,f),right:re("right",l,i,f),away:re("away",l,i,f),towards:re("towards",l,i,f)};if(yield{roomId:e,subRoomId:o,gridPosition:u,boundaries:a},i!==void 0){if(f===void 0)throw new Error(`Sub-room ${o} not found in room ${e}. Available sub-rooms: ${Object.keys(i)}`);for(const[m,{gridPosition:p}]of q(Ve(i)))m!==o&&(yield*B({roomId:e,subRoomId:m,campaign:t,visited:r,vectorFromPrevious:Ke({...p,z:0},f),previousRoomGridPosition:u}))}if(d.roomAbove!==void 0){const{roomAbove:m,subRoomAbove:p}=d;yield*B({roomId:m,subRoomId:p,campaign:t,visited:r,vectorFromPrevious:j.up,previousRoomGridPosition:u})}if(d.roomBelow!==void 0){const{roomBelow:m,subRoomBelow:p}=d;yield*B({roomId:m,subRoomId:p,campaign:t,visited:r,vectorFromPrevious:j.down,previousRoomGridPosition:u})}for(const m of l){const{toRoom:p}=m.config;yield*B({roomId:p,campaign:t,visited:r,subRoomId:m.config.meta?.toSubRoom,vectorFromPrevious:j[m.config.direction],previousRoomGridPosition:u})}const s=d.meta?.nonContiguousRelationship;if(s!==void 0){const{with:{room:m},gridOffset:p}=s;yield*B({roomId:m,campaign:t,visited:r,subRoomId:"*",vectorFromPrevious:p,previousRoomGridPosition:u})}}const ot={jail:["bars"],blacktooth:["plain","plain","armour","shield","shield","armour"],bookworld:["book","book","cowboy"],egyptus:["hieroglyphics","hieroglyphics","hieroglyphics","sarcophagus","sarcophagus"],market:["passage","more-fruits","fruits","more-fruits","fruits"],moonbase:["coil","window1","window2","window3"],penitentiary:["loop","loop","skeleton"],safari:["wall","shield","wall","window","window","wall","shield"]},X=(e,o,t=0)=>{const r=Mo(ot[e]);return Bo(t,Uo(o+t,r))},tt=e=>({awayWall:{type:"wall",config:{direction:"away",tiles:Array.from(X("blacktooth",e.x))},position:{x:0,y:e.y,z:0}},leftWall:{type:"wall",config:{direction:"left",tiles:Array.from(X("blacktooth",e.y))},position:{x:e.x,y:0,z:0}},towardsWall:{type:"wall",config:{direction:"towards",times:{x:e.x}},position:{x:0,y:0,z:0}},rightWall:{type:"wall",config:{direction:"right",times:{y:e.y}},position:{x:0,y:0,z:0}}}),to=e=>({planet:"blacktooth",color:{hue:"cyan",shade:"basic"},items:{floor:{type:"floor",config:{floorType:"standable",scenery:"blacktooth",times:e},position:{x:0,y:0,z:0}},...tt(e)}}),ro=(e,o)=>{e.planet=o;for(const t of Object.values(e.items))t.type==="floor"&&t.config.floorType==="standable"&&(t.config.scenery=o),t.type==="wall"&&(t.config.direction==="away"||t.config.direction==="left")&&(t.config.tiles=Array.from(X(o,t.config.tiles.length))),t.type==="pickup"&&t.config.gives==="crown"&&ho.includes(o)&&(t.config.planet=o)},rt=e=>e[Math.floor(Math.random()*e.length)],we=(e,o,t)=>{const n=`room_${q(Io({start:0})).find(l=>e.campaignInProgress.rooms[`room_${l}`]===void 0)}`,c=t??{hue:rt(vo),shade:Math.random()<.66?"basic":"dimmed"},d={id:n,...structuredClone(to({x:8,y:8})),color:c};return ro(d,o),e.campaignInProgress.rooms[n]=d,d},be=(e,o,t)=>{if(o.type==="player"){const{which:n}=o.config;return t?`preview-${n}`:n}const r=o.type==="monster"?o.config.which:o.type;for(let n=1;;n++){const c=n===1?r:`${r}_${n}`;if(!e.items[c])return c}},xe=(e,o,t,r)=>{const n=T(e),c=be(n,o,r),d=no(e,r),l={type:o.type,config:o.config,position:t};return d[c]=l,[c,l]},no=(e,o,t=e.currentlyEditingRoomId)=>o?e.previewedEdits:e.campaignInProgress.rooms[t].items,nt=["head","heels"],it=[...nt,"headOverHeels"],C=(...e)=>o=>e.includes(o.type),st=C("bubbles","stopAutowalk","firedDoughnut","floatingText","emitter","particle"),at=(e,o)=>st(e)||pt(e)&&(o!==void 0&&ft(o)||e.config.direction.z!==0)||ht(e)&&e.config.floorType==="none",Lr=(e,o)=>!at(e,o),ct=["ball","slidingBlock","slidingDeadly"];C(...ct);const lt=["portableBlock","spring","sceneryPlayer","sceneryCrown","monster","slidingBlock"],dt=["dalek","turtle","elephantHead","homingBot","helicopterBug"],jr=e=>e.type==="slidingBlock"?e.config.style==="puck":e.type==="monster"?dt.includes(e.config.which):lt.includes(e.type),ft=e=>e.type==="head"||e.type==="heels"||e.type==="headOverHeels";function Xr(e){return ut.includes(e.type)}const ut=[...it,"monster","ball","charles","pushableBlock","movingPlatform","moveableDeadly","pickup","portableBlock","slidingBlock","slidingDeadly","spring","sceneryPlayer","sceneryCrown"],mt=["monster","deadlyBlock","moveableDeadly","slidingDeadly"];C(...mt);const yt=e=>e.config.times!==void 0,pt=C("portal");C("teleporter");C("heels");C("head");C("heels","headOverHeels");C("head","headOverHeels");C("lift");C("emitter");const gt=C("monster"),ht=C("floor");C("pickup");C("spring");const Dr=C("joystick");C("monster","movingPlatform");const Gr=e=>gt(e)&&e.config.which==="cyberman"&&e.state.everActivated===!1,ce=e=>({x:e.direction==="away"?e.tiles.length:e.direction==="towards"?e.times?.x:1,y:e.direction==="left"?e.tiles.length:e.direction==="right"?e.times?.y:1}),Ur=e=>e.type==="wall"?ce(e.config):yt(e)?e.config.times:void 0,Je=(e=L)=>({x:e.x??1,y:e.y??1,z:e.z??1}),It=e=>({x:e.x??1,y:e.y??1}),W=e=>{const o=t=>t.config.times!==void 0;return e.type==="wall"?Je(ce(e.config)):o(e)?Je(e.config.times):L},io=e=>{const o={};let t=!1;return e.x!==1&&(o.x=e.x,t=!0),e.y!==1&&(o.y=e.y,t=!0),e.z!==1&&(o.z=e.z,t=!0),t?o:void 0};function*so(e,o,t){for(const r of Ve(e)){const[n,c]=r;if(c===null||c.type!=="wall"||c.config.direction!==o)continue;const{position:d,config:l}=c,u=It(ce(l)),i=xo(Se(l.direction)),f=Se(l.direction),a=Ke(t,d);if(a[f]!==0||a[i]<-1||a[i]>=u[i])continue;if(a[i]===0&&u[i]===2){yield[n,null];continue}const s=2+a[i];if(s===1||s===2){const h=U(c,E=>{E.position=A(d,{[i]:s});const R=E.config;switch(R.direction){case"towards":case"right":R.times[i]=u[i]-s;break;default:R.tiles=R.tiles.slice(s)}});yield[n,h];continue}const p=u[i]-a[i];if(p===2||p===1){const h=U(c,E=>{const R=E.config;switch(R.direction){case"towards":case"right":R.times[i]=u[i]-p;break;default:R.tiles=R.tiles.slice(0,-p)}});yield[n,h];continue}const y=U(c,h=>{const E=h.config;switch(E.direction){case"towards":case"right":E.times[i]=a[i];break;default:E.tiles=E.tiles.slice(0,a[i])}});yield[`${n}/beforeDoor`,y];const I=U(c,h=>{h.position={...d,[i]:t[i]+2};const E=h.config;switch(E.direction){case"towards":case"right":E.times[i]=u[i]-a[i]-2;break;default:E.tiles=E.tiles.slice(a[i]+2)}});yield[`${n}/afterDoor`,I],yield[n,null]}}const Le=(e,o,t,r,n)=>{const c=ve(e,o);if(c===void 0)throw new Error("can't cut hole in walls for a room that does not exist");const d=no(e,n,o);for(const[l,u]of so(c.items,t,r))n?d[l]=u:u===null?delete d[l]:d[l]=u},vt=e=>Ye(e.items),xt=e=>Ze(e),wt=e=>q(vt(e)),_=(e,...o)=>{const t=q(xt(e));return o.length===0?t:t.filter(([,r])=>o.includes(r.type))},bt=({state:e,fromRoomJson:o,direction:t,isPreview:r,autoAddRooms:n})=>{const c=e.campaignInProgress,d=q(B({campaign:c,roomId:o.id})).find(({gridPosition:l})=>bo(l,j[t]));if(d)return c.rooms[d.roomId];if(!r)return n?we(e,o.planet):void 0},Rt=e=>_(e.items,"floor").reduce((o,[,t])=>{const r=t.position.y;return Math.min(o,r)},Number.POSITIVE_INFINITY),Et=e=>_(e.items,"floor").reduce((o,[,t])=>{const r=t.position.y+t.config.times.y;return Math.max(o,r)},Number.NEGATIVE_INFINITY),zt=e=>_(e.items,"floor").reduce((o,[,t])=>{const r=t.position.x;return Math.min(o,r)},Number.POSITIVE_INFINITY),kt=e=>_(e.items,"floor").reduce((o,[,t])=>{const r=t.position.x+t.config.times.x;return Math.max(o,r)},Number.NEGATIVE_INFINITY),At=(e,o,t,r,n)=>{const c=T(e),d=t;Le(e,c.id,d,o,n);const l=r.config.toRoom==="+";console.log("autoAddRooms:",l);const u=bt({state:e,fromRoomJson:c,direction:d,isPreview:n,autoAddRooms:l}),[i,f]=xe(e,{type:"door",config:{...r.config,toRoom:u?u.id:r.config.toRoom,direction:d}},o,n);if(!n&&u){const a=be(u,r,n),s={x:d==="left"?zt(u):d==="right"?kt(u):o.x,y:d==="away"?Rt(u):d==="towards"?Et(u):o.y,z:o.z},m=wo(d),p={type:"door",config:{toRoom:c.id,direction:m},position:s};u.items[a]=p,p.config.toDoor=i,f.config.toDoor=a,Le(e,u.id,m,s,!1)}};function je(e){var o="";return t(e),o;function t(n){if(n===null||typeof n!="object"||n.toJSON!=null)o+=JSON.stringify(n);else if(Array.isArray(n)){o+="[";var c=!1;n.forEach(function(l){c&&(o+=","),c=!0,l===void 0&&(l=null),t(l)}),o+="]"}else{o+="{";var d=Object.keys(n).filter(function(l){return n[l]!==void 0}).sort();d.forEach(function(l,u){return r(n,l,u)}),o+="}"}}function r(n,c,d){d>0&&(o+=","),o+=JSON.stringify(c),o+=":",t(n[c])}}const Yr=(e,...o)=>{const t={};for(const r of o)t[r]=e[r];return t},Xe=(e,...o)=>{const t={...e};for(const r of o)delete t[r];return t},Re=e=>Qe(Ee(e))>0,Ee=e=>{switch(e.type){case"deadlyBlock":return L;case"conveyor":if(e.config.disappearing)return ne;switch(e.config.direction){case"left":case"right":return{x:1,y:0,z:0};case"away":case"towards":return{x:0,y:1,z:0};default:throw e.config.direction,new Error}case"hushPuppy":return L;case"teleporter":return{x:1,y:1,z:0};case"floor":case"spikes":return{x:1,y:1,z:0};case"block":return L;case"barrier":if(e.config.disappearing)return ne;switch(e.config.axis){case"x":return{x:1,y:0,z:1};case"y":return{x:0,y:1,z:1};default:throw e.config.axis,new Error}case"wall":switch(e.config.direction){case"left":case"right":return{x:0,y:1,z:1};case"away":case"towards":return{x:1,y:0,z:1};default:throw e.config,new Error}default:return ne}};class se{#t;#o;#e;constructor(o,t){this.#o={x:-o.x,y:-o.y,z:-o.z},this.#e={x:t.x-o.x+1,y:t.y-o.y+1,z:t.z-o.z+1},this.#t=Array.from({length:this.#e.x},()=>Array.from({length:this.#e.y},()=>Array.from({length:this.#e.z},()=>new Set)))}static fromItems(o){let t=1/0,r=1/0,n=1/0,c=-1/0,d=-1/0,l=-1/0;const u=[...o];for(const[,f]of u){const{x:a,y:s,z:m}=f.position,p=W(f);t=Math.min(t,a),r=Math.min(r,s),n=Math.min(n,m),c=Math.max(c,a+p.x-1),d=Math.max(d,s+p.y-1),l=Math.max(l,m+p.z-1)}if(u.length===0)return new se({x:0,y:0,z:0},{x:0,y:0,z:0});const i=new se({x:t,y:r,z:n},{x:c,y:d,z:l});for(const f of u){const[,a]=f,{x:s,y:m,z:p}=a.position,g=W(a);for(let y=0;y<g.x;y++)for(let I=0;I<g.y;I++)for(let h=0;h<g.z;h++)i.add({x:s+y,y:m+I,z:p+h},f)}return i}get(o){const t=o.x+this.#o.x,r=o.y+this.#o.y,n=o.z+this.#o.z;if(this.#r(t,r,n))return this.#t[t][r][n]}set(o,t){const r=o.x+this.#o.x,n=o.y+this.#o.y,c=o.z+this.#o.z;this.#r(r,n,c)&&(this.#t[r][n][c]=t)}add(o,t){const r=this.get(o);r&&r.add(t)}remove(o,t){const r=this.get(o);r&&r.delete(t)}get size(){return{...this.#e}}get minBounds(){return{x:-this.#o.x,y:-this.#o.y,z:-this.#o.z}}get maxBounds(){const o=this.minBounds;return{x:o.x+this.#e.x-1,y:o.y+this.#e.y-1,z:o.z+this.#e.z-1}}*iterate(){const{minBounds:o}=this;for(let t=0;t<this.#e.x;t++)for(let r=0;r<this.#e.y;r++)for(let n=0;n<this.#e.z;n++)yield[{x:t+o.x,y:r+o.y,z:n+o.z},this.#t[t][r][n]]}extractUniqueItems(){const o=new Set,t=[];for(const[,r]of this.iterate())for(const n of r)o.has(n)||(o.add(n),t.push(n));return t}#r(o,t,r){return o>=0&&o<this.#e.x&&t>=0&&t<this.#e.y&&r>=0&&r<this.#e.z}}const $=e=>e.type==="wall"?`wall/${e.config.direction}`:e.type==="teleporter"?je({type:e.type,config:Xe(e.config,"toPosition","times")}):je({type:e.type,config:Xe(e.config,"times")}),St=e=>Re(e[1]),Ct=e=>({x:Math.floor(e.x%1*ie.x),y:Math.floor(e.y%1*ie.y)}),Pt=(e,o)=>`${e},${o}`,Tt=(e,o)=>{let t=e,r=t.length;for(;;){const n=[...Ot(t,o)];if(n.length===r)return n;r=n.length,t=n}},Ft=(e,o=()=>!0)=>{const t=new Map,r=[];for(const c of e){const[,d]=c;if(!o(c))r.push(c);else if(Re(d)){const l=Ct(d.position),u=Pt(l.x,l.y);t.has(u)||t.set(u,[]),t.get(u).push(c)}else r.push(c)}const n=[];for(const[c,d]of t)if(d.length>0){const l=d.map(([m,p])=>[m,{...p,position:{x:Math.floor(p.position.x),y:Math.floor(p.position.y),z:p.position.z}}]),u=Tt(l,o),[i,f]=c.split(",").map(Number),a=i/ie.x,s=f/ie.y;for(const[m,p]of u)n.push([m,{...p,position:{x:p.position.x+a,y:p.position.y+s,z:p.position.z}}])}return[...n,...r]},Ot=(e,o=()=>!0)=>{const t=[],r=[];for(const s of e)o(s)&&St(s)?t.push(s):r.push(s);const n=se.fromItems(t),c=n.size,{minBounds:d}=n,l=new Map,u=new Map;for(const[,s]of n.iterate())for(const[,m]of s){const p=$(m);u.has(p)||u.set(p,m)}for(const[s]of u)l.set(s,Array.from({length:c.x},()=>Array.from({length:c.y},()=>Array(c.z).fill(!1))));const i=(s,m)=>{const p=W(m),g={x:s.x+p.x-1,y:s.y+p.y-1,z:s.z+p.z-1},y=Ee(m),I=$(m),h=new Set;h.add(m);const E=x=>{const k=new Set;let z=!1;for(let{x:v}=s;v<=x.x;v++)for(let{y:w}=s;w<=x.y;w++)for(let{z:b}=s;b<=x.z;b++){const P=n.get({x:v,y:w,z:b});let N=!1,J=!1;if(P)for(const[,F]of P)$(F)===I?(N=!0,k.add(F)):Re(F)&&F.type!=="wall"&&(J=!0);J&&!N&&(z=!0),(!P||P.size===0)&&(z=!0),N||(z=!0)}if(z)return!1;let S=!1;for(const v of k)h.has(v)||(S=!0,h.add(v));if(!S)return!1;for(const v of k){const w=W(v),b={x:v.position.x+w.x-1,y:v.position.y+w.y-1,z:v.position.z+w.z-1};if(v.position.x<s.x||v.position.y<s.y||v.position.z<s.z||b.x>x.x||b.y>x.y||b.z>x.z)return!1}return!0};let R=!0;for(;R;){if(R=!1,y.x>0&&g.x+1<d.x+c.x){let x=g.x;for(let{y:k}=s;k<=g.y;k++)for(let{z}=s;z<=g.z;z++){const S=n.get({x:g.x+1,y:k,z});if(S){for(const[,v]of S)if($(v)===I){const w=W(v),b=v.position.x+w.x-1;x=Math.max(x,b)}}}x>g.x&&E({...g,x})&&(g.x=x,R=!0)}if(y.y>0&&g.y+1<d.y+c.y){let x=g.y;for(let{x:k}=s;k<=g.x;k++)for(let{z}=s;z<=g.z;z++){const S=n.get({x:k,y:g.y+1,z});if(S){for(const[,v]of S)if($(v)===I){const w=W(v),b=v.position.y+w.y-1;x=Math.max(x,b)}}}x>g.y&&E({...g,y:x})&&(g.y=x,R=!0)}if(y.z>0&&g.z+1<d.z+c.z){let x=g.z;for(let{x:k}=s;k<=g.x;k++)for(let{y:z}=s;z<=g.y;z++){const S=n.get({x:k,y:z,z:g.z+1});if(S){for(const[,v]of S)if($(v)===I){const w=W(v),b=v.position.z+w.z-1;x=Math.max(x,b)}}}x>g.z&&E({...g,z:x})&&(g.z=x,R=!0)}}return g},f=(s,m)=>{if(s.type==="wall"){if(m.type!=="wall")throw new Error("only walls can join walls");if(s.config.direction!==m.config.direction)throw new Error("walls must have the same direction to join");return s.config.direction==="right"||s.config.direction==="towards"?s:{...s,config:{...s.config,tiles:[...s.config.tiles,...m.config.tiles]}}}return s},a=({x:s,y:m,z:p},{x:g,y,z:I},h)=>{const[E,R]=h,x=$(R),k=g-s+1,z=y-m+1,S=I-p+1;let v=R;if(k+z+S>3){const w={...R.config};if(R.type==="wall")switch(R.config.direction){case"away":case"left":break;case"towards":k!==1&&(w.times={x:k});break;case"right":z!==1&&(w.times={y:z});break}else{const b={...io(W(R))};k!==1&&(b.x=k),z!==1&&(b.y=z),S!==1&&(b.z=S),w.times=b}v={...R,config:w}}for(let w=s;w<=g;w++)for(let b=m;b<=y;b++)for(let P=p;P<=I;P++)if(l.get(x)[w-d.x][b-d.y][P-d.z]=!0,w!==s||b!==m||P!==p){const N=n.get({x:w,y:b,z:P});if(N)e:for(const J of N){const[,F]=J;if($(F)===x){F.position.x===w&&F.position.y===b&&F.position.z===P&&(v=f(v,F)),n.remove({x:w,y:b,z:P},J);break e}}}return[E,v]};for(const[s,m]of n.iterate())for(const p of m){const[,g]=p;if(g.position.x===s.x&&g.position.y===s.y&&g.position.z===s.z){const y=$(g),I=l.get(y),h=s.x-d.x,E=s.y-d.y,R=s.z-d.z;if(I&&!I[h][E][R]){const x=i(s,g),k=a(s,x,p);n.remove(s,p),n.add(s,k)}}}return[...n.extractUniqueItems(),...r]},ao=(e,o)=>Object.fromEntries(Ft(Object.entries(e),o)),co=(e,o)=>{const t=T(e);t.items=ao(t.items,o);const r=e.selectedJsonItemIds.filter(n=>t.items[n]!==void 0);r.length!==e.selectedJsonItemIds.length&&(e.selectedJsonItemIds=r)},$t=e=>e.type==="door",Wt=e=>e.type==="monster"&&e.config.which==="cyberman",_t={applyItemTool(e,{payload:{blockPosition:o,pointedAtItemJson:t,preview:r}}){const n=e,{tool:c}=n;if(c.type!=="item")throw new Error("applying item tool reducer while the current tool is not an item tool");switch(r||(H(n),n.previewedEdits={}),n.selectedJsonItemIds=[],!0){case $t(c.item):{if(t.type!=="wall")throw new Error("doors can only be added on walls");At(n,o,t.config.direction,c.item,r);break}case(Wt(c.item)&&t.type==="deadlyBlock"&&t.config.style==="toaster"&&t.position.z+1===o.z):{xe(n,{...c.item,config:{...c.item.config,activated:"off"}},o,r);break}default:xe(n,c.item,o,r)}r||co(n,d=>d.type==="wall")}},Mt={changeDragInProgress(e,{payload:o}){const t=e;t.dragInProgress=o}},qt={changeGridResolution(e,{payload:o}){const t=e;t.halfGridResolution=o},changeWallsFloorsLocked(e,{payload:o}){const t=e;t.wallsFloorsLocked=o}},Nt={setSelectedItemsInRoom(e,{payload:{jsonItemIds:o}}){e.selectedJsonItemIds=o},toggleSelectedItemInRoom(e,{payload:{jsonItemId:o}}){const t=e.selectedJsonItemIds.indexOf(o);t===-1?e.selectedJsonItemIds.push(o):e.selectedJsonItemIds.splice(t,1)},setHoveredItemInRoom(e,o){e.hoveredItem=o.payload},setClickableAnnotationHovered(e,o){e.clickableAnnotationHovered=o.payload}},Bt=(e,...o)=>({x:e(...o.map(t=>t.x)),y:e(...o.map(t=>t.y)),z:e(...o.map(t=>t.z))}),De=(e,o,t)=>{const r=t-e.length;r>0?e.push(...X(o,r,e.length)):r<0&&e.splice(t)},Ht=e=>e==="towards"||e==="right";function*lo(e,o){const t={type:"wall",config:Ht(e.config.direction)?e.config.direction==="towards"?{direction:e.config.direction,times:{x:2}}:{direction:e.config.direction,times:{y:2}}:{direction:e.config.direction,tiles:[...X(o.planet,2,e.position[e.config.direction==="away"?"x":"y"])]},position:{...e.position,z:0}};yield[be(o,t,!1),t]}function fo(e,o){const t=ce(e.config),r=A(o.position,o.config.times);switch(e.config.direction){case"towards":if(e.position.y===o.position.y&&e.position.x>=o.position.x&&e.position.x<r.x)return{tangentAxis:"x",normalAxis:"y",edgePosition:e.position.y,wallStart:e.position.x,wallLength:t.x??1,isOnFloorEdge:!0,wallFullySpansFloor:e.position.x===o.position.x&&t.x===o.config.times.x,wallTouchesFloorEnd:e.position.x+(t.x??1)===r.x};break;case"right":if(e.position.x===o.position.x&&e.position.y>=o.position.y&&e.position.y<r.y)return{tangentAxis:"y",normalAxis:"x",edgePosition:e.position.x,wallStart:e.position.y,wallLength:t.y??1,isOnFloorEdge:!0,wallFullySpansFloor:e.position.y===o.position.y&&t.y===o.config.times.y,wallTouchesFloorEnd:e.position.y+(t.y??1)===r.y};break;case"away":if(e.position.y===o.position.y+o.config.times.y&&e.position.x>=o.position.x&&e.position.x<r.x)return{tangentAxis:"x",normalAxis:"y",edgePosition:e.position.y,wallStart:e.position.x,wallLength:t.x??1,isOnFloorEdge:!0,wallFullySpansFloor:e.position.x===o.position.x&&t.x===o.config.times.x,wallTouchesFloorEnd:e.position.x+(t.x??1)===r.x};break;case"left":if(e.position.x===o.position.x+o.config.times.x&&e.position.y>=o.position.y&&e.position.y<r.y)return{tangentAxis:"y",normalAxis:"x",edgePosition:e.position.x,wallStart:e.position.y,wallLength:t.y??1,isOnFloorEdge:!0,wallFullySpansFloor:e.position.y===o.position.y&&t.y===o.config.times.y,wallTouchesFloorEnd:e.position.y+(t.y??1)===r.y};break}return null}function*uo(e,o,t,r,n){const c=A(o.position,r),d=o.config.times,l=n?A(d,n):o.config.times,u=A(o.position,d),i=A(c,l);for(const[f,a]of q(e)){if(a.type==="wall"&&a.position.z!==o.position.z)continue;if(a.type==="door"){const g=a.config;let y=!1,I={...O(a.position)};switch(g.direction){case"towards":a.position.y===o.position.y&&a.position.x>=o.position.x&&a.position.x<o.position.x+d.x&&(y=!0,I=A(a.position,r));break;case"right":a.position.x===o.position.x&&a.position.y>=o.position.y&&a.position.y<o.position.y+d.y&&(y=!0,I=A(a.position,r));break;case"away":a.position.y===o.position.y+d.y&&a.position.x>=o.position.x&&a.position.x<o.position.x+d.x&&(y=!0,I=A(a.position,{x:r.x,y:r.y+(n?.y??0),z:r.z}));break;case"left":a.position.x===o.position.x+d.x&&a.position.y>=o.position.y&&a.position.y<o.position.y+d.y&&(y=!0,I=A(a.position,{x:r.x+(n?.x??0),y:r.y,z:r.z}));break}if(y){const h=structuredClone(O(a));h.position=I,yield[f,h]}continue}const s=a,m=fo(s,o);if(!m||!m.isOnFloorEdge)continue;const p=structuredClone(O(s));switch(s.config.direction){case"towards":case"right":p.position=A(s.position,r);break;case"away":{const g=c.y+l.y;p.position={...s.position,x:s.position.x+r.x,y:g};break}case"left":{const g=c.x+l.x;p.position={...s.position,x:g,y:s.position.y+r.y};break}}if(m.wallFullySpansFloor){const g=l[m.tangentAxis];s.config.direction==="away"||s.config.direction==="left"?De(p.config.tiles,t,g):p.config.times={[m.tangentAxis]:g},yield[f,p]}else{const g=o.position[m.tangentAxis],y=u[m.tangentAxis],I=c[m.tangentAxis],h=i[m.tangentAxis],E=p.position[m.tangentAxis];if(E>=h){yield[f,null];continue}const R=Math.max(m.wallStart,g),k=Math.min(m.wallStart+m.wallLength,y)-R;let z;if(s.config.direction==="away"||s.config.direction==="left"){const b=o.position[m.normalAxis]+d[m.normalAxis],P=c[m.normalAxis]+l[m.normalAxis];z=b!==P}else z=o.position[m.normalAxis]!==c[m.normalAxis];const S=Math.max(E,I);let v;m.wallTouchesFloorEnd&&!z?v=h:v=Math.min(E+k,h);const w=v-S;w<=0?yield[f,null]:(s.config.direction==="away"||s.config.direction==="left"?De(p.config.tiles,t,w):p.config.times={[m.tangentAxis]:w},yield[f,p])}}}function*Jt(e,o,t,r){for(const[n,c]of _(e.items,"floor")){const d=fo(o,c);if(!d)continue;const l={x:0,y:0,z:0},u={x:0,y:0,z:0},i=t[d.normalAxis],f=t[d.tangentAxis],a=r?r[d.tangentAxis]:0;if(i!==0&&(o.config.direction==="towards"||o.config.direction==="right"?(l[d.normalAxis]=i,u[d.normalAxis]=-i):u[d.normalAxis]=i),f!==0&&(d.wallStart===c.position[d.tangentAxis]?(l[d.tangentAxis]=f,u[d.tangentAxis]=-f):d.wallTouchesFloorEnd&&(u[d.tangentAxis]=f)),a!==0&&d.wallTouchesFloorEnd&&(u[d.tangentAxis]=a),l.x!==0||l.y!==0||u.x!==0||u.y!==0){const s=A(c.config.times,u),m={...c,position:A(c.position,l),config:{...c.config,times:{x:s.x,y:s.y}}};yield[n,m]}yield*uo(_(e.items,"wall","door"),c,e.planet,l,u)}}const Lt={moveOrResizeItemAsPreview(e,{payload:{jsonItemIds:o,timesDelta:t,positionDelta:r}}){const n=e,c=T(n);for(const d of o){const l=oo(n,d);if(l===void 0)throw new Error(`no json item found for some of the ids in resize ${d}`);if(l.type==="wall"){for(const[i,f]of Jt(c,l,r,t))n.previewedEdits[i]=f;continue}if(l.type==="floor")for(const[i,f]of uo(_(c.items,"wall","door"),l,c.planet,r,t))n.previewedEdits[i]=f;if(l.type==="door"){console.log("before healing, room items are",O(c.items));for(const[i,f]of lo(l,O(c)))console.log("healing",`"${i}"`,f),n.previewedEdits[i]=f}const u={...l,position:A(l.position,r),config:{...l.config}};if(n.previewedEdits[d]=u,jt(u,t),l.type==="door"){console.log("before cutting room plus previews is",{...O(c.items),...O(n.previewedEdits)});for(const[i,f]of so({...O(c.items),...O(n.previewedEdits)},u.config.direction,u.position))console.log("cutting",`"${i}"`,f),n.previewedEdits[i]=f}}n.dragInProgress=!0}},jt=(e,o)=>{if(o!==void 0){const t=W(e),r=Ee(e),n=Ro(o,r);if(Qe(n)>0){const c=io(Bt((d,l)=>Math.max(1,d+l),t,n));c===void 0?delete e.config.times:e.config.times=c}}},Xt=(e,o)=>{const t=e.items[o];if(t.type==="door"){for(const[r,n]of lo(t,e))e.items[r]=n;e.items=ao(e.items)}delete e.items[o]},Ge=(e,o)=>{wt(e).filter(t=>t.type==="floor").filter(t=>t.position.z===0).forEach(t=>{t.config={...t.config,floorType:o,scenery:o==="standable"?e.planet:void 0}})},Dt={changeRoomColour(e,{payload:o}){const t=e,r=t.campaignInProgress.rooms[t.currentlyEditingRoomId].color;H(t),Object.assign(r,o)},changeRoomScenery(e,{payload:o}){const t=e,r=T(t);H(t),ro(r,o)},roomJsonEdited(e,{payload:o}){const t=e;t.campaignInProgress.rooms[t.currentlyEditingRoomId]=o},deleteSelected(e){const o=e,t=T(o);H(o),o.selectedJsonItemIds.forEach(r=>{Xt(t,r)}),o.selectedJsonItemIds=[]},clearRoom(e){const o=e,t=T(o);H(o);for(const r of eo(t.items)){const n=t.items[r];n.type!=="floor"&&n.type!=="wall"&&n.type!=="door"&&(delete t.items[r],o.selectedJsonItemIds=o.selectedJsonItemIds.filter(c=>c!==r))}},setRoomAboveOrBelow(e,{payload:o}){const t=e,r=o.direction==="above"?"roomAbove":"roomBelow",n=r==="roomAbove"?"roomBelow":"roomAbove",c=T(t),d=o.createNew?we(t,c.planet,c.color).id:o.roomId,l=c[r]&&ve(t,c[r]);l?.[n]===t.currentlyEditingRoomId&&(l[n]=void 0),c[r]=d;const u=d&&ve(t,d);u!==void 0&&(u[n]=c.id),u?Ge(r==="roomBelow"?c:u,"none"):Ge(r==="roomBelow"?c:l,"standable")}},Gt=(e,o)=>{const t=Ze(o);for(const[r,n]of t)n===null?delete e.items[r]:e.items[r]=n},Ut={setAutoCoalesce(e,o){e.autoCoalesce=o.payload},resetPreviewedEdits(e){e.previewedEdits={}},commitCurrentPreviewedEdits(e){H(e),Gt(T(e),e.previewedEdits),e.autoCoalesce&&co(e),e.previewedEdits={}}},ze="room_0",Yt={id:ze,...to({x:8,y:8})},Ue={name:"new campaign",rooms:{[ze]:Yt}},ke={campaignInProgress:Ue,savedCampaign:Ue,currentlyEditingRoomId:ze,editingRoomIdHistory:{back:[],forward:[]},previewedEdits:{},tool:{type:"pointer"},hoveredItem:void 0,clickableAnnotationHovered:!1,selectedJsonItemIds:[],halfGridResolution:!1,autoCoalesce:!0,wallsFloorsLocked:!0,dragInProgress:!1,history:{undo:[],redo:[]}},Vt={loadCampaign(e,{payload:{campaign:o}}){const t=e;t.savedCampaign=o,t.campaignInProgress=o,t.hoveredItem=void 0,t.selectedJsonItemIds=[],t.clickableAnnotationHovered=!1,t.dragInProgress=!1,t.history=ke.history;const r=Ie(eo(o.rooms));if(r===void 0)throw new Error("could not find any rooms in this campaign");t.currentlyEditingRoomId=r},campaignSaved(e,{payload:{campaign:o}}){const t=e;t.savedCampaign=o}},mo=(e,o)=>{if(!e.campaignInProgress.rooms[o]){console.warn(`can't change to room ${o} - it doesn't exist`);return}e.editingRoomIdHistory.back.push(e.currentlyEditingRoomId),e.currentlyEditingRoomId=o,e.clickableAnnotationHovered=!1,e.hoveredItem=void 0,e.selectedJsonItemIds=[],e.history=ke.history},Kt={changeToRoom(e,{payload:o}){mo(e,o)},roomBack(e){const o=e,{editingRoomIdHistory:t}=o;if(t.back.length===0)return;const r=t.back.pop();t.forward.push(o.currentlyEditingRoomId),o.currentlyEditingRoomId=r},roomForward(e){const o=e,{editingRoomIdHistory:t}=o;if(t.forward.length===0)return;const r=t.forward.pop();t.back.push(o.currentlyEditingRoomId),o.currentlyEditingRoomId=r}},Zt={addRoom(e){const o=e.campaignInProgress.rooms[e.currentlyEditingRoomId],t=we(e,o.planet);mo(e,t.id)},removeRoom(e){const o=e.campaignInProgress.rooms[e.currentlyEditingRoomId],r=Ie(_(o.items,"door","teleporter"))?.[1].config.toRoom??Ie(Lo(n=>n!==e.currentlyEditingRoomId,Eo(e.campaignInProgress.rooms)));r!==void 0&&(delete e.campaignInProgress.rooms[e.currentlyEditingRoomId],e.currentlyEditingRoomId=r)}},Ae=zo({name:"levelEditor",initialState:ke,reducers:{setTool(e,{payload:o}){const t=e;o.type==="item"&&(t.selectedJsonItemIds=[]),t.tool=o},injected(){},...qt,...Vo,..._t,...Mt,...Nt,...Dt,...Lt,...Ut,...Vt,...Zt,...Kt},selectors:{selectCurrentCampaignInProgress:e=>e.campaignInProgress,selectCurrentEditingRoomJson:T,selectItem:oo,selectCurrentEditingRoomColour:e=>T(e).color,selectCurrentEditingRoomScenery:e=>T(e).planet,selectTool:e=>e.tool,selectSelectedJsonItemIds:e=>e.selectedJsonItemIds,selectHoveredItem:e=>e.hoveredItem,selectItemIsSelected:Yo,...Ko}}),{addRoom:Qt,applyItemTool:er,campaignSaved:or,changeDragInProgress:tr,changeGridResolution:rr,changeRoomColour:nr,changeRoomScenery:ir,changeToRoom:sr,changeWallsFloorsLocked:ar,clearRoom:cr,commitCurrentPreviewedEdits:lr,deleteSelected:dr,injected:fr,loadCampaign:ur,moveOrResizeItemAsPreview:mr,redo:yr,removeRoom:pr,resetPreviewedEdits:gr,roomBack:hr,roomJsonEdited:Ir,setAutoCoalesce:vr,setClickableAnnotationHovered:xr,setHoveredItemInRoom:wr,setRoomAboveOrBelow:br,setSelectedItemsInRoom:Rr,setTool:Er,toggleSelectedItemInRoom:zr,undo:kr,roomForward:Ar}=Ae.actions,{selectCanRedo:Sr,selectCanUndo:Cr,selectCurrentCampaignInProgress:Pr,selectCurrentEditingRoomColour:Tr,selectCurrentEditingRoomJson:Fr,selectCurrentEditingRoomScenery:Or,selectHoveredItem:$r,selectItem:Wr,selectItemIsSelected:_r,selectSelectedJsonItemIds:Mr,selectTool:qr}=Ae.selectors,Nr=ko.withTypes(),Vr=Object.freeze(Object.defineProperty({__proto__:null,addRoom:Qt,applyItemTool:er,campaignSaved:or,changeDragInProgress:tr,changeGridResolution:rr,changeRoomColour:nr,changeRoomScenery:ir,changeToRoom:sr,changeWallsFloorsLocked:ar,clearRoom:cr,commitCurrentPreviewedEdits:lr,deleteSelected:dr,injected:fr,levelEditorSlice:Ae,loadCampaign:ur,moveOrResizeItemAsPreview:mr,redo:yr,removeRoom:pr,resetPreviewedEdits:gr,roomBack:hr,roomForward:Ar,roomJsonEdited:Ir,selectCanRedo:Sr,selectCanUndo:Cr,selectCurrentCampaignInProgress:Pr,selectCurrentEditingRoomColour:Tr,selectCurrentEditingRoomJson:Fr,selectCurrentEditingRoomScenery:Or,selectHoveredItem:$r,selectItem:Wr,selectItemIsSelected:_r,selectSelectedJsonItemIds:Mr,selectTool:qr,setAutoCoalesce:vr,setClickableAnnotationHovered:xr,setHoveredItemInRoom:wr,setRoomAboveOrBelow:br,setSelectedItemsInRoom:Rr,setTool:Er,toggleSelectedItemInRoom:zr,undo:kr,useAppSelectorWithLevelEditorSlice:Nr},Symbol.toStringTag,{value:"Module"}));export{xr as $,ut as A,j as B,ct as C,Yr as D,Je as E,ie as F,ce as G,Ht as H,W as I,ht as J,Lr as K,Xr as L,jt as M,Lo as N,mr as O,lr as P,hr as Q,Ar as R,vr as S,sr as T,C as U,yt as V,Ur as W,ft as X,Dr as Y,Gr as Z,jr as _,Er as a,$r as a0,Mr as a1,It as a2,Ee as a3,Bt as a4,tr as a5,Rr as a6,zr as a7,er as a8,wr as a9,gr as aa,oo as ab,Wr as ac,_r as ad,Re as ae,Ir as af,Vr as ag,Tr as b,rr as c,dr as d,nr as e,Or as f,ir as g,Cr as h,Sr as i,kr as j,yr as k,ar as l,Fr as m,X as n,cr as o,T as p,br as q,Fo as r,qr as s,Pr as t,Nr as u,or as v,ur as w,Qt as x,pr as y,Jr as z};
