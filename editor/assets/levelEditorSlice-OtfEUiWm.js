import{a5 as _,a6 as ae,a7 as j,a8 as O,a9 as G,aa as A,ab as we,ac as N,ad as be,ae as po,af as ne,ag as Ke,ah as Ze,ai as go,aj as ho,ak as Io,al as vo,am as xo,an as L,ao as wo,ap as Pe,aq as U,ar as Qe,as as bo,at as Ro,au as eo,av as Eo,aw as zo,ax as ko,ay as Ao}from"./index-DIc_YSPQ.js";var Y={},V={},Te;function So(){if(Te)return V;Te=1;function e(d,u){var i;if(typeof Symbol>"u"||d[Symbol.iterator]==null){if(Array.isArray(d)||(i=o(d))||u){i&&(d=i);var f=0,l=function(){};return{s:l,n:function(){return f>=d.length?{done:!0}:{done:!1,value:d[f++]}},e:function(y){throw y},f:l}}throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}var a=!0,m=!1,p;return{s:function(){i=d[Symbol.iterator]()},n:function(){var y=i.next();return a=y.done,y},e:function(y){m=!0,p=y},f:function(){try{!a&&i.return!=null&&i.return()}finally{if(m)throw p}}}}function o(d,u){if(d){if(typeof d=="string")return t(d,u);var i=Object.prototype.toString.call(d).slice(8,-1);if(i==="Object"&&d.constructor&&(i=d.constructor.name),i==="Map"||i==="Set")return Array.from(d);if(i==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return t(d,u)}}function t(d,u){(u==null||u>d.length)&&(u=d.length);for(var i=0,f=new Array(u);i<u;i++)f[i]=d[i];return f}var r=_(),n=r.ensureIterable;function s(d){var u=[],i=e(d),f;try{for(i.s();!(f=i.n()).done;){var l=f.value;u.push(l)}}catch(a){i.e(a)}finally{i.f()}return u}V.__toArray=s;function c(d){return s(n(d))}return V.toArray=c,V}var Fe;function Co(){if(Fe)return Y;Fe=1;var e=ae(),o=e.mark(c),t=_(),r=t.iterableCurry,n=So(),s=n.__toArray;function c(u,i){var f;return e.wrap(function(a){for(;;)switch(a.prev=a.next){case 0:if(f=Array.isArray(u)?u:s(u),f.length){a.next=3;break}return a.abrupt("return");case 3:if(!i--){a.next=7;break}return a.delegateYield(f,"t0",5);case 5:a.next=3;break;case 7:case"end":return a.stop()}},o)}Y.__cycleTimes=c;var d=r(c);return Y.cycleTimes=d,Y}var K={},Oe;function Po(){if(Oe)return K;Oe=1;var e=ae(),o=e.mark(d);function t(i,f){var l;if(typeof Symbol>"u"||i[Symbol.iterator]==null){if(Array.isArray(i)||(l=r(i))||f){l&&(i=l);var a=0,m=function(){};return{s:m,n:function(){return a>=i.length?{done:!0}:{done:!1,value:i[a++]}},e:function(h){throw h},f:m}}throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}var p=!0,g=!1,y;return{s:function(){l=i[Symbol.iterator]()},n:function(){var h=l.next();return p=h.done,h},e:function(h){g=!0,y=h},f:function(){try{!p&&l.return!=null&&l.return()}finally{if(g)throw y}}}}function r(i,f){if(i){if(typeof i=="string")return n(i,f);var l=Object.prototype.toString.call(i).slice(8,-1);if(l==="Object"&&i.constructor&&(l=i.constructor.name),l==="Map"||l==="Set")return Array.from(i);if(l==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(l))return n(i,f)}}function n(i,f){(f==null||f>i.length)&&(f=i.length);for(var l=0,a=new Array(f);l<f;l++)a[l]=i[l];return a}var s=_(),c=s.iterableCurry;function d(i,f){var l,a,m,p;return e.wrap(function(y){for(;;)switch(y.prev=y.next){case 0:l=0,a=t(i),y.prev=2,a.s();case 4:if((m=a.n()).done){y.next=11;break}if(p=m.value,!f(p,l++)){y.next=9;break}return y.next=9,p;case 9:y.next=4;break;case 11:y.next=16;break;case 13:y.prev=13,y.t0=y.catch(2),a.e(y.t0);case 16:return y.prev=16,a.f(),y.finish(16);case 19:case"end":return y.stop()}},o,null,[[2,13,16,19]])}K.__filter=d;var u=c(d);return K.filter=u,K}var Z={},$e;function To(){if($e)return Z;$e=1;var e=_(),o=e.iterableCurry,t=Co(),r=t.__cycleTimes;function n(c){return r(c,1/0)}Z.__cycle=n;var s=o(n);return Z.cycle=s,Z}var Q={},We;function Fo(){if(We)return Q;We=1;var e=ae(),o=e.mark(d);function t(i,f){var l;if(typeof Symbol>"u"||i[Symbol.iterator]==null){if(Array.isArray(i)||(l=r(i))||f){l&&(i=l);var a=0,m=function(){};return{s:m,n:function(){return a>=i.length?{done:!0}:{done:!1,value:i[a++]}},e:function(h){throw h},f:m}}throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}var p=!0,g=!1,y;return{s:function(){l=i[Symbol.iterator]()},n:function(){var h=l.next();return p=h.done,h},e:function(h){g=!0,y=h},f:function(){try{!p&&l.return!=null&&l.return()}finally{if(g)throw y}}}}function r(i,f){if(i){if(typeof i=="string")return n(i,f);var l=Object.prototype.toString.call(i).slice(8,-1);if(l==="Object"&&i.constructor&&(l=i.constructor.name),l==="Map"||l==="Set")return Array.from(i);if(l==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(l))return n(i,f)}}function n(i,f){(f==null||f>i.length)&&(f=i.length);for(var l=0,a=new Array(f);l<f;l++)a[l]=i[l];return a}var s=_(),c=s.iterableCurry;function d(i,f){var l,a,m,p;return e.wrap(function(y){for(;;)switch(y.prev=y.next){case 0:l=0,a=t(i),y.prev=2,a.s();case 4:if((m=a.n()).done){y.next=11;break}if(p=m.value,!(l++>=f)){y.next=9;break}return y.next=9,p;case 9:y.next=4;break;case 11:y.next=16;break;case 13:y.prev=13,y.t0=y.catch(2),a.e(y.t0);case 16:return y.prev=16,a.f(),y.finish(16);case 19:case"end":return y.stop()}},o,null,[[2,13,16,19]])}Q.__drop=d;var u=c(d);return Q.drop=u,Q}var ee={},oe={},Me;function Oo(){if(Me)return oe;Me=1;var e=_(),o=e.iterableCurry,t=e.callReturn;function r(s,c){var d=s[Symbol.iterator](),u=d.next(),i=u.value,f=u.done;return f?c:(t(d),i)}oe.__firstOr=r;var n=o(r,{reduces:!0});return oe.firstOr=n,oe}var _e;function $o(){if(_e)return ee;_e=1;var e=_(),o=e.iterableCurry,t=Oo(),r=t.__firstOr;function n(c){return r(c,void 0)}ee.__first=n;var s=o(n,{reduces:!0});return ee.first=s,ee}var te={},qe;function Wo(){if(qe)return te;qe=1;var e=ae(),o=e.mark(d);function t(i,f){var l;if(typeof Symbol>"u"||i[Symbol.iterator]==null){if(Array.isArray(i)||(l=r(i))||f){l&&(i=l);var a=0,m=function(){};return{s:m,n:function(){return a>=i.length?{done:!0}:{done:!1,value:i[a++]}},e:function(h){throw h},f:m}}throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}var p=!0,g=!1,y;return{s:function(){l=i[Symbol.iterator]()},n:function(){var h=l.next();return p=h.done,h},e:function(h){g=!0,y=h},f:function(){try{!p&&l.return!=null&&l.return()}finally{if(g)throw y}}}}function r(i,f){if(i){if(typeof i=="string")return n(i,f);var l=Object.prototype.toString.call(i).slice(8,-1);if(l==="Object"&&i.constructor&&(l=i.constructor.name),l==="Map"||l==="Set")return Array.from(i);if(l==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(l))return n(i,f)}}function n(i,f){(f==null||f>i.length)&&(f=i.length);for(var l=0,a=new Array(f);l<f;l++)a[l]=i[l];return a}var s=_(),c=s.iterableCurry;function d(i,f){var l,a,m,p;return e.wrap(function(y){for(;;)switch(y.prev=y.next){case 0:if(f!==0){y.next=2;break}return y.abrupt("return");case 2:l=0,a=t(i),y.prev=4,a.s();case 6:if((m=a.n()).done){y.next=14;break}return p=m.value,y.next=10,p;case 10:if(++l!==f){y.next=12;break}return y.abrupt("break",14);case 12:y.next=6;break;case 14:y.next=19;break;case 16:y.prev=16,y.t0=y.catch(4),a.e(y.t0);case 19:return y.prev=19,a.f(),y.finish(19);case 22:case"end":return y.stop()}},o,null,[[4,16,19,22]])}te.__take=d;var u=c(d);return te.take=u,te}var le,Ne;function Mo(){return Ne||(Ne=1,le=To().cycle),le}var _o=Mo();const qo=j(_o);var de,Je;function No(){return Je||(Je=1,de=Fo().drop),de}var Jo=No();const Bo=j(Jo);var fe,Be;function Ho(){return Be||(Be=1,fe=Po().filter),fe}var Lo=Ho();const Do=j(Lo);var ue,He;function Xo(){return He||(He=1,ue=$o().first),ue}var jo=Xo();const Ie=j(jo);var me,Le;function Go(){return Le||(Le=1,me=Wo().take),me}var Uo=Go();const Yo=j(Uo),P=e=>e.campaignInProgress.rooms[e.currentlyEditingRoomId],ve=(e,o)=>e.campaignInProgress.rooms[o],oo=(e,o,t)=>e.campaignInProgress.rooms[t??e.currentlyEditingRoomId]?.items[o],Vo=(e,o)=>e.selectedJsonItemIds.includes(o),q=e=>{const o=structuredClone(O(P(e))),{history:t}=e;t.redo=[],t.undo.push(o)},Ko={undo(e){const o=e,{campaignInProgress:t,history:{undo:r,redo:n},currentlyEditingRoomId:s}=o;r.length!==0&&(n.push(t.rooms[s]),t.rooms[s]=r.pop())},redo(e){const o=e,{campaignInProgress:t,history:{redo:r,undo:n},currentlyEditingRoomId:s}=o;r.length!==0&&(n.push(t.rooms[s]),t.rooms[s]=r.pop())}},Zo={selectCanUndo:e=>e.history.undo.length>0,selectCanRedo:e=>e.history.redo.length>0},ye={x:1,y:0,z:0},pe={x:-1,y:0,z:0},ge={x:0,y:-1,z:0},he={x:0,y:1,z:0},D={away:he,left:ye,right:pe,towards:ge,down:{x:0,y:0,z:-1},up:{x:0,y:0,z:1},awayRight:G(A(he,pe)),towardsRight:G(A(ge,pe)),towardsLeft:G(A(ge,ye)),awayLeft:G(A(he,ye))},jr={w:16,d:16,h:12},ie={x:16,y:16,z:12},Qo=(e,o,t)=>{if(o==="*")return!0;const r=t.meta.subRooms[o];return e.x>=r.physicalPosition.from.x&&e.y>=r.physicalPosition.from.y&&e.x<=r.physicalPosition.to.x&&e.y<=r.physicalPosition.to.y},et=({position:e},o,t)=>Qo(e,o,t),ot=(e,o,t)=>{if(o==="*")return 0;const r=t.meta.subRooms[o],{from:n,to:s}=r.physicalPosition;if(e.x>=n.x&&e.y>=n.y&&e.x<=s.x&&e.y<=s.y)return 0;let c=0,d=0;return e.x<n.x?c=n.x-e.x:e.x>s.x&&(c=e.x-s.x),e.y<n.y?d=n.y-e.y:e.y>s.y&&(d=e.y-s.y),c+d},tt=(e,o,t)=>{const r=t.meta?.subRooms;if(r===void 0)return"*";let n,s=1/0;const c=e;for(const d of we(r)){const u=ot(c,d,t);if(u===0)return d;u<s&&(s=u,n=d)}if(n===void 0)throw new Error(`item not found in any subroom of ${t.id}
      item at ðŸ“ ${JSON.stringify(c)}
      subrooms ${JSON.stringify(t.meta?.subRooms,null,2)}`);return n},re=(e,o,t,r)=>o.some(n=>n.config.direction===e)?"doorway":t===void 0?"wall":Object.values(t).some(({gridPosition:n})=>go(D[e],ho(n,r)))?"open":"wall";function*B(e){try{yield*rt(e)}catch(o){const t=o;throw new Error(`
  error in recursion ${e.roomId}/${e.subRoomId??"*"}`,{cause:t})}}function*rt({roomId:e,subRoomId:o="*",campaign:t,visited:r={},vectorFromPrevious:n,previousRoomGridPosition:s=ne}){if(e==="nowhere"||r[e]?.[o])return;r[e]===void 0&&(r[e]={}),r[e][o]=!0;const c=t.rooms[e];if(c===void 0)throw new Error(`no room in the campaign with id="${e}"`);const d=[...N(be(c.items)).filter(m=>m.type==="door").filter(m=>et(m,o,c))],u=A(s,n===void 0?po:n),i=c.meta?.subRooms;if(i){if(o==="*")throw new Error(`subRoomId '*' means 'all' and is not allowed for big rooms. Must be one of the sub-rooms in ${e}: ${Object.keys(i)}`);if(!i[o])throw new Error(`Sub-room ${o} not found in room ${e}. Available sub-rooms: ${Object.keys(i)}`)}const f=i?.[o].gridPosition,l={left:re("left",d,i,f),right:re("right",d,i,f),away:re("away",d,i,f),towards:re("towards",d,i,f)};if(yield{roomId:e,subRoomId:o,gridPosition:u,boundaries:l},i!==void 0){if(f===void 0)throw new Error(`Sub-room ${o} not found in room ${e}. Available sub-rooms: ${Object.keys(i)}`);for(const[m,{gridPosition:p}]of N(Ke(i)))m!==o&&(yield*B({roomId:e,subRoomId:m,campaign:t,visited:r,vectorFromPrevious:Ze({...p,z:0},f),previousRoomGridPosition:u}))}if(c.roomAbove!==void 0){const{roomAbove:m,subRoomAbove:p}=c;yield*B({roomId:m,subRoomId:p,campaign:t,visited:r,vectorFromPrevious:D.up,previousRoomGridPosition:u})}if(c.roomBelow!==void 0){const{roomBelow:m,subRoomBelow:p}=c;yield*B({roomId:m,subRoomId:p,campaign:t,visited:r,vectorFromPrevious:D.down,previousRoomGridPosition:u})}for(const m of d){const{toRoom:p}=m.config;try{yield*B({roomId:p,campaign:t,visited:r,subRoomId:m.config.meta?.toSubRoom,vectorFromPrevious:D[m.config.direction],previousRoomGridPosition:u})}catch(g){throw new Error(`error while traversing door ${JSON.stringify(m,null,2)} in room ${e} to room ${p}`,{cause:g})}}const a=c.meta?.nonContiguousRelationship;if(a!==void 0){const{with:{room:m},gridOffset:p}=a;yield*B({roomId:m,campaign:t,visited:r,subRoomId:"*",vectorFromPrevious:p,previousRoomGridPosition:u})}}const nt={jail:["bars"],blacktooth:["plain","plain","armour","shield","shield","armour"],bookworld:["book","book","cowboy"],egyptus:["hieroglyphics","hieroglyphics","hieroglyphics","sarcophagus","sarcophagus"],market:["passage","more-fruits","fruits","more-fruits","fruits"],moonbase:["coil","window1","window2","window3"],penitentiary:["loop","loop","skeleton"],safari:["wall","shield","wall","window","window","wall","shield"]},X=(e,o,t=0)=>{const r=qo(nt[e]);return Bo(t,Yo(o+t,r))},it=e=>({awayWall:{type:"wall",config:{direction:"away",tiles:Array.from(X("blacktooth",e.x))},position:{x:0,y:e.y,z:0}},leftWall:{type:"wall",config:{direction:"left",tiles:Array.from(X("blacktooth",e.y))},position:{x:e.x,y:0,z:0}},towardsWall:{type:"wall",config:{direction:"towards",times:{x:e.x}},position:{x:0,y:0,z:0}},rightWall:{type:"wall",config:{direction:"right",times:{y:e.y}},position:{x:0,y:0,z:0}}}),to=e=>({planet:"blacktooth",color:{hue:"cyan",shade:"basic"},items:{floor:{type:"floor",config:{floorType:"standable",scenery:"blacktooth",times:e},position:{x:0,y:0,z:0}},...it(e)}}),ro=(e,o)=>{e.planet=o;for(const t of Object.values(e.items))t.type==="floor"&&t.config.floorType==="standable"&&(t.config.scenery=o),t.type==="wall"&&(t.config.direction==="away"||t.config.direction==="left")&&(t.config.tiles=Array.from(X(o,t.config.tiles.length))),t.type==="pickup"&&t.config.gives==="crown"&&Io.includes(o)&&(t.config.planet=o)},st=e=>e[Math.floor(Math.random()*e.length)],Re=(e,o,t)=>{const n=`room_${N(vo({start:0})).find(d=>e.campaignInProgress.rooms[`room_${d}`]===void 0)}`,s=t??{hue:st(xo),shade:Math.random()<.66?"basic":"dimmed"},c={id:n,...structuredClone(to({x:8,y:8})),color:s};return ro(c,o),e.campaignInProgress.rooms[n]=c,c},Ee=(e,o,t)=>{if(o.type==="player"){const{which:n}=o.config;return t?`preview-${n}`:n}const r=o.type==="monster"?o.config.which:o.type;for(let n=1;;n++){const s=n===1?r:`${r}_${n}`;if(!e.items[s])return s}},xe=(e,o,t,r)=>{const n=P(e),s=Ee(n,o,r),c=no(e,r),d={type:o.type,config:o.config,position:t};return c[s]=d,[s,d]},no=(e,o,t=e.currentlyEditingRoomId)=>o?e.previewedEdits:e.campaignInProgress.rooms[t].items,at=["head","heels"],ct=[...at,"headOverHeels"],C=(...e)=>o=>e.includes(o.type),lt=C("bubbles","stopAutowalk","firedDoughnut","floatingText","emitter","particle"),dt=(e,o)=>lt(e)||It(e)&&(o!==void 0&&yt(o)||e.config.direction.z!==0)||xt(e)&&e.config.floorType==="none",Gr=(e,o)=>!dt(e,o),ft=["ball","slidingBlock","slidingDeadly"];C(...ft);const ut=["portableBlock","spring","sceneryPlayer","sceneryCrown","monster","slidingBlock"],mt=["dalek","turtle","elephantHead","homingBot","helicopterBug"],Ur=e=>e.type==="slidingBlock"?e.config.style==="puck":e.type==="monster"?mt.includes(e.config.which):ut.includes(e.type),yt=e=>e.type==="head"||e.type==="heels"||e.type==="headOverHeels";function Yr(e){return pt.includes(e.type)}const pt=[...ct,"monster","ball","charles","pushableBlock","movingPlatform","moveableDeadly","pickup","portableBlock","slidingBlock","slidingDeadly","spring","sceneryPlayer","sceneryCrown"],gt=["monster","deadlyBlock","moveableDeadly","slidingDeadly"];C(...gt);const ht=e=>e.config.times!==void 0,It=C("portal");C("teleporter");C("heels");C("head");C("heels","headOverHeels");C("head","headOverHeels");C("lift");C("emitter");const vt=C("monster"),xt=C("floor");C("pickup");C("spring");const Vr=C("joystick");C("monster","movingPlatform");const Kr=e=>vt(e)&&e.config.which==="cyberman"&&e.state.everActivated===!1,ce=e=>({x:e.direction==="away"?e.tiles.length:e.direction==="towards"?e.times?.x:1,y:e.direction==="left"?e.tiles.length:e.direction==="right"?e.times?.y:1}),Zr=e=>e.type==="wall"?ce(e.config):ht(e)?e.config.times:void 0,De=(e=L)=>({x:e.x??1,y:e.y??1,z:e.z??1}),wt=e=>({x:e.x??1,y:e.y??1}),W=e=>{const o=t=>t.config.times!==void 0;return e.type==="wall"?De(ce(e.config)):o(e)?De(e.config.times):L},io=e=>{const o={};let t=!1;return e.x!==1&&(o.x=e.x,t=!0),e.y!==1&&(o.y=e.y,t=!0),e.z!==1&&(o.z=e.z,t=!0),t?o:void 0};function*so(e,o,t){for(const r of Ke(e)){const[n,s]=r;if(s===null||s.type!=="wall"||s.config.direction!==o)continue;const{position:c,config:d}=s,u=wt(ce(d)),i=wo(Pe(d.direction)),f=Pe(d.direction),l=Ze(t,c);if(l[f]!==0||l[i]<-1||l[i]>=u[i])continue;if(l[i]===0&&u[i]===2){yield[n,null];continue}const a=2+l[i];if(a===1||a===2){const h=U(s,E=>{E.position=A(c,{[i]:a});const R=E.config;switch(R.direction){case"towards":case"right":R.times[i]=u[i]-a;break;default:R.tiles=R.tiles.slice(a)}});yield[n,h];continue}const p=u[i]-l[i];if(p===2||p===1){const h=U(s,E=>{const R=E.config;switch(R.direction){case"towards":case"right":R.times[i]=u[i]-p;break;default:R.tiles=R.tiles.slice(0,-p)}});yield[n,h];continue}const y=U(s,h=>{const E=h.config;switch(E.direction){case"towards":case"right":E.times[i]=l[i];break;default:E.tiles=E.tiles.slice(0,l[i])}});yield[`${n}/beforeDoor`,y];const I=U(s,h=>{h.position={...c,[i]:t[i]+2};const E=h.config;switch(E.direction){case"towards":case"right":E.times[i]=u[i]-l[i]-2;break;default:E.tiles=E.tiles.slice(l[i]+2)}});yield[`${n}/afterDoor`,I],yield[n,null]}}const Xe=(e,o,t,r,n)=>{const s=ve(e,o);if(s===void 0)throw new Error("can't cut hole in walls for a room that does not exist");const c=no(e,n,o);for(const[d,u]of so(s.items,t,r))n?c[d]=u:u===null?delete c[d]:c[d]=u},bt=e=>be(e.items),Rt=e=>Qe(e),ao=e=>N(bt(e)),M=(e,...o)=>{const t=N(Rt(e));return o.length===0?t:t.filter(([,r])=>o.includes(r.type))},Et=({state:e,fromRoomJson:o,subRoomId:t,direction:r,isPreview:n,autoAddRooms:s})=>{const c=e.campaignInProgress,d=B({campaign:c,roomId:o.id,subRoomId:t}),u=N(d).find(({gridPosition:i})=>Ro(i,D[r]));if(u)return c.rooms[u.roomId];if(!n)return s?Re(e,o.planet):void 0},zt=e=>M(e.items,"floor").reduce((o,[,t])=>{const r=t.position.y;return Math.min(o,r)},Number.POSITIVE_INFINITY),kt=e=>M(e.items,"floor").reduce((o,[,t])=>{const r=t.position.y+t.config.times.y;return Math.max(o,r)},Number.NEGATIVE_INFINITY),At=e=>M(e.items,"floor").reduce((o,[,t])=>{const r=t.position.x;return Math.min(o,r)},Number.POSITIVE_INFINITY),St=e=>M(e.items,"floor").reduce((o,[,t])=>{const r=t.position.x+t.config.times.x;return Math.max(o,r)},Number.NEGATIVE_INFINITY),Ct=(e,o,t,r,n)=>{const s=P(e),c=t;Xe(e,s.id,c,o,n);const d=r.config.toRoom==="+",u=tt(o,"block",s),i=Et({state:e,fromRoomJson:s,subRoomId:u,direction:c,isPreview:n,autoAddRooms:d}),[f,l]=xe(e,{type:"door",config:{...r.config,toRoom:i?i.id:r.config.toRoom,direction:c}},o,n);if(!n&&i){const a=Ee(i,r,n),m={x:c==="left"?At(i):c==="right"?St(i):o.x,y:c==="away"?zt(i):c==="towards"?kt(i):o.y,z:o.z},p=bo(c),g={type:"door",config:{toRoom:s.id,direction:p,meta:u==="*"?void 0:{toSubRoom:u}},position:m};i.items[a]=g,g.config.toDoor=f,l.config.toDoor=a,Xe(e,i.id,p,m,!1)}};function je(e){var o="";return t(e),o;function t(n){if(n===null||typeof n!="object"||n.toJSON!=null)o+=JSON.stringify(n);else if(Array.isArray(n)){o+="[";var s=!1;n.forEach(function(d){s&&(o+=","),s=!0,d===void 0&&(d=null),t(d)}),o+="]"}else{o+="{";var c=Object.keys(n).filter(function(d){return n[d]!==void 0}).sort();c.forEach(function(d,u){return r(n,d,u)}),o+="}"}}function r(n,s,c){c>0&&(o+=","),o+=JSON.stringify(s),o+=":",t(n[s])}}const Qr=(e,...o)=>{const t={};for(const r of o)t[r]=e[r];return t},Ge=(e,...o)=>{const t={...e};for(const r of o)delete t[r];return t},ze=e=>eo(ke(e))>0,ke=e=>{switch(e.type){case"deadlyBlock":return L;case"conveyor":if(e.config.disappearing)return ne;switch(e.config.direction){case"left":case"right":return{x:1,y:0,z:0};case"away":case"towards":return{x:0,y:1,z:0};default:throw e.config.direction,new Error}case"hushPuppy":return L;case"teleporter":return{x:1,y:1,z:0};case"floor":case"spikes":return{x:1,y:1,z:0};case"block":return L;case"barrier":if(e.config.disappearing)return ne;switch(e.config.axis){case"x":return{x:1,y:0,z:1};case"y":return{x:0,y:1,z:1};default:throw e.config.axis,new Error}case"wall":switch(e.config.direction){case"left":case"right":return{x:0,y:1,z:1};case"away":case"towards":return{x:1,y:0,z:1};default:throw e.config,new Error}default:return ne}};class se{#t;#o;#e;constructor(o,t){this.#o={x:-o.x,y:-o.y,z:-o.z},this.#e={x:t.x-o.x+1,y:t.y-o.y+1,z:t.z-o.z+1},this.#t=Array.from({length:this.#e.x},()=>Array.from({length:this.#e.y},()=>Array.from({length:this.#e.z},()=>new Set)))}static fromItems(o){let t=1/0,r=1/0,n=1/0,s=-1/0,c=-1/0,d=-1/0;const u=[...o];for(const[,f]of u){const{x:l,y:a,z:m}=f.position,p=W(f);t=Math.min(t,l),r=Math.min(r,a),n=Math.min(n,m),s=Math.max(s,l+p.x-1),c=Math.max(c,a+p.y-1),d=Math.max(d,m+p.z-1)}if(u.length===0)return new se({x:0,y:0,z:0},{x:0,y:0,z:0});const i=new se({x:t,y:r,z:n},{x:s,y:c,z:d});for(const f of u){const[,l]=f,{x:a,y:m,z:p}=l.position,g=W(l);for(let y=0;y<g.x;y++)for(let I=0;I<g.y;I++)for(let h=0;h<g.z;h++)i.add({x:a+y,y:m+I,z:p+h},f)}return i}get(o){const t=o.x+this.#o.x,r=o.y+this.#o.y,n=o.z+this.#o.z;if(this.#r(t,r,n))return this.#t[t][r][n]}set(o,t){const r=o.x+this.#o.x,n=o.y+this.#o.y,s=o.z+this.#o.z;this.#r(r,n,s)&&(this.#t[r][n][s]=t)}add(o,t){const r=this.get(o);r&&r.add(t)}remove(o,t){const r=this.get(o);r&&r.delete(t)}get size(){return{...this.#e}}get minBounds(){return{x:-this.#o.x,y:-this.#o.y,z:-this.#o.z}}get maxBounds(){const o=this.minBounds;return{x:o.x+this.#e.x-1,y:o.y+this.#e.y-1,z:o.z+this.#e.z-1}}*iterate(){const{minBounds:o}=this;for(let t=0;t<this.#e.x;t++)for(let r=0;r<this.#e.y;r++)for(let n=0;n<this.#e.z;n++)yield[{x:t+o.x,y:r+o.y,z:n+o.z},this.#t[t][r][n]]}extractUniqueItems(){const o=new Set,t=[];for(const[,r]of this.iterate())for(const n of r)o.has(n)||(o.add(n),t.push(n));return t}#r(o,t,r){return o>=0&&o<this.#e.x&&t>=0&&t<this.#e.y&&r>=0&&r<this.#e.z}}const $=e=>e.type==="wall"?`wall/${e.config.direction}`:e.type==="teleporter"?je({type:e.type,config:Ge(e.config,"toPosition","times")}):je({type:e.type,config:Ge(e.config,"times")}),Pt=e=>ze(e[1]),Tt=e=>({x:Math.floor(e.x%1*ie.x),y:Math.floor(e.y%1*ie.y)}),Ft=(e,o)=>`${e},${o}`,Ot=(e,o)=>{let t=e,r=t.length;for(;;){const n=[...Wt(t,o)];if(n.length===r)return n;r=n.length,t=n}},$t=(e,o=()=>!0)=>{const t=new Map,r=[];for(const s of e){const[,c]=s;if(!o(s))r.push(s);else if(ze(c)){const d=Tt(c.position),u=Ft(d.x,d.y);t.has(u)||t.set(u,[]),t.get(u).push(s)}else r.push(s)}const n=[];for(const[s,c]of t)if(c.length>0){const d=c.map(([m,p])=>[m,{...p,position:{x:Math.floor(p.position.x),y:Math.floor(p.position.y),z:p.position.z}}]),u=Ot(d,o),[i,f]=s.split(",").map(Number),l=i/ie.x,a=f/ie.y;for(const[m,p]of u)n.push([m,{...p,position:{x:p.position.x+l,y:p.position.y+a,z:p.position.z}}])}return[...n,...r]},Wt=(e,o=()=>!0)=>{const t=[],r=[];for(const a of e)o(a)&&Pt(a)?t.push(a):r.push(a);const n=se.fromItems(t),s=n.size,{minBounds:c}=n,d=new Map,u=new Map;for(const[,a]of n.iterate())for(const[,m]of a){const p=$(m);u.has(p)||u.set(p,m)}for(const[a]of u)d.set(a,Array.from({length:s.x},()=>Array.from({length:s.y},()=>Array(s.z).fill(!1))));const i=(a,m)=>{const p=W(m),g={x:a.x+p.x-1,y:a.y+p.y-1,z:a.z+p.z-1},y=ke(m),I=$(m),h=new Set;h.add(m);const E=x=>{const k=new Set;let z=!1;for(let{x:v}=a;v<=x.x;v++)for(let{y:w}=a;w<=x.y;w++)for(let{z:b}=a;b<=x.z;b++){const T=n.get({x:v,y:w,z:b});let J=!1,H=!1;if(T)for(const[,F]of T)$(F)===I?(J=!0,k.add(F)):ze(F)&&F.type!=="wall"&&(H=!0);H&&!J&&(z=!0),(!T||T.size===0)&&(z=!0),J||(z=!0)}if(z)return!1;let S=!1;for(const v of k)h.has(v)||(S=!0,h.add(v));if(!S)return!1;for(const v of k){const w=W(v),b={x:v.position.x+w.x-1,y:v.position.y+w.y-1,z:v.position.z+w.z-1};if(v.position.x<a.x||v.position.y<a.y||v.position.z<a.z||b.x>x.x||b.y>x.y||b.z>x.z)return!1}return!0};let R=!0;for(;R;){if(R=!1,y.x>0&&g.x+1<c.x+s.x){let x=g.x;for(let{y:k}=a;k<=g.y;k++)for(let{z}=a;z<=g.z;z++){const S=n.get({x:g.x+1,y:k,z});if(S){for(const[,v]of S)if($(v)===I){const w=W(v),b=v.position.x+w.x-1;x=Math.max(x,b)}}}x>g.x&&E({...g,x})&&(g.x=x,R=!0)}if(y.y>0&&g.y+1<c.y+s.y){let x=g.y;for(let{x:k}=a;k<=g.x;k++)for(let{z}=a;z<=g.z;z++){const S=n.get({x:k,y:g.y+1,z});if(S){for(const[,v]of S)if($(v)===I){const w=W(v),b=v.position.y+w.y-1;x=Math.max(x,b)}}}x>g.y&&E({...g,y:x})&&(g.y=x,R=!0)}if(y.z>0&&g.z+1<c.z+s.z){let x=g.z;for(let{x:k}=a;k<=g.x;k++)for(let{y:z}=a;z<=g.y;z++){const S=n.get({x:k,y:z,z:g.z+1});if(S){for(const[,v]of S)if($(v)===I){const w=W(v),b=v.position.z+w.z-1;x=Math.max(x,b)}}}x>g.z&&E({...g,z:x})&&(g.z=x,R=!0)}}return g},f=(a,m)=>{if(a.type==="wall"){if(m.type!=="wall")throw new Error("only walls can join walls");if(a.config.direction!==m.config.direction)throw new Error("walls must have the same direction to join");return a.config.direction==="right"||a.config.direction==="towards"?a:{...a,config:{...a.config,tiles:[...a.config.tiles,...m.config.tiles]}}}return a},l=({x:a,y:m,z:p},{x:g,y,z:I},h)=>{const[E,R]=h,x=$(R),k=g-a+1,z=y-m+1,S=I-p+1;let v=R;if(k+z+S>3){const w={...R.config};if(R.type==="wall")switch(R.config.direction){case"away":case"left":break;case"towards":k!==1&&(w.times={x:k});break;case"right":z!==1&&(w.times={y:z});break}else{const b={...io(W(R))};k!==1&&(b.x=k),z!==1&&(b.y=z),S!==1&&(b.z=S),w.times=b}v={...R,config:w}}for(let w=a;w<=g;w++)for(let b=m;b<=y;b++)for(let T=p;T<=I;T++)if(d.get(x)[w-c.x][b-c.y][T-c.z]=!0,w!==a||b!==m||T!==p){const J=n.get({x:w,y:b,z:T});if(J)e:for(const H of J){const[,F]=H;if($(F)===x){F.position.x===w&&F.position.y===b&&F.position.z===T&&(v=f(v,F)),n.remove({x:w,y:b,z:T},H);break e}}}return[E,v]};for(const[a,m]of n.iterate())for(const p of m){const[,g]=p;if(g.position.x===a.x&&g.position.y===a.y&&g.position.z===a.z){const y=$(g),I=d.get(y),h=a.x-c.x,E=a.y-c.y,R=a.z-c.z;if(I&&!I[h][E][R]){const x=i(a,g),k=l(a,x,p);n.remove(a,p),n.add(a,k)}}}return[...n.extractUniqueItems(),...r]},co=(e,o)=>Object.fromEntries($t(Object.entries(e),o)),lo=(e,o)=>{const t=P(e);t.items=co(t.items,o);const r=e.selectedJsonItemIds.filter(n=>t.items[n]!==void 0);r.length!==e.selectedJsonItemIds.length&&(e.selectedJsonItemIds=r)},Mt=e=>e.type==="door",_t=e=>e.type==="monster"&&e.config.which==="cyberman",qt={applyItemTool(e,{payload:{blockPosition:o,pointedAtItemJson:t,preview:r}}){const n=e,{tool:s}=n;if(s.type!=="item")throw new Error("applying item tool reducer while the current tool is not an item tool");switch(r||(q(n),n.previewedEdits={}),n.selectedJsonItemIds=[],!0){case Mt(s.item):{if(t.type!=="wall")throw new Error("doors can only be added on walls");Ct(n,o,t.config.direction,s.item,r);break}case(_t(s.item)&&t.type==="deadlyBlock"&&t.config.style==="toaster"&&t.position.z+1===o.z):{xe(n,{...s.item,config:{...s.item.config,activated:"off"}},o,r);break}default:xe(n,s.item,o,r)}r||lo(n,c=>c.type==="wall")}},Nt={changeDragInProgress(e,{payload:o}){const t=e;t.dragInProgress=o}},Jt={changeGridResolution(e,{payload:o}){const t=e;t.gridResolution=o},changeWallsFloorsLocked(e,{payload:o}){const t=e;t.wallsFloorsLocked=o}},Bt={setSelectedItemsInRoom(e,{payload:{jsonItemIds:o}}){const t=P(e).items;o.forEach(r=>{if(!t[r])throw new Error(`Item with json item id "${r}" is not in the current room`)}),e.selectedJsonItemIds=o},toggleSelectedItemInRoom(e,{payload:{jsonItemId:o}}){const t=e.selectedJsonItemIds.indexOf(o);t===-1?e.selectedJsonItemIds.push(o):e.selectedJsonItemIds.splice(t,1)},setHoveredItemInRoom(e,o){e.hoveredItem=o.payload},setClickableAnnotationHovered(e,o){e.clickableAnnotationHovered=o.payload}},Ht=(e,...o)=>({x:e(...o.map(t=>t.x)),y:e(...o.map(t=>t.y)),z:e(...o.map(t=>t.z))}),Ue=(e,o,t)=>{const r=t-e.length;r>0?e.push(...X(o,r,e.length)):r<0&&e.splice(t)},Lt=e=>e==="towards"||e==="right";function*fo(e,o){const t={type:"wall",config:Lt(e.config.direction)?e.config.direction==="towards"?{direction:e.config.direction,times:{x:2}}:{direction:e.config.direction,times:{y:2}}:{direction:e.config.direction,tiles:[...X(o.planet,2,e.position[e.config.direction==="away"?"x":"y"])]},position:{...e.position,z:0}};yield[Ee(o,t,!1),t]}function uo(e,o){const t=ce(e.config),r=A(o.position,o.config.times);switch(e.config.direction){case"towards":if(e.position.y===o.position.y&&e.position.x>=o.position.x&&e.position.x<r.x)return{tangentAxis:"x",normalAxis:"y",edgePosition:e.position.y,wallStart:e.position.x,wallLength:t.x??1,isOnFloorEdge:!0,wallFullySpansFloor:e.position.x===o.position.x&&t.x===o.config.times.x,wallTouchesFloorEnd:e.position.x+(t.x??1)===r.x};break;case"right":if(e.position.x===o.position.x&&e.position.y>=o.position.y&&e.position.y<r.y)return{tangentAxis:"y",normalAxis:"x",edgePosition:e.position.x,wallStart:e.position.y,wallLength:t.y??1,isOnFloorEdge:!0,wallFullySpansFloor:e.position.y===o.position.y&&t.y===o.config.times.y,wallTouchesFloorEnd:e.position.y+(t.y??1)===r.y};break;case"away":if(e.position.y===o.position.y+o.config.times.y&&e.position.x>=o.position.x&&e.position.x<r.x)return{tangentAxis:"x",normalAxis:"y",edgePosition:e.position.y,wallStart:e.position.x,wallLength:t.x??1,isOnFloorEdge:!0,wallFullySpansFloor:e.position.x===o.position.x&&t.x===o.config.times.x,wallTouchesFloorEnd:e.position.x+(t.x??1)===r.x};break;case"left":if(e.position.x===o.position.x+o.config.times.x&&e.position.y>=o.position.y&&e.position.y<r.y)return{tangentAxis:"y",normalAxis:"x",edgePosition:e.position.x,wallStart:e.position.y,wallLength:t.y??1,isOnFloorEdge:!0,wallFullySpansFloor:e.position.y===o.position.y&&t.y===o.config.times.y,wallTouchesFloorEnd:e.position.y+(t.y??1)===r.y};break}return null}function*mo(e,o,t,r,n){const s=A(o.position,r),c=o.config.times,d=n?A(c,n):o.config.times,u=A(o.position,c),i=A(s,d);for(const[f,l]of N(e)){if(l.type==="wall"&&l.position.z!==o.position.z)continue;if(l.type==="door"){const g=l.config;let y=!1,I={...O(l.position)};switch(g.direction){case"towards":l.position.y===o.position.y&&l.position.x>=o.position.x&&l.position.x<o.position.x+c.x&&(y=!0,I=A(l.position,r));break;case"right":l.position.x===o.position.x&&l.position.y>=o.position.y&&l.position.y<o.position.y+c.y&&(y=!0,I=A(l.position,r));break;case"away":l.position.y===o.position.y+c.y&&l.position.x>=o.position.x&&l.position.x<o.position.x+c.x&&(y=!0,I=A(l.position,{x:r.x,y:r.y+(n?.y??0),z:r.z}));break;case"left":l.position.x===o.position.x+c.x&&l.position.y>=o.position.y&&l.position.y<o.position.y+c.y&&(y=!0,I=A(l.position,{x:r.x+(n?.x??0),y:r.y,z:r.z}));break}if(y){const h=structuredClone(O(l));h.position=I,yield[f,h]}continue}const a=l,m=uo(a,o);if(!m||!m.isOnFloorEdge)continue;const p=structuredClone(O(a));switch(a.config.direction){case"towards":case"right":p.position=A(a.position,r);break;case"away":{const g=s.y+d.y;p.position={...a.position,x:a.position.x+r.x,y:g};break}case"left":{const g=s.x+d.x;p.position={...a.position,x:g,y:a.position.y+r.y};break}}if(m.wallFullySpansFloor){const g=d[m.tangentAxis];a.config.direction==="away"||a.config.direction==="left"?Ue(p.config.tiles,t,g):p.config.times={[m.tangentAxis]:g},yield[f,p]}else{const g=o.position[m.tangentAxis],y=u[m.tangentAxis],I=s[m.tangentAxis],h=i[m.tangentAxis],E=p.position[m.tangentAxis];if(E>=h){yield[f,null];continue}const R=Math.max(m.wallStart,g),k=Math.min(m.wallStart+m.wallLength,y)-R;let z;if(a.config.direction==="away"||a.config.direction==="left"){const b=o.position[m.normalAxis]+c[m.normalAxis],T=s[m.normalAxis]+d[m.normalAxis];z=b!==T}else z=o.position[m.normalAxis]!==s[m.normalAxis];const S=Math.max(E,I);let v;m.wallTouchesFloorEnd&&!z?v=h:v=Math.min(E+k,h);const w=v-S;w<=0?yield[f,null]:(a.config.direction==="away"||a.config.direction==="left"?Ue(p.config.tiles,t,w):p.config.times={[m.tangentAxis]:w},yield[f,p])}}}function*Dt(e,o,t,r){for(const[n,s]of M(e.items,"floor")){const c=uo(o,s);if(!c)continue;const d={x:0,y:0,z:0},u={x:0,y:0,z:0},i=t[c.normalAxis],f=t[c.tangentAxis],l=r?r[c.tangentAxis]:0;if(i!==0&&(o.config.direction==="towards"||o.config.direction==="right"?(d[c.normalAxis]=i,u[c.normalAxis]=-i):u[c.normalAxis]=i),f!==0&&(c.wallStart===s.position[c.tangentAxis]?(d[c.tangentAxis]=f,u[c.tangentAxis]=-f):c.wallTouchesFloorEnd&&(u[c.tangentAxis]=f)),l!==0&&c.wallTouchesFloorEnd&&(u[c.tangentAxis]=l),d.x!==0||d.y!==0||u.x!==0||u.y!==0){const a=A(s.config.times,u),m={...s,position:A(s.position,d),config:{...s.config,times:{x:a.x,y:a.y}}};yield[n,m]}yield*mo(M(e.items,"wall","door"),s,e.planet,d,u)}}const Xt={moveOrResizeItemAsPreview(e,{payload:{jsonItemIds:o,timesDelta:t,positionDelta:r}}){const n=e,s=P(n);for(const c of o){const d=oo(n,c);if(d===void 0)throw new Error(`no json item found for some of the ids in resize ${c}`);if(d.type==="wall"){for(const[i,f]of Dt(s,d,r,t))n.previewedEdits[i]=f;continue}if(d.type==="floor")for(const[i,f]of mo(M(s.items,"wall","door"),d,s.planet,r,t))n.previewedEdits[i]=f;if(d.type==="door"){console.log("before healing, room items are",O(s.items));for(const[i,f]of fo(d,O(s)))console.log("healing",`"${i}"`,f),n.previewedEdits[i]=f}const u={...d,position:A(d.position,r),config:{...d.config}};if(n.previewedEdits[c]=u,jt(u,t),d.type==="door"){console.log("before cutting room plus previews is",{...O(s.items),...O(n.previewedEdits)});for(const[i,f]of so({...O(s.items),...O(n.previewedEdits)},u.config.direction,u.position))console.log("cutting",`"${i}"`,f),n.previewedEdits[i]=f}}n.dragInProgress=!0}},jt=(e,o)=>{if(o!==void 0){const t=W(e),r=ke(e),n=Eo(o,r);if(eo(n)>0){const s=io(Ht((c,d)=>Math.max(1,c+d),t,n));s===void 0?delete e.config.times:e.config.times=s}}},Gt=(e,o)=>{const t=e.items[o];if(t.type==="door"){for(const[r,n]of fo(t,e))e.items[r]=n;e.items=co(e.items)}delete e.items[o]},Ut=(e,o)=>{const t=e.currentlyEditingRoomId,r=P(e);for(const n of be(e.campaignInProgress.rooms)){ao(n).filter(c=>c.type==="door"||c.type==="teleporter").filter(c=>c.config.toRoom===t).forEach(c=>{c.config.toRoom=o});const s=n.meta?.nonContiguousRelationship?.with;s?.room===t&&(s.room=o)}e.campaignInProgress.rooms[o]={...r,id:o},delete e.campaignInProgress.rooms[t],e.currentlyEditingRoomId=o},Ye=(e,o)=>{ao(e).filter(t=>t.type==="floor").filter(t=>t.position.z===0).forEach(t=>{t.config={...t.config,floorType:o,scenery:o==="standable"?e.planet:void 0}})},Yt={changeRoomColour(e,{payload:o}){const t=e,r=t.campaignInProgress.rooms[t.currentlyEditingRoomId].color;q(t),Object.assign(r,o)},changeRoomScenery(e,{payload:o}){const t=e,r=P(t);q(t),ro(r,o)},roomJsonEdited(e,{payload:o}){const t=e;q(t),t.campaignInProgress.rooms[t.currentlyEditingRoomId]=o;const r=t.selectedJsonItemIds.filter(n=>o.items[n]!==void 0);r.length!==t.selectedJsonItemIds.length&&(t.selectedJsonItemIds=r),o.id!==t.currentlyEditingRoomId&&Ut(t,o.id)},deleteSelected(e){const o=e,t=P(o);q(o),o.selectedJsonItemIds.forEach(r=>{Gt(t,r)}),o.selectedJsonItemIds=[]},clearRoom(e){const o=e,t=P(o);q(o);for(const r of we(t.items)){const n=t.items[r];n.type!=="floor"&&n.type!=="wall"&&n.type!=="door"&&(delete t.items[r],o.selectedJsonItemIds=o.selectedJsonItemIds.filter(s=>s!==r))}},setRoomAboveOrBelow(e,{payload:o}){const t=e,r=o.direction==="above"?"roomAbove":"roomBelow",n=r==="roomAbove"?"roomBelow":"roomAbove",s=P(t),c=o.createNew?Re(t,s.planet,s.color).id:o.roomId,d=s[r]&&ve(t,s[r]);d?.[n]===t.currentlyEditingRoomId&&(d[n]=void 0),s[r]=c;const u=c&&ve(t,c);u!==void 0&&(u[n]=s.id),u?Ye(r==="roomBelow"?s:u,"none"):Ye(r==="roomBelow"?s:d,"standable")}},Vt=(e,o)=>{const t=Qe(o);for(const[r,n]of t)n===null?delete e.items[r]:e.items[r]=n},Kt={setAutoCoalesce(e,o){e.autoCoalesce=o.payload},resetPreviewedEdits(e){e.previewedEdits={}},commitCurrentPreviewedEdits(e){q(e),Vt(P(e),e.previewedEdits),e.autoCoalesce&&lo(e),e.previewedEdits={}}},Ae="room_0",Zt={id:Ae,...to({x:8,y:8})},Ve={name:"new campaign",rooms:{[Ae]:Zt}},Se={campaignInProgress:Ve,savedCampaign:Ve,currentlyEditingRoomId:Ae,editingRoomIdHistory:{back:[],forward:[]},previewedEdits:{},tool:{type:"pointer"},hoveredItem:void 0,clickableAnnotationHovered:!1,selectedJsonItemIds:[],gridResolution:1,autoCoalesce:!0,wallsFloorsLocked:!0,dragInProgress:!1,history:{undo:[],redo:[]}},Qt={loadCampaign(e,{payload:{campaign:o}}){const t=e;t.savedCampaign=o,t.campaignInProgress=o,t.hoveredItem=void 0,t.selectedJsonItemIds=[],t.clickableAnnotationHovered=!1,t.dragInProgress=!1,t.history=Se.history;const r=Ie(we(o.rooms));if(r===void 0)throw new Error("could not find any rooms in this campaign");t.currentlyEditingRoomId=r},campaignSaved(e,{payload:{campaign:o}}){const t=e;t.savedCampaign=o}},yo=(e,o)=>{if(!e.campaignInProgress.rooms[o]){console.warn(`can't change to room ${o} - it doesn't exist`);return}e.editingRoomIdHistory.back.push(e.currentlyEditingRoomId),e.currentlyEditingRoomId=o,e.clickableAnnotationHovered=!1,e.hoveredItem=void 0,e.selectedJsonItemIds=[],e.history=Se.history},er={changeToRoom(e,{payload:o}){yo(e,o)},roomBack(e){const o=e,{editingRoomIdHistory:t}=o;if(t.back.length===0)return;const r=t.back.pop();t.forward.push(o.currentlyEditingRoomId),o.currentlyEditingRoomId=r},roomForward(e){const o=e,{editingRoomIdHistory:t}=o;if(t.forward.length===0)return;const r=t.forward.pop();t.back.push(o.currentlyEditingRoomId),o.currentlyEditingRoomId=r}},or={addRoom(e){const o=e.campaignInProgress.rooms[e.currentlyEditingRoomId],t=Re(e,o.planet);yo(e,t.id)},removeRoom(e){const o=e.campaignInProgress.rooms[e.currentlyEditingRoomId],r=Ie(M(o.items,"door","teleporter"))?.[1].config.toRoom??Ie(Do(n=>n!==e.currentlyEditingRoomId,zo(e.campaignInProgress.rooms)));r!==void 0&&(delete e.campaignInProgress.rooms[e.currentlyEditingRoomId],e.currentlyEditingRoomId=r)}},tr=[1,.5,.125],Ce=ko({name:"levelEditor",initialState:Se,reducers:{setTool(e,{payload:o}){const t=e;o.type==="item"&&(t.selectedJsonItemIds=[]),t.tool=o},injected(){},...Jt,...Ko,...qt,...Nt,...Bt,...Yt,...Xt,...Kt,...Qt,...or,...er},selectors:{selectCurrentCampaignInProgress:e=>e.campaignInProgress,selectCurrentEditingRoomJson:P,selectItem:oo,selectCurrentEditingRoomColour:e=>P(e).color,selectCurrentEditingRoomScenery:e=>P(e).planet,selectTool:e=>e.tool,selectSelectedJsonItemIds:e=>e.selectedJsonItemIds,selectHoveredItem:e=>e.hoveredItem,selectItemIsSelected:Vo,...Zo}}),{addRoom:rr,applyItemTool:nr,campaignSaved:ir,changeDragInProgress:sr,changeGridResolution:ar,changeRoomColour:cr,changeRoomScenery:lr,changeToRoom:dr,changeWallsFloorsLocked:fr,clearRoom:ur,commitCurrentPreviewedEdits:mr,deleteSelected:yr,injected:pr,loadCampaign:gr,moveOrResizeItemAsPreview:hr,redo:Ir,removeRoom:vr,resetPreviewedEdits:xr,roomBack:wr,roomJsonEdited:br,setAutoCoalesce:Rr,setClickableAnnotationHovered:Er,setHoveredItemInRoom:zr,setRoomAboveOrBelow:kr,setSelectedItemsInRoom:Ar,setTool:Sr,toggleSelectedItemInRoom:Cr,undo:Pr,roomForward:Tr}=Ce.actions,{selectCanRedo:Fr,selectCanUndo:Or,selectCurrentCampaignInProgress:$r,selectCurrentEditingRoomColour:Wr,selectCurrentEditingRoomJson:Mr,selectCurrentEditingRoomScenery:_r,selectHoveredItem:qr,selectItem:Nr,selectItemIsSelected:Jr,selectSelectedJsonItemIds:Br,selectTool:Hr}=Ce.selectors,Lr=Ao.withTypes(),en=Object.freeze(Object.defineProperty({__proto__:null,addRoom:rr,applyItemTool:nr,campaignSaved:ir,changeDragInProgress:sr,changeGridResolution:ar,changeRoomColour:cr,changeRoomScenery:lr,changeToRoom:dr,changeWallsFloorsLocked:fr,clearRoom:ur,commitCurrentPreviewedEdits:mr,deleteSelected:yr,gridResolutions:tr,injected:pr,levelEditorSlice:Ce,loadCampaign:gr,moveOrResizeItemAsPreview:hr,redo:Ir,removeRoom:vr,resetPreviewedEdits:xr,roomBack:wr,roomForward:Tr,roomJsonEdited:br,selectCanRedo:Fr,selectCanUndo:Or,selectCurrentCampaignInProgress:$r,selectCurrentEditingRoomColour:Wr,selectCurrentEditingRoomJson:Mr,selectCurrentEditingRoomScenery:_r,selectHoveredItem:qr,selectItem:Nr,selectItemIsSelected:Jr,selectSelectedJsonItemIds:Br,selectTool:Hr,setAutoCoalesce:Rr,setClickableAnnotationHovered:Er,setHoveredItemInRoom:zr,setRoomAboveOrBelow:kr,setSelectedItemsInRoom:Ar,setTool:Sr,toggleSelectedItemInRoom:Cr,undo:Pr,useAppSelectorWithLevelEditorSlice:Lr},Symbol.toStringTag,{value:"Module"}));export{Kr as $,vr as A,jr as B,pt as C,D,ft as E,Qr as F,De as G,ie as H,ce as I,Lt as J,W as K,xt as L,Gr as M,Yr as N,jt as O,Do as P,ke as Q,hr as R,mr as S,wr as T,Tr as U,Rr as V,C as W,ht as X,Zr as Y,yt as Z,Vr as _,Sr as a,Ur as a0,Er as a1,qr as a2,Br as a3,wt as a4,oo as a5,xr as a6,nr as a7,Ht as a8,zr as a9,Nr as aa,Jr as ab,Ar as ac,ze as ad,Cr as ae,sr as af,br as ag,en as ah,Wr as b,ar as c,yr as d,cr as e,_r as f,tr as g,lr as h,Or as i,Fr as j,Pr as k,Ir as l,fr as m,Mr as n,X as o,ur as p,P as q,Oo as r,Hr as s,dr as t,Lr as u,kr as v,$r as w,ir as x,gr as y,rr as z};
