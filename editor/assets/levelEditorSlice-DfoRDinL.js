import{r as J,g as uo,a9 as wt,i as Y,aa as Uo,ab as Je,ac as m,ad as vt,ae as R,af as ye,ag as no,ah as Co,ai as It,aj as zt,ak as go,al as Rt,am as ge,an as N,ao as Zo,ap as kt,aq as Ve,ar as Qo,as as Et,at as jo,au as Pt,av as oe,aw as to,ax as Ho,ay as ee,az as To,o as Ue,aA as pe,aB as me,aC as At,aD as Ct,aE as Tt,aF as St,aG as Ot,aH as Ft,aI as Ze,aJ as Nt,aK as q,aL as $t,aM as Wt,aN as Bt}from"./index-I2kZ5OMd.js";import{o as so,i as co,a as G}from"./RoomJson-BLI1E_zi.js";var po={},mo={},he;function Mt(){if(he)return mo;he=1;const{ensureIterable:o}=J();function e(i){const n=[];for(const s of i)n.push(s);return n}mo.__toArray=e;function t(i){return e(o(i))}return mo.toArray=t,mo}var xe;function _t(){if(xe)return po;xe=1;const{iterableCurry:o}=J(),{__toArray:e}=Mt();function*t(n,s){const r=Array.isArray(n)?n:e(n);if(r.length)for(;s--;)yield*r}po.__cycleTimes=t;const i=o(t);return po.cycleTimes=i,po}var ho={},be;function Xt(){if(be)return ho;be=1;const{iterableCurry:o}=J();function*e(i,n){let s=0;for(const r of i)n(r,s++)&&(yield r)}ho.__filter=e;const t=o(e);return ho.filter=t,ho}var xo={},we;function Dt(){if(we)return xo;we=1;const{iterableCurry:o}=J(),{__cycleTimes:e}=_t();function t(n){return e(n,1/0)}xo.__cycle=t;const i=o(t);return xo.cycle=i,xo}var bo={},ve;function Ht(){if(ve)return bo;ve=1;const{iterableCurry:o}=J();function*e(i,n){let s=0;for(const r of i)s++>=n&&(yield r)}bo.__drop=e;const t=o(e);return bo.drop=t,bo}var wo={},vo={},Ie;function Yt(){if(Ie)return vo;Ie=1;const{iterableCurry:o,callReturn:e}=J();function t(n,s){const r=n[Symbol.iterator](),{value:c,done:a}=r.next();return a?s:(e(r),c)}vo.__firstOr=t;const i=o(t,{reduces:!0});return vo.firstOr=i,vo}var ze;function Lt(){if(ze)return wo;ze=1;const{iterableCurry:o}=J(),{__firstOr:e}=Yt();function t(n){return e(n,void 0)}wo.__first=t;const i=o(t,{reduces:!0});return wo.first=i,wo}var Io={},Re;function qt(){if(Re)return Io;Re=1;const{iterableCurry:o}=J();function*e(i,n){if(n===0)return;let s=0;for(const r of i)if(yield r,++s===n)break}Io.__take=e;const t=o(e);return Io.take=t,Io}var So,ke;function Gt(){return ke||(ke=1,So=Dt().cycle),So}var Kt=Gt();const Jt=uo(Kt);var Oo,Ee;function Vt(){return Ee||(Ee=1,Oo=Ht().drop),Oo}var Ut=Vt();const Zt=uo(Ut);var Fo,Pe;function Qt(){return Pe||(Pe=1,Fo=Xt().filter),Fo}var jt=Qt();const oi=uo(jt);var No,Ae;function ei(){return Ae||(Ae=1,No=Lt().first),No}var ti=ei();const Yo=uo(ti);var $o,Ce;function ii(){return Ce||(Ce=1,$o=qt().take),$o}var ni=ii();const si=uo(ni),Qe=o=>()=>wt(o),Us=(o,e)=>e?.[o],ri=o=>so(o),io=o=>Y(ri(o)),ai=Symbol("roomSpatialIndexKey"),h={w:16,d:16,h:12},ro={x:16,y:16,z:12},ci=(o,e,t)=>{if(e==="*")return!0;const i=t.meta.subRooms[e];return o.x>=i.physicalPosition.from.x&&o.y>=i.physicalPosition.from.y&&o.x<=i.physicalPosition.to.x&&o.y<=i.physicalPosition.to.y},Zs=({position:o},e,t)=>ci(o,e,t),li=(o,e,t)=>{if(e==="*")return 0;const i=t.meta.subRooms[e],{from:n,to:s}=i.physicalPosition;if(o.x>=n.x&&o.y>=n.y&&o.x<=s.x&&o.y<=s.y)return 0;let r=0,c=0;return o.x<n.x?r=n.x-o.x:o.x>s.x&&(r=o.x-s.x),o.y<n.y?c=n.y-o.y:o.y>s.y&&(c=o.y-s.y),r+c},te=(o,e,t)=>{const i=t.meta?.subRooms;if(i===void 0)return"*";let n,s=1/0;const r=e==="fine"?{x:o.x/h.w,y:o.y/h.d}:o;for(const c of Uo(i)){const a=li(r,c,t);if(a===0)return c;a<s&&(s=a,n=c)}if(n===void 0)throw new Error(`item not found in any subroom of ${t.id}
      item at 📍 ${JSON.stringify(r)}
      subrooms ${JSON.stringify(t.meta?.subRooms,null,2)}`);return n},di=["head","heels"],fi=[...di,"headOverHeels"],ui="@@original",yi="original",Qs={userId:ui,campaignName:yi,version:-1},js=({x:o=0,y:e=0})=>e-o,X=({x:o=0,y:e=0,z:t=0})=>({x:e-o,y:-(o+e)/2-t}),or=(o,e,t)=>{const i=X(o),n=Je(t,i);return m(gi(e,n),o)},gi=(o,{x:e,y:t})=>{switch(vt(o)){case"xy":return{x:-e/2-t,y:e/2-t,z:0};case"xz":return{x:-e,y:0,z:e/2-t};case"yz":return{x:0,y:e,z:-e/2-t};default:throw new Error("only axis-aligned planes are supported for unprojection")}},S=({x:o=0,y:e=0,z:t=0})=>({x:o*h.w,y:e*h.d,z:t*h.h}),er=({x:o=0,y:e=0,z:t=0})=>({x:o/h.w,y:e/h.d,z:t/h.h}),tr=o=>X(S(o)),pi={floors:{edgeLeftX:Number.POSITIVE_INFINITY,edgeRightX:Number.NEGATIVE_INFINITY,topEdgeY:Number.POSITIVE_INFINITY,bottomEdgeY:Number.NEGATIVE_INFINITY},allItems:{topEdgeY:Number.POSITIVE_INFINITY}},mi=o=>io(o.items).reduce((e,t)=>{if(t.type==="floor"){const{config:{naturalFootprint:i},state:{position:n},renderAabb:s,renderAabbOffset:r,aabb:c}=t,a=X(m(i.position,{x:i.aabb.x,z:i.aabb.z})).x,d=X(m(i.position,{y:i.aabb.y,z:i.aabb.z})).x,f=X(m(i.position,i.aabb)).y,u=X(m(n,r??R,{z:(s??c).z})).y;return{allItems:e.allItems,floors:{edgeLeftX:Math.min(e.floors.edgeLeftX,a),edgeRightX:Math.max(e.floors.edgeRightX,d),topEdgeY:Math.min(e.floors.topEdgeY,f),bottomEdgeY:Math.max(e.floors.bottomEdgeY,u)}}}else{const i=X(m(t.state.position,t.renderAabb??t.aabb??R,t.renderAabbOffset??R)).y;return{allItems:{topEdgeY:Math.min(e.allItems.topEdgeY,i)},floors:e.floors}}},pi),hi={from:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY,z:Number.POSITIVE_INFINITY},to:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY,z:Number.NEGATIVE_INFINITY}},ir=o=>{const e=co(o).filter(t=>t.type==="floor").reduce((t,i)=>{const{position:n,config:{times:s}}=i;return{from:{x:Math.min(t.from.x,n.x),y:Math.min(t.from.y,n.y),z:Math.min(t.from.z,n.z)},to:{x:Math.max(t.to.x,n.x+s.x),y:Math.max(t.to.y,n.y+s.y),z:Math.max(t.to.z,n.z)}}},hi);if(isFinite(e.from.x))return e},xi={jail:["bars"],blacktooth:["plain","plain","armour","shield","shield","armour"],bookworld:["book","book","cowboy"],egyptus:["hieroglyphics","hieroglyphics","hieroglyphics","sarcophagus","sarcophagus"],market:["passage","more-fruits","fruits","more-fruits","fruits"],moonbase:["coil","window1","window2","window3"],penitentiary:["loop","loop","skeleton"],safari:["wall","shield","wall","window","window","wall","shield"]},lo=(o,e,t=0)=>{const i=Jt(xi[o]);return Zt(t,si(e+t,i))},bi=o=>({awayWall:{type:"wall",config:{direction:"away",tiles:Array.from(lo("blacktooth",o.x))},position:{x:0,y:o.y,z:0}},leftWall:{type:"wall",config:{direction:"left",tiles:Array.from(lo("blacktooth",o.y))},position:{x:o.x,y:0,z:0}},towardsWall:{type:"wall",config:{direction:"towards",times:{x:o.x}},position:{x:0,y:0,z:0}},rightWall:{type:"wall",config:{direction:"right",times:{y:o.y}},position:{x:0,y:0,z:0}}}),je=o=>({planet:"blacktooth",color:{hue:"cyan",shade:"basic"},items:{floor:{type:"floor",config:{floorType:"standable",scenery:"blacktooth",times:o},position:{x:0,y:0,z:0}},...bi(o)}}),ie="room_0",wi={id:ie,...je({x:8,y:8})},vi={meta:{published:!1},locator:{campaignName:void 0,userId:"anon",version:0},rooms:{[ie]:wi}},ne={campaignInProgress:vi,remoteCampaign:void 0,currentlyEditingRoomId:ie,editingRoomIdHistory:{back:[],forward:[]},previewedEdits:{},tool:{type:"pointer"},hoveredItem:void 0,clickableAnnotationHovered:!1,selectedJsonItemIds:[],gridResolution:1,autoCoalesce:!0,wallsFloorsLocked:!0,dragInProgress:!1,history:{undo:[],redo:[]}},se=({aabb:o,state:{position:e}},{aabb:t,state:{position:i}})=>!(e.x+o.x<=i.x||e.x>=i.x+t.x)&&!(e.y+o.y<=i.y||e.y>=i.y+t.y)&&!(e.z+o.z<=i.z||e.z>=i.z+t.z);function*nr(o,e){for(const t of e)o.id!==t.id&&se(o,t)&&(yield t)}const Ii=o=>!0;function*zi(o,e,t=Ii){const i=e.getItemCuboidNeighbourhood(o);for(const n of i)t(n)&&se(o,n)&&(yield n)}const Te={stopAutowalk:5,portal:5,wall:5,blocker:5,doorLegs:5,sceneryPlayer:5,bubbles:5,switch:10,button:10,doorFrame:15,ball:18,block:20,barrier:20,floor:20,hushPuppy:20,teleporter:20,lift:30,movingPlatform:30,pushableBlock:30,portableBlock:30,sceneryCrown:30,slidingBlock:30,spring:30,joystick:40,charles:40,conveyor:40,head:50,heels:50,headOverHeels:50,pickup:80,firedDoughnut:90,spikes:98,slidingDeadly:100,moveableDeadly:100,deadlyBlock:100,monster:100,floatingText:200,particle:200,emitter:200},Ri=(o,e)=>Te[o.type]-Te[e.type],C=(...o)=>{if(o.length===1){const[e]=o;return t=>t.type===e}return e=>o.includes(e.type)},ki=C("bubbles","stopAutowalk","firedDoughnut","floatingText","emitter","particle"),Ei=(o,e)=>ki(o)||Fi(o)&&(e!==void 0&&Ci(e)||o.config.direction.z!==0)||tt(o)&&o.config.floorType==="none",Lo=(o,e)=>!Ei(o,e),ot=["ball","slidingBlock","slidingDeadly"];C(...ot);const Pi=["portableBlock","spring","sceneryPlayer","sceneryCrown","monster","slidingBlock"],Ai=["dalek","turtle","elephantHead","homingBot","helicopterBug"],sr=o=>o.type==="slidingBlock"?o.config.style==="puck":o.type==="monster"?Ai.includes(o.config.which):Pi.includes(o.type),Ci=o=>o.type==="head"||o.type==="heels"||o.type==="headOverHeels";function Ti(o){return et.includes(o.type)}const et=[...fi,"monster","ball","charles","pushableBlock","movingPlatform","moveableDeadly","pickup","portableBlock","slidingBlock","slidingDeadly","spring","sceneryPlayer","sceneryCrown"],Si=["monster","deadlyBlock","moveableDeadly","slidingDeadly"];C(...Si);const Oi=o=>o.config.times!==void 0,Fi=C("portal");C("teleporter");const rr=C("heels");C("head");const ar=C("headOverHeels");C("heels","headOverHeels");C("head","headOverHeels");C("lift");C("button");C("emitter");const Ni=C("monster"),tt=C("floor");C("pickup");const cr=o=>o.type==="button"||o.type==="switch"&&o.config.type==="in-room";C("spring");const lr=C("joystick");C("conveyor");C("hushPuppy");C("firedDoughnut");const dr=C("wall","doorFrame");C("monster","movingPlatform");const fr=o=>Ni(o)&&o.config.which==="cyberman"&&o.state.everActivated===!1,$i=(o,e,t,i)=>{const n=Math.max(0,Math.min(o.x+e.x,t.x+i.x)-Math.max(o.x,t.x)),s=Math.max(0,Math.min(o.y+e.y,t.y+i.y)-Math.max(o.y,t.y));return n*s},Se=({state:{position:o},aabb:e},{state:{position:t},aabb:i})=>$i(o,e,t,i),V={state:{position:{x:0,y:0,z:0}},aabb:{x:0,y:0,z:0}},U={state:{position:{x:0,y:0,z:0}},aabb:{x:0,y:0,z:0}},Wi=(o,e,t=.001)=>{if(!Lo(e,o)||o.id===e.id)return!1;const{state:{vels:{gravity:{z:i}}}}=o;return i>0?!1:(V.state.position.x=o.state.position.x,V.state.position.y=o.state.position.y,V.state.position.z=o.state.position.z-ye,V.aabb.x=o.aabb.x,V.aabb.y=o.aabb.y,V.aabb.z=o.aabb.z+t+ye,U.state.position.x=e.state.position.x,U.state.position.y=e.state.position.y,U.state.position.z=e.state.position.z+e.aabb.z,U.aabb.x=e.aabb.x,U.aabb.y=e.aabb.y,U.aabb.z=0,se(V,U))},Bi=(o,e)=>{const i=[...Y(e).filter(s=>Wi(o,s))];return i.length===0?void 0:i.reduce((s,r)=>{const c=Ri(r,s);return c<0||c===0&&Se(o,r)>Se(o,s)?r:s})},Mi=o=>X(o),_i=(o,e)=>X(m(o,{x:e.x,z:e.z})),Xi=(o,e)=>X(m(o,{y:e.y,z:e.z})),ur=(o,e)=>X(m(o,{y:e.y})),yr=(o,e)=>X(m(o,{x:e.x})),gr=(o,e)=>X(m(o,e)),pr=(o,e,t)=>X(m(o,{x:t.x*e.x,y:t.y*e.y,z:t.z*e.z})),Oe=(o,e,t)=>{const i=_i(e,t),n=Xi(e,t),s=Mi(e),r=o;return r.xAxisProjectionMin=n.y-n.x/2,r.xAxisProjectionMax=s.y-s.x/2,r.yAxisProjectionMin=i.y+i.x/2,r.yAxisProjectionMax=s.y+s.x/2,r.zAxisProjectionMin=i.x,r.zAxisProjectionMax=n.x,r},Fe=h.w*2,Ne=h.w*2,$e=h.w*2,We=h.w*2;class Di{#t=new Map;#e=new Map;#o=new Map;#i=new Map;#n=new Map;constructor(e){if(e)for(const t of e)this.addItem(t)}#a(e,t,i,n){const s=new Set;for(const r of t)n(r).add(e),s.add(r);i.set(e,s)}#c(e,t,i){const n=i.get(e);if(n){for(const s of n){const r=t.get(s);r&&(r.delete(e),r.size===0&&t.delete(s))}i.delete(e)}}#l(e,t,i,n,s){const r=n.get(e);if(!r)throw new Error("Item not in index");const c=new Set(t);let a=!1,d=!1;for(const f of r)if(!c.has(f)){const u=i.get(f);u&&(a=!0,u.delete(e))}for(const f of c)r.has(f)||(s(f).add(e),d=!0);if(a)for(const f of r){const u=i.get(f);u&&u.size===0&&i.delete(f)}a||d?n.set(e,c):c.clear()}addItem(e){if(this.#o.has(e))throw new Error("Item is already in the spatial index");this.#a(e,this.#s(e.state.position,e.aabb),this.#o,t=>this.#f(t)),this.#y(e),this.#a(e,this.#r(e),this.#i,t=>this.#u(t))}#d(e,t){return`${e},${t}`}#f(e){let t=this.#t.get(e);return t||(t=new Set,this.#t.set(e,t)),t}#u(e){let t=this.#e.get(e);return t||(t=new Set,this.#e.set(e,t)),t}*#s(e,t){const i=e,n=m(e,t),s=Math.floor(i.x/Ne),r=Math.floor(i.y/Fe),c=Math.floor(n.x/Ne),a=Math.floor(n.y/Fe);for(let d=s;d<=c;d++)for(let f=r;f<=a;f++)yield this.#d(d,f)}#y(e){const t=e.renderAabbOffset?m(e.state.position,e.renderAabbOffset):e.state.position,i=e.renderAabb||e.aabb,n=this.#n.get(e);if(n!==void 0)return Oe(n,t,i),n;{const s=Oe({},t,i);return this.#n.set(e,s),s}}*#r(e){const t=this.#n.get(e);if(t===void 0)throw new Error("projectionAxes not calculated for "+e.id);const{xAxisProjectionMin:i,xAxisProjectionMax:n,yAxisProjectionMin:s,yAxisProjectionMax:r}=t,c=Math.floor(i/We),a=Math.floor(s/$e),d=Math.floor(n/We),f=Math.floor(r/$e);for(let u=c;u<=d;u++)for(let l=a;l<=f;l++)yield this.#d(u,l)}removeItem(e){if(!this.#o.has(e))throw new Error(`Item ${e.id} is not in the spatial index`);this.#c(e,this.#t,this.#o),this.#c(e,this.#e,this.#i)}updateItemSpatialIndex(e){this.#l(e,this.#s(e.state.position,e.aabb),this.#t,this.#o,t=>this.#f(t))}updateItemProjectedIndex(e){this.#y(e),this.#l(e,this.#r(e),this.#e,this.#i,t=>this.#u(t))}getCuboidNeighbourhood(e,t,i){const n=new Set;for(const s of this.#s(e,t)){const r=this.#t.get(s);if(r)for(const c of r)c!==i&&n.add(c)}return n}getProjectedNeighbourhood(e,t){const i=new Set;for(const n of this.#r(e)){const s=this.#e.get(n);if(s)for(const r of s)r!==t&&i.add(r)}return i}getItemCuboidNeighbourhood(e){return this.getCuboidNeighbourhood(e.state.position,e.aabb,e)}getItemProjectedNeighbourhood(e){return this.getProjectedNeighbourhood(e,e)}getItemAxesProjections(e){return this.#n.get(e)}debugToString(){const t=Array.from(this.#t.keys()).sort().map(s=>{const r=this.#t.get(s),c=Array.from(r).map(a=>a.id);return`  (${s}) => [${c.join(", ")}]`}),n=Array.from(this.#e.keys()).sort().map(s=>{const r=this.#e.get(s),c=Array.from(r).map(a=>a.id);return`  (${s}) => [${c.join(", ")}]`});return`GridSpatialIndex (${this.#t.size} 2D cells, ${this.#e.size} projected cells, ${this.#o.size} items) {
  2D Cells:
${t.join(`,
`)}
  Projected Cells:
${n.join(`,
`)}
}`}}const Hi=({above:o,below:e})=>{const t=e.state.stoodOnBy;if(!Object.isExtensible(t))throw new Error(`${o.id} can't stand on ${e.id} - its standingOn is not extensible`);o.state.standingOnItemId=e.id,t[o.id]=!0},W={x:12,y:12,z:h.h},Yi={x:14,y:14,z:h.h},Z={x:16,y:16,z:h.h},Wo={...W,z:h.h*2},it=o=>{switch(o.type){case"spring":case"portableBlock":case"moveableDeadly":case"slidingDeadly":case"firedDoughnut":return{aabb:W};case"slidingBlock":return o.config.style==="book"?{aabb:Z}:{aabb:W};case"lift":return{aabb:{...W,z:W.z}};case"switch":return{aabb:{...W,z:W.z}};case"button":return{aabb:{x:15,y:15,z:2}};case"pickup":return o.config.gives==="scroll"?{aabb:{x:16,y:4,z:13}}:{aabb:W};case"charles":return{aabb:Wo};case"ball":return{aabb:{x:12,y:12,z:12}};case"pushableBlock":case"movingPlatform":return{aabb:Z};case"block":switch(o.config.style){case"artificial":case"organic":case"book":return{aabb:Z};case"tower":return{aabb:{x:11,y:11,z:h.h}};default:throw new Error("unknown block style")}case"monster":switch(o.config.which){case"skiHead":return{aabb:{...W,z:21}};case"bubbleRobot":case"cyberman":case"elephant":case"emperorsGuardian":case"monkey":case"computerBot":return{aabb:Wo};case"helicopterBug":case"dalek":case"emperor":case"homingBot":case"elephantHead":return{aabb:W};case"turtle":return{aabb:W};default:throw o.config,new Error("unknown monster type")}case"deadlyBlock":case"spikes":return{aabb:Z};case"bubbles":return{aabb:W};case"conveyor":case"hushPuppy":case"teleporter":return{aabb:Z};case"barrier":return{aabb:o.config.axis==="y"?{x:3,y:15,z:h.h}:{x:15,y:3,z:h.h}};case"sceneryPlayer":return o.config.which==="headOverHeels"?{aabb:Wo}:{aabb:W};case"emitter":return{aabb:R};default:return{aabb:Yi}}},D={aabb:W,castsShadowWhileStoodOn:!1},yo=o=>({x:o.direction==="away"?o.tiles.length:o.direction==="towards"?o.times?.x:1,y:o.direction==="left"?o.tiles.length:o.direction==="right"?o.times?.y:1}),mr=o=>o.type==="wall"?yo(o.config):Oi(o)?o.config.times:void 0,qo=(o=no)=>({x:o.x??1,y:o.y??1,z:o.z??1}),Li=o=>({x:o.x??1,y:o.y??1}),H=o=>{const e=t=>t.config.times!==void 0;return o.type==="wall"?qo(yo(o.config)):e(o)?qo(o.config.times):no},nt=o=>{const e={};let t=!1;return o.x!==1&&(e.x=o.x,t=!0),o.y!==1&&(e.y=o.y,t=!0),o.z!==1&&(e.z=o.z,t=!0),t?e:void 0},fo=(o,e={})=>{const t=qo(e),i=Co(ro,o);return It(zt(t,ro),i)},j=-2,B=Number.MIN_SAFE_INTEGER,Bo={x:1,y:0,z:0},Mo={x:-1,y:0,z:0},_o={x:0,y:-1,z:0},Xo={x:0,y:1,z:0},$={away:Xo,left:Bo,right:Mo,towards:_o,down:{x:0,y:0,z:-1},up:{x:0,y:0,z:1},awayRight:go(m(Xo,Mo)),towardsRight:go(m(_o,Mo)),towardsLeft:go(m(_o,Bo)),awayLeft:go(m(Xo,Bo))},Be=Rt/1e3,qi={firedDoughnut:2*Be,floatingText:Be},Gi=10,hr=6e4,Ki=8,xr=750,br=1500,wr=200,vr=.15,Ji=ge.h-ge.w/2,st=Ji+2,re=9999,Go=o=>{const e=S(o.position),{aabb:t}=it(o);if(t===void 0)throw new Error(`item type= ${o.type} config=${JSON.stringify(o.config)} has no bounding box`);return o.type==="wall"?e:m(e,{x:h.w-t.x>>1,y:h.d-t.y>>1})},_=()=>({expires:null,stoodOnBy:{},disappearing:null,switchedAtRoomTime:B,stoodOnUntilRoomTime:B,actedOnAt:{roomTime:B,by:N}}),Me=()=>({standingOnItemId:null,vels:{gravity:R,movingFloor:R},latentMovement:[],collidedWith:{roomTime:B,by:N},controlledWithJoystickAtRoomTime:B}),Vi=o=>{const e=et.includes(o.type);return{..._(),position:Go(o),...e?{standingOnItemId:null,vels:{gravity:R,movingFloor:R,...ot.includes(o.type)?{sliding:R}:{},...o.type==="monster"||o.type==="movingPlatform"?{walking:R}:{}},latentMovement:[],collidedWith:{roomTime:B,by:N}}:{},...o.type==="joystick"||o.type==="emitter"||o.type==="lift"||o.type==="conveyor"||o.type==="teleporter"?{...structuredClone(o.config)}:{},...o.type==="monster"?{activated:o.config.activated==="on",everActivated:o.config.activated==="on",timeOfLastDirectionChange:Number.NEGATIVE_INFINITY,...o.config.which==="skiHead"||o.config.which==="turtle"||o.config.which==="elephantHead"||o.config.which==="cyberman"?{facing:$[o.config.startDirection]}:{facing:$.towards}}:{},...o.type==="pickup"?{disappearing:{on:"touch",byType:o.config.gives==="bag"||o.config.gives==="jumps"?["heels","headOverHeels"]:o.config.gives==="doughnuts"||o.config.gives==="hooter"||o.config.gives==="fast"?["head","headOverHeels"]:["head","heels","headOverHeels"]}}:{},...o.type==="movingPlatform"?{activated:o.config.activated==="on",everActivated:o.config.activated==="on",facing:$[o.config.startDirection]}:{},...o.type==="switch"?{setting:o.config.initialSetting,touchedOnProgression:-1}:{},...o.type==="button"?{pressed:!1}:{},...o.type==="block"?{disappearing:o.config.disappearing??null}:{},...o.type==="conveyor"?{disappearing:o.config.disappearing??null}:{},...o.type==="barrier"?{disappearing:o.config.disappearing??null}:{},...o.type==="lift"?{direction:"up",vels:{lift:R}}:{},...o.type==="charles"?{facing:$.towards}:{},...o.type==="emitter"?{lastEmittedAtRoomTime:B,quantityEmitted:0}:{},...o.type==="firedDoughnut"?{disappearing:{on:"touch"},vels:{fired:o.config.direction?Zo($[o.config.direction],qi.firedDoughnut):R}}:{}}},Ui=({config:{direction:o},position:e})=>o==="right"&&e.x===0||o==="towards"&&e.y===0,Do=h.h*2,Zi=4,zo=h.h*Zi,Qi=2,Ir=2*h.w,ji=.5,_e=2;function*on(o,e){const{config:{direction:t},position:i}=o,n=Ve(t),s=Qo(n),r=Ui(o),c={...R,[s]:r?-.5:0},a=1,d={[s]:r?-a:0},f=a*h.w,u={...R,[s]:f},l=9,y=8,g=8;{const p={[n]:y,[s]:g,z:zo};yield{...o,...D,type:"doorFrame",id:`${e}/frameFar`,jsonItemId:e,config:{...o.config,inHiddenWall:r,part:"far"},state:{..._(),position:S(m(i,{[n]:1.5},c,d)),stoodOnBy:N},aabb:m(p,u),renderAabb:p,renderAabbOffset:r?u:void 0}}{const p={[n]:l,[s]:g,z:zo};yield{...o,...D,type:"doorFrame",id:`${e}/frameNear`,jsonItemId:e,config:{...o.config,inHiddenWall:r,part:"near"},state:{..._(),position:S(m(i,c,d)),stoodOnBy:N},aabb:m(p,u),renderAabb:p,renderAabbOffset:r?u:void 0}}{const p={[n]:2*h.w-l-y,[s]:g,z:zo-Do};yield{...o,...D,type:"doorFrame",id:`${e}/frameTop`,jsonItemId:e,config:{...o.config,inHiddenWall:r,part:"top"},state:{..._(),position:m(S(m(i,c,d)),{[n]:l,z:Do}),stoodOnBy:N},aabb:m(p,u),renderAabb:p,renderAabbOffset:r?u:void 0}}yield{...o,...D,type:"blocker",id:`${e}/blockerAbove`,jsonItemId:e,config:{},renders:!1,state:{..._(),position:m(S(m(i,c,d)),{z:zo}),stoodOnBy:N},aabb:m(S({[n]:2,[s]:a}),{[s]:g,z:re}),renderAabb:R,fixedZIndex:j},yield{...o,...D,type:"portal",id:`${e}/portal`,jsonItemId:e,config:{...kt(o.config,"toRoom","toDoor"),inHidden:r,relativePoint:S({...R,[s]:r?a+.25:-.25}),direction:$[t]},fixedZIndex:j,state:{..._(),position:m(S(m(i,{[s]:r?-.5-a:.5})),{[n]:l}),stoodOnBy:N},aabb:{[n]:Qi*h.w-l-y,[s]:f,z:Do}},i.z!==0&&(yield{...o,...D,type:"doorLegs",id:`${e}/legs`,jsonItemId:e,config:{...o.config,inHiddenWall:r,style:"none",side:"away",height:i.z},renders:!0,shadowCastTexture:r?{textureId:"shadow.door.floatingThreshold.double.y",flipX:n==="x"}:void 0,castsShadowWhileStoodOn:r,state:{..._(),position:{...S(m(i,c,d)),z:0}},aabb:m(S({[n]:2,[s]:.5,z:i.z}),u),renderAabb:r?m(S({[n]:2,[s]:.5,z:.5})):void 0,renderAabbOffset:r?m({[n]:0,[s]:0,z:(i.z-.5)*h.h},{[s]:u[s]}):void 0,shadowOffset:{z:i.z*h.h,[s]:r?u[s]:void 0}}),yield{...D,type:"stopAutowalk",id:`${e}/stopAutowalk`,jsonItemId:e,aabb:S({[n]:2,[s]:_e,z:2}),config:{},fixedZIndex:j,state:{..._(),position:S(Co(i,Zo($[t],ji),r?R:{[s]:_e})),stoodOnBy:N}}}const Xe=3,De=10,He=.52,Ro=.5,en=(o,e,t)=>{const{config:{times:i},position:n}=e,s=m(n,{z:-Xe}),r={...i,z:Xe};let c=s,a=r;const d=Y(so(t.items)).filter(l=>l.type==="door");if(n.z===0){const l={};for(const y of d){const{position:g,config:{direction:p}}=y;switch(p){case"towards":!l.towards&&g.y===s.y&&g.x>=s.x&&g.x<=s.x+i.x-2&&(a=m(a,{y:Ro}),c=m(c,{y:-Ro}),l.towards=!0);break;case"away":!l.away&&g.y===s.y+i.y&&g.x>=s.x&&g.x<=s.x+i.x-2&&(a=m(a,{y:He}),l.away=!0);break;case"right":!l.right&&g.x===s.x&&g.y>=s.y&&g.y<=s.y+i.y-2&&(a=m(a,{x:Ro}),c=m(c,{x:-Ro}),l.right=!0);break;case"left":!l.left&&g.x===s.x+i.x&&g.y>=s.y&&g.y<=s.y+i.y-2&&(a=m(a,{x:He}),l.left=!0);break}}}const f=S(c),u=fo(Z,a);return{...D,type:"floor",id:o,jsonItemId:o,config:{...e.config,naturalFootprint:{aabb:fo(Z,r),position:S(s)}},aabb:u,renderAabb:{...u,z:De},renderAabbOffset:{...R,z:u.z-De},shadowCastTexture:"shadow.fullBlock",state:{..._(),position:f}}},Ye={config:N,shadowCastTexture:"shadow.smallRound",castsShadowWhileStoodOn:!0,aabb:W},Le=()=>{const o=Pt(jo.getState());return{action:"idle",jumped:!1,teleporting:null,autoWalk:!1,facing:$.towards,walkStartFacing:$.towards,walkDistance:0,vels:{walking:R,gravity:R,movingFloor:R},switchedToAt:B,lastDiedAt:B,gameTime:0,jumpStartTime:B,lives:o?"infinite":Ki,jumpStartZ:0}},tn=(o,e)=>{const t=Et(jo.getState());return o.config.which==="head"?{id:e,jsonItemId:e,type:"head",...D,...Ye,state:{..._(),...Me(),...Le(),hasHooter:!1,gameWalkDistance:0,fastStepsStartedAtDistance:B,shieldCollectedAt:B,doughnuts:t?"infinite":0,position:Go(o),stoodOnUntilRoomTime:B}}:{id:e,jsonItemId:e,type:"heels",...D,...Ye,state:{..._(),...Me(),...Le(),carrying:null,hasBag:!1,bigJumps:0,isBigJump:!1,shieldCollectedAt:B,position:Go(o),stoodOnUntilRoomTime:B}}},rt=o=>o==="towards"||o==="right",ae=1,nn={x:h.w,y:h.d*ae,z:re},sn={x:h.w,y:0,z:st},rn={x:h.w*ae,y:h.d,z:re},an={x:0,y:h.d,z:st},cn=(o,e)=>{const{config:{direction:t},position:i}=e,n=yo(e.config),s=Ve(t),r=Qo(s),c=rt(t),a={...R,[r]:c?-ae:0};return{type:"wall",id:o,jsonItemId:o,config:e.config,aabb:fo(s==="y"?rn:nn,n),renderAabb:c?R:fo(s==="y"?an:sn,n),fixedZIndex:c?j:void 0,state:{..._(),position:S(m(i,a)),stoodOnBy:N},shadowCastTexture:s==="y"?"shadow.wall.y":{textureId:"shadow.wall.y",flipX:!0},castsShadowWhileStoodOn:c}};function*at(o,e,t,i=N,n={},s=""){if(!i[o]&&!(e.type==="pickup"&&e.config.gives==="scroll"&&e.config.source==="manual"&&n[e.config.page]))switch(!0){case e.type==="door":return yield*on(e,o);case e.type==="player":{yield tn(e,o);return}case e.type==="wall":{yield cn(o,e);return}case e.type==="floor":{yield en(o,e,t);return}case(e.type==="block"&&e.config.disappearing!==void 0&&oe(H(e))>=2):{const r=H(e);for(let c=0;c<r.x;c++)for(let a=0;a<r.y;a++)for(let d=0;d<r.z;d++){const f=to(e,u=>{u.position={x:e.position.x+c,y:e.position.y+a,z:e.position.z+d},u.config.times=no});yield*at(o,f,t,i,n,`${s}_${c}_${a}_${d}`)}break}case(e.type==="sceneryCrown"&&!jo.getState().gameMenus.gameInPlay.planetsLiberated[e.config.planet]):return;default:{const r=it(e),c=e.config.times!==void 0?{aabb:fo(r.aabb,e.config.times),renderAabb:void 0}:r;let a;try{a=Vi(e)}catch(d){throw new Error(`loadItemFromJson: error creating initial state for jsonItem ${JSON.stringify(e,null,2)}`,{cause:d})}yield{...e,...D,...c,id:`${o}${s}`,jsonItemId:o,fixedZIndex:e.type==="emitter"?j:void 0,shadowCastTexture:ln(e),castsShadowWhileStoodOn:e.type==="monster"&&(e.config.which==="emperor"||e.config.which==="emperorsGuardian"||e.config.which==="turtle"||e.config.which==="helicopterBug")||e.type==="pickup"||e.type==="ball"||e.type==="lift"||e.type==="pushableBlock"||e.type==="sceneryPlayer"||e.type==="slidingDeadly"||e.type==="spring",config:e.config,state:a}}}}const ln=o=>{switch(o.type){case"lift":case"switch":return"shadow.smallBlock";case"conveyor":return{textureId:"shadow.fullBlock",flipX:Ho(o.config.direction)==="x"};case"barrier":return{textureId:"shadow.barrier.y",flipX:o.config.axis==="x"};case"spring":case"firedDoughnut":case"slidingDeadly":return"shadow.smallRound";case"block":return o.config.style==="tower"?"shadow.smallRound":"shadow.fullBlock";case"pushableBlock":case"movingPlatform":case"hushPuppy":case"deadlyBlock":case"teleporter":case"spikes":return"shadow.fullBlock";case"portableBlock":return o.config.style==="drum"?"shadow.smallRound":"shadow.smallBlock";case"pickup":return o.config.gives==="scroll"?"shadow.scroll":"shadow.smallRound";case"ball":case"charles":case"monster":return"shadow.smallRound";case"slidingBlock":return o.config.style==="book"?"shadow.fullBlock":"shadow.smallRound"}},ko=h.h,dn=-12,fn=o=>{const e=io(o).filter(tt).reduce((t,{config:{naturalFootprint:{position:{x:i,y:n},aabb:{x:s,y:r}}}})=>{const c=i+s,a=n+r;return{minX:Math.min(t.minX,i),maxX:Math.max(t.maxX,c),minY:Math.min(t.minY,n),maxY:Math.max(t.maxY,a)}},{minX:1/0,maxX:-1/0,minY:1/0,maxY:-1/0});if(!(e.minX>e.maxY))return e};function*un(o,e){const t=fn(e);if(t===void 0)return;const{minX:i,maxX:n,minY:s,maxY:r}=t;o.roomBelow!==void 0&&(yield{...D,type:"portal",id:"portal/toRoomBelow",fixedZIndex:j,config:{toRoom:o.roomBelow,relativePoint:{x:(i+n)/2,y:(s+r)/2,z:ko+h.h},direction:$.down},aabb:{x:n-i,y:r-s,z:ko},state:{..._(),position:{x:i,y:s,z:dn-ko}},renders:!1}),o.roomAbove!==void 0&&(yield{...D,type:"portal",id:"portal/toRoomAbove",fixedZIndex:j,config:{toRoom:o.roomAbove,relativePoint:{...o.ceilingRelativePoint!==void 0?S(o.ceilingRelativePoint):{x:(i+n)/2,y:(s+r)/2},z:-12},direction:$.up},aabb:{x:n-i,y:r-s,z:ko},state:{..._(),position:m({x:i,y:s},{z:h.h*(o.height??Gi)})}})}function*yn(o,e,t,i){const n=ee(o.items);for(const[s,r]of n)r.type==="player"&&!i||(yield*at(s,r,o,e,t))}const qe=o=>Y(o).reduce((e,t)=>({...e,[t.id]:t}),{}),ct=({roomJson:o,roomPickupsCollected:e,scrollsRead:t,isNewGame:i=!1})=>{const n=qe(yn(o,e,t,i)),s={...qe(un(o,n)),...n},r=new Di(io(s));for(const a of io(s)){const f=zi(a,r).find(u=>Lo(a)&&Lo(u)&&!(a.type==="wall"&&u.type==="wall"));f!==void 0&&console.error(`in room ${o.id} item ${a.id} @${JSON.stringify(a.state.position)} #${JSON.stringify(a.aabb)} is colliding with (solid item) ${f.id} @${JSON.stringify(f.state.position)} #${JSON.stringify(f.aabb)} on loading room ${o.id}`)}for(const a of io(s).filter(Ti)){const d=Bi(a,io(s).filter(f=>f.id!==a.id));d!==void 0&&Hi({above:a,below:d})}return{...o,roomJson:o,items:s,roomTime:0,[ai]:r}},gn=To([o=>O(o.levelEditor),o=>o.levelEditor.previewedEdits],(o,e)=>to(o,t=>{const i=Ue(e);for(const[n,s]of i)s===null?delete t.items[n]:t.items[n]=s})),pn=To([o=>O(o.levelEditor)],o=>ct({roomJson:o,roomPickupsCollected:N,scrollsRead:N,isNewGame:!0})),mn=To([gn],o=>ct({roomJson:o,roomPickupsCollected:N,scrollsRead:N,isNewGame:!0})),hn=To([pn],o=>{const{floors:{edgeLeftX:e,edgeRightX:t,bottomEdgeY:i},allItems:{topEdgeY:n}}=mi(o);return{l:e,r:t,w:t-e,b:i,t:n,h:i-n}}),zr=Qe(mn),Rr=Qe(hn),O=o=>o.campaignInProgress.rooms[o.currentlyEditingRoomId],Ko=(o,e)=>o.campaignInProgress.rooms[e],lt=(o,e,t)=>o.campaignInProgress.rooms[t??o.currentlyEditingRoomId]?.items[e],xn=(o,e)=>o.selectedJsonItemIds.includes(e),ce=o=>oe(le(o))>0,le=o=>{switch(o.type){case"deadlyBlock":return no;case"conveyor":if(o.config.disappearing)return R;switch(o.config.direction){case"left":case"right":return{x:1,y:0,z:0};case"away":case"towards":return{x:0,y:1,z:0};default:throw o.config.direction,new Error}case"hushPuppy":return no;case"teleporter":return{x:1,y:1,z:0};case"floor":case"spikes":return{x:1,y:1,z:0};case"block":return no;case"barrier":if(o.config.disappearing)return R;switch(o.config.axis){case"x":return{x:1,y:0,z:1};case"y":return{x:0,y:1,z:1};default:throw o.config.axis,new Error}case"wall":switch(o.config.direction){case"left":case"right":return{x:0,y:1,z:1};case"away":case"towards":return{x:1,y:0,z:1};default:throw o.config,new Error}default:return R}};class Ao{#t;#e;#o;constructor(e,t){this.#e={x:-e.x,y:-e.y,z:-e.z},this.#o={x:t.x-e.x+1,y:t.y-e.y+1,z:t.z-e.z+1},this.#t=Array.from({length:this.#o.x},()=>Array.from({length:this.#o.y},()=>Array.from({length:this.#o.z},()=>new Set)))}static fromItems(e){let t=1/0,i=1/0,n=1/0,s=-1/0,r=-1/0,c=-1/0;const a=[...e];for(const[,f]of a){const{x:u,y:l,z:y}=f.position,g=H(f);t=Math.min(t,u),i=Math.min(i,l),n=Math.min(n,y),s=Math.max(s,u+g.x-1),r=Math.max(r,l+g.y-1),c=Math.max(c,y+g.z-1)}if(a.length===0)return new Ao({x:0,y:0,z:0},{x:0,y:0,z:0});const d=new Ao({x:t,y:i,z:n},{x:s,y:r,z:c});for(const f of a){const[,u]=f,{x:l,y,z:g}=u.position,p=H(u);for(let T=0;T<p.x;T++)for(let A=0;A<p.y;A++)for(let I=0;I<p.z;I++)d.add({x:l+T,y:y+A,z:g+I},f)}return d}get(e){const t=e.x+this.#e.x,i=e.y+this.#e.y,n=e.z+this.#e.z;if(this.#i(t,i,n))return this.#t[t][i][n]}set(e,t){const i=e.x+this.#e.x,n=e.y+this.#e.y,s=e.z+this.#e.z;this.#i(i,n,s)&&(this.#t[i][n][s]=t)}add(e,t){const i=this.get(e);i&&i.add(t)}remove(e,t){const i=this.get(e);i&&i.delete(t)}get size(){return{...this.#o}}get minBounds(){return{x:-this.#e.x,y:-this.#e.y,z:-this.#e.z}}get maxBounds(){const e=this.minBounds;return{x:e.x+this.#o.x-1,y:e.y+this.#o.y-1,z:e.z+this.#o.z-1}}*iterate(){const{minBounds:e}=this;for(let t=0;t<this.#o.x;t++)for(let i=0;i<this.#o.y;i++)for(let n=0;n<this.#o.z;n++)yield[{x:t+e.x,y:i+e.y,z:n+e.z},this.#t[t][i][n]]}extractUniqueItems(){const e=new Set,t=[];for(const[,i]of this.iterate())for(const n of i)e.has(n)||(e.add(n),t.push(n));return t}#i(e,t,i){return e>=0&&e<this.#o.x&&t>=0&&t<this.#o.y&&i>=0&&i<this.#o.z}}const K=o=>o.type==="wall"?`wall/${o.config.direction}`:o.type==="teleporter"?pe({type:o.type,config:me(o.config,"toPosition","times")}):pe({type:o.type,config:me(o.config,"times")}),bn=o=>ce(o[1]),wn=o=>({x:Math.floor(o.x%1*ro.x),y:Math.floor(o.y%1*ro.y)}),vn=(o,e)=>`${o},${e}`,In=(o,e)=>{let t=o,i=t.length;for(;;){const n=[...Rn(t,e)];if(n.length===i)return n;i=n.length,t=n}},zn=(o,e=()=>!0)=>{const t=new Map,i=[];for(const s of o){const[,r]=s;if(!e(s))i.push(s);else if(ce(r)){const c=wn(r.position),a=vn(c.x,c.y);t.has(a)||t.set(a,[]),t.get(a).push(s)}else i.push(s)}const n=[];for(const[s,r]of t)if(r.length>0){const c=r.map(([y,g])=>[y,{...g,position:{x:Math.floor(g.position.x),y:Math.floor(g.position.y),z:g.position.z}}]),a=In(c,e),[d,f]=s.split(",").map(Number),u=d/ro.x,l=f/ro.y;for(const[y,g]of a)n.push([y,{...g,position:{x:g.position.x+u,y:g.position.y+l,z:g.position.z}}])}return[...n,...i]},Rn=(o,e=()=>!0)=>{const t=[],i=[];for(const l of o)e(l)&&bn(l)?t.push(l):i.push(l);const n=Ao.fromItems(t),s=n.size,{minBounds:r}=n,c=new Map,a=new Map;for(const[,l]of n.iterate())for(const[,y]of l){const g=K(y);a.has(g)||a.set(g,y)}for(const[l]of a)c.set(l,Array.from({length:s.x},()=>Array.from({length:s.y},()=>Array(s.z).fill(!1))));const d=(l,y)=>{const g=H(y),p={x:l.x+g.x-1,y:l.y+g.y-1,z:l.z+g.z-1},T=le(y),A=K(y),I=new Set;I.add(y);const k=b=>{const P=new Set;let E=!1;for(let{x}=l;x<=b.x;x++)for(let{y:w}=l;w<=b.y;w++)for(let{z:v}=l;v<=b.z;v++){const M=n.get({x,y:w,z:v});let oo=!1,ao=!1;if(M)for(const[,L]of M)K(L)===A?(oo=!0,P.add(L)):ce(L)&&L.type!=="wall"&&(ao=!0);ao&&!oo&&(E=!0),(!M||M.size===0)&&(E=!0),oo||(E=!0)}if(E)return!1;let F=!1;for(const x of P)I.has(x)||(F=!0,I.add(x));if(!F)return!1;for(const x of P){const w=H(x),v={x:x.position.x+w.x-1,y:x.position.y+w.y-1,z:x.position.z+w.z-1};if(x.position.x<l.x||x.position.y<l.y||x.position.z<l.z||v.x>b.x||v.y>b.y||v.z>b.z)return!1}return!0};let z=!0;for(;z;){if(z=!1,T.x>0&&p.x+1<r.x+s.x){let b=p.x;for(let{y:P}=l;P<=p.y;P++)for(let{z:E}=l;E<=p.z;E++){const F=n.get({x:p.x+1,y:P,z:E});if(F){for(const[,x]of F)if(K(x)===A){const w=H(x),v=x.position.x+w.x-1;b=Math.max(b,v)}}}b>p.x&&k({...p,x:b})&&(p.x=b,z=!0)}if(T.y>0&&p.y+1<r.y+s.y){let b=p.y;for(let{x:P}=l;P<=p.x;P++)for(let{z:E}=l;E<=p.z;E++){const F=n.get({x:P,y:p.y+1,z:E});if(F){for(const[,x]of F)if(K(x)===A){const w=H(x),v=x.position.y+w.y-1;b=Math.max(b,v)}}}b>p.y&&k({...p,y:b})&&(p.y=b,z=!0)}if(T.z>0&&p.z+1<r.z+s.z){let b=p.z;for(let{x:P}=l;P<=p.x;P++)for(let{y:E}=l;E<=p.y;E++){const F=n.get({x:P,y:E,z:p.z+1});if(F){for(const[,x]of F)if(K(x)===A){const w=H(x),v=x.position.z+w.z-1;b=Math.max(b,v)}}}b>p.z&&k({...p,z:b})&&(p.z=b,z=!0)}}return p},f=(l,y)=>{if(l.type==="wall"){if(y.type!=="wall")throw new Error("only walls can join walls");if(l.config.direction!==y.config.direction)throw new Error("walls must have the same direction to join");return l.config.direction==="right"||l.config.direction==="towards"?l:{...l,config:{...l.config,tiles:[...l.config.tiles,...y.config.tiles]}}}return l},u=({x:l,y,z:g},{x:p,y:T,z:A},I)=>{const[k,z]=I,b=K(z),P=p-l+1,E=T-y+1,F=A-g+1;let x=z;if(P+E+F>3){const w={...z.config};if(z.type==="wall")switch(z.config.direction){case"away":case"left":break;case"towards":P!==1&&(w.times={x:P});break;case"right":E!==1&&(w.times={y:E});break}else{const v={...nt(H(z))};P!==1&&(v.x=P),E!==1&&(v.y=E),F!==1&&(v.z=F),w.times=v}x={...z,config:w}}for(let w=l;w<=p;w++)for(let v=y;v<=T;v++)for(let M=g;M<=A;M++)if(c.get(b)[w-r.x][v-r.y][M-r.z]=!0,w!==l||v!==y||M!==g){const oo=n.get({x:w,y:v,z:M});if(oo)o:for(const ao of oo){const[,L]=ao;if(K(L)===b){L.position.x===w&&L.position.y===v&&L.position.z===M&&(x=f(x,L)),n.remove({x:w,y:v,z:M},ao);break o}}}return[k,x]};for(const[l,y]of n.iterate())for(const g of y){const[,p]=g;if(p.position.x===l.x&&p.position.y===l.y&&p.position.z===l.z){const T=K(p),A=c.get(T),I=l.x-r.x,k=l.y-r.y,z=l.z-r.z;if(A&&!A[I][k][z]){const b=d(l,p),P=u(l,b,g);n.remove(l,g),n.add(l,P)}}}return[...n.extractUniqueItems(),...i]},de=(o,e)=>Object.fromEntries(zn(Object.entries(o),e)),kn=o=>o[Math.floor(Math.random()*o.length)],dt=(o,e)=>{o.planet=e;for(const t of Object.values(o.items))t.type==="floor"&&t.config.floorType==="standable"&&(t.config.scenery=e),t.type==="wall"&&(t.config.direction==="away"||t.config.direction==="left")&&(t.config.tiles=Array.from(lo(e,t.config.tiles.length))),t.type==="pickup"&&t.config.gives==="crown"&&At.includes(e)&&(t.config.planet=e)},En={x:8,y:8},Pn=(o,e,t,i,n)=>{const s={};for(const f of n){const u={x:f.x*e.x,y:f.y*e.y},l=je(e);for(const[y,g]of Object.entries(l.items)){const p=`${y}_${f.x}_${f.y}`;s[p]={...g,position:{x:g.position.x+u.x,y:g.position.y+u.y,z:g.position.z}}}}const r=new Set;for(const f of n){const u=n.some(y=>y.x===f.x+1&&y.y===f.y),l=n.some(y=>y.x===f.x&&y.y===f.y+1);u&&(r.add(`leftWall_${f.x}_${f.y}`),r.add(`rightWall_${f.x+1}_${f.y}`)),l&&(r.add(`awayWall_${f.x}_${f.y}`),r.add(`towardsWall_${f.x}_${f.y+1}`))}for(const f of r)delete s[f];const c=de(s),a=n.length>1?Object.fromEntries(n.map((f,u)=>[u.toString(),{gridPosition:f,physicalPosition:{from:{x:f.x*e.x,y:f.y*e.y},to:{x:(f.x+1)*e.x-1,y:(f.y+1)*e.y-1}}}])):void 0,d={id:o,planet:"blacktooth",color:t,items:c,...a&&{meta:{subRooms:a}}};return dt(d,i),d},fe=({state:o,scenery:e,maybeColour:t,roomSize:i=En,gridPositions:n=[{x:0,y:0}]})=>{const r=`room_${Y(Ct({start:0})).find(d=>o.campaignInProgress.rooms[`room_${d}`]===void 0)}`,c=t??{hue:kn(Tt),shade:Math.random()<.66?"basic":"dimmed"},a=Pn(r,i,c,e,n);return o.campaignInProgress.rooms[r]=a,a},Po=(o,e,t=!1)=>{if(!o.campaignInProgress.rooms[e]){console.warn(`can't change to room ${e} - it doesn't exist`);return}t||o.editingRoomIdHistory.back.push(o.currentlyEditingRoomId),o.currentlyEditingRoomId=e,o.clickableAnnotationHovered=!1,o.hoveredItem=void 0,o.selectedJsonItemIds=[],t||(o.history=ne.history)},An={addRoom(o,{payload:{roomSize:e,gridPositions:t=[{x:0,y:0}]}}){const{planet:i}=O(o),n=fe({state:o,scenery:i,roomSize:e,gridPositions:t});Po(o,n.id)},removeRoom(o){const e=o.campaignInProgress.rooms[o.currentlyEditingRoomId],i=Yo(G(e.items,"door","teleporter"))?.[1].config.toRoom??Yo(oi(n=>n!==o.currentlyEditingRoomId,St(o.campaignInProgress.rooms)));i!==void 0&&(delete o.campaignInProgress.rooms[o.currentlyEditingRoomId],o.currentlyEditingRoomId=i)}},Eo=(o,e,t,i)=>e.some(n=>n.config.direction===o)?"doorway":t===void 0?"wall":Object.values(t).some(({gridPosition:n})=>Ft($[o],Je(n,i)))?"open":"wall";function*eo(o){try{yield*Cn(o)}catch(e){const t=e;throw new Error(`
  error in recursion ${o.roomId}/${o.subRoomId??"*"}`,{cause:t})}}function*Cn({roomId:o,subRoomId:e="*",campaign:t,visited:i={},vectorFromPrevious:n,previousRoomGridPosition:s=R}){if(o==="nowhere"||i[o]?.[e])return;i[o]===void 0&&(i[o]={}),i[o][e]=!0;const r=t.rooms[o];if(r===void 0)throw new Error(`no room in the campaign with id="${o}"`);const c=[...Y(so(r.items)).filter(y=>y.type==="door").filter(y=>te(y.position,"block",r)===e)],a=m(s,n===void 0?Ot:n),d=r.meta?.subRooms;if(d){if(e==="*")throw new Error(`subRoomId '*' means 'all' and is not allowed for big rooms. Must be one of the sub-rooms in ${o}: ${Object.keys(d)}`);if(!d[e])throw new Error(`Sub-room ${e} not found in room ${o}. Available sub-rooms: ${Object.keys(d)}`)}const f=d?.[e].gridPosition,u={left:Eo("left",c,d,f),right:Eo("right",c,d,f),away:Eo("away",c,d,f),towards:Eo("towards",c,d,f)};if(yield{roomId:o,subRoomId:e,gridPosition:a,boundaries:u},d!==void 0){if(f===void 0)throw new Error(`Sub-room ${e} not found in room ${o}. Available sub-rooms: ${Object.keys(d)}`);for(const[y,{gridPosition:g}]of Y(ee(d)))y!==e&&(yield*eo({roomId:o,subRoomId:y,campaign:t,visited:i,vectorFromPrevious:Co({...g,z:0},f),previousRoomGridPosition:a}))}if(r.roomAbove!==void 0){const{roomAbove:y,subRoomAbove:g}=r;yield*eo({roomId:y,subRoomId:g,campaign:t,visited:i,vectorFromPrevious:$.up,previousRoomGridPosition:a})}if(r.roomBelow!==void 0){const{roomBelow:y,subRoomBelow:g}=r;yield*eo({roomId:y,subRoomId:g,campaign:t,visited:i,vectorFromPrevious:$.down,previousRoomGridPosition:a})}for(const y of c){const{toRoom:g}=y.config;try{yield*eo({roomId:g,campaign:t,visited:i,subRoomId:y.config.meta?.toSubRoom,vectorFromPrevious:$[y.config.direction],previousRoomGridPosition:a})}catch(p){throw new Error(`error while traversing door ${JSON.stringify(y,null,2)} in room ${o} to room ${g}`,{cause:p})}}const l=r.meta?.nonContiguousRelationship;if(l!==void 0){const{with:{room:y},gridOffset:g}=l;yield*eo({roomId:y,campaign:t,visited:i,subRoomId:"*",vectorFromPrevious:g,previousRoomGridPosition:a})}}const ft=(o,e)=>{for(let t=1;;t++){const i=t===1?e:`${e}_${t}`;if(!o.items[i])return i}},ut=(o,e,t)=>{if(e.type==="player"){const{which:n}=e.config;return t?`preview-${n}`:n}const i=e.type==="monster"?e.config.which:e.type;return ft(o,i)},Jo=(o,e,t,i)=>{const n=O(o),s=ut(n,e,i),r=yt(o,i),c={type:e.type,config:e.config,position:t};return r[s]=c,[s,c]},yt=(o,e,t=o.currentlyEditingRoomId)=>e?o.previewedEdits:o.campaignInProgress.rooms[t].items;function*gt(o,e,t){for(const i of ee(o)){const[n,s]=i;if(s===null||s.type!=="wall"||s.config.direction!==e)continue;const{position:r,config:c}=s,a=Li(yo(c)),d=Qo(Ho(c.direction)),f=Ho(c.direction),u=Co(t,r);if(u[f]!==0||u[d]<-1||u[d]>=a[d])continue;if(u[d]===0&&a[d]===2){yield[n,null];continue}const l=2+u[d];if(l===1||l===2){const I=to(s,k=>{k.position=m(r,{[d]:l});const z=k.config;switch(z.direction){case"towards":case"right":z.times[d]=a[d]-l;break;default:z.tiles=z.tiles.slice(l)}});yield[n,I];continue}const g=a[d]-u[d];if(g===2||g===1){const I=to(s,k=>{const z=k.config;switch(z.direction){case"towards":case"right":z.times[d]=a[d]-g;break;default:z.tiles=z.tiles.slice(0,-g)}});yield[n,I];continue}const T=to(s,I=>{const k=I.config;switch(k.direction){case"towards":case"right":k.times[d]=u[d];break;default:k.tiles=k.tiles.slice(0,u[d])}});yield[`${n}/beforeDoor`,T];const A=to(s,I=>{I.position={...r,[d]:t[d]+2};const k=I.config;switch(k.direction){case"towards":case"right":k.times[d]=a[d]-u[d]-2;break;default:k.tiles=k.tiles.slice(u[d]+2)}});yield[`${n}/afterDoor`,A],yield[n,null]}}const pt=(o,e,t,i,n)=>{const s=Ko(o,e);if(s===void 0)throw new Error("can't cut hole in walls for a room that does not exist");const r=yt(o,n,e);for(const[c,a]of gt(s.items,t,i))n?r[c]=a:a===null?delete r[c]:r[c]=a},Tn=({state:o,fromRoomJson:e,subRoomId:t,direction:i,isPreview:n,autoAddRooms:s})=>{const r=o.campaignInProgress,c=eo({campaign:r,roomId:e.id,subRoomId:t}),a=Y(c).find(({gridPosition:d})=>Nt(d,$[i]));if(a)return r.rooms[a.roomId];if(!n)return s?fe({state:o,scenery:e.planet}):void 0},Sn=o=>G(o.items,"floor").reduce((e,[,t])=>{const i=t.position.y;return Math.min(e,i)},Number.POSITIVE_INFINITY),On=o=>G(o.items,"floor").reduce((e,[,t])=>{const i=t.position.y+t.config.times.y;return Math.max(e,i)},Number.NEGATIVE_INFINITY),Fn=o=>G(o.items,"floor").reduce((e,[,t])=>{const i=t.position.x;return Math.min(e,i)},Number.POSITIVE_INFINITY),Nn=o=>G(o.items,"floor").reduce((e,[,t])=>{const i=t.position.x+t.config.times.x;return Math.max(e,i)},Number.NEGATIVE_INFINITY),mt=({state:o,fromRoomJson:e,toRoomJson:t,outgoingDoorEntry:[i,n]})=>{const s=n.config.direction,r=n.position,c=te(n.position,"block",e),a=ft(t,"door"),d={x:s==="left"?Fn(t):s==="right"?Nn(t):r.x,y:s==="away"?Sn(t):s==="towards"?On(t):r.y,z:r.z},f=Ze(s),u={type:"door",config:{toRoom:e.id,direction:f,meta:c==="*"?void 0:{toSubRoom:c}},position:d};t.items[a]=u,u.config.toDoor=i,n.config.toDoor=a,pt(o,t.id,f,d,!1)},$n=(o,e,t,i,n)=>{const s=O(o),r=t;pt(o,s.id,r,e,n);const c=i.config.toRoom==="+",a=te(e,"block",s),d=Tn({state:o,fromRoomJson:s,subRoomId:a,direction:r,isPreview:n,autoAddRooms:c}),[f,u]=Jo(o,{type:"door",config:{...i.config,toRoom:d?d.id:i.config.toRoom,direction:r}},e,n);!n&&d&&mt({state:o,fromRoomJson:s,toRoomJson:d,outgoingDoorEntry:[f,u]})},Vo=(o,e)=>{const t=O(o);t.items=de(t.items,e);const i=o.selectedJsonItemIds.filter(n=>t.items[n]!==void 0);i.length!==o.selectedJsonItemIds.length&&(o.selectedJsonItemIds=i)},Q=o=>{const e=structuredClone(q(O(o))),{history:t}=o;t.redo=[],t.undo.push(e)},Wn={undo(o){const e=o,{campaignInProgress:t,history:{undo:i,redo:n},currentlyEditingRoomId:s}=e;i.length!==0&&(n.push(t.rooms[s]),t.rooms[s]=i.pop())},redo(o){const e=o,{campaignInProgress:t,history:{redo:i,undo:n},currentlyEditingRoomId:s}=e;i.length!==0&&(n.push(t.rooms[s]),t.rooms[s]=i.pop())}},Bn={selectCanUndo:o=>o.history.undo.length>0,selectCanRedo:o=>o.history.redo.length>0},Mn=o=>o.type==="door",_n=o=>o.type==="monster"&&o.config.which==="cyberman",Xn={applyItemTool(o,{payload:{blockPosition:e,pointedAtItemJson:t,preview:i}}){const n=o,{tool:s}=n;if(s.type!=="item")throw new Error("applying item tool reducer while the current tool is not an item tool");switch(i||(Q(n),n.previewedEdits={}),n.selectedJsonItemIds=[],!0){case Mn(s.item):{if(t.type!=="wall")throw new Error("doors can only be added on walls");$n(n,e,t.config.direction,s.item,i);break}case(_n(s.item)&&t.type==="deadlyBlock"&&t.config.style==="toaster"&&t.position.z+1===e.z):{Jo(n,{...s.item,config:{...s.item.config,activated:"off"}},e,i);break}default:Jo(n,s.item,e,i)}i||(n.autoCoalesce?Vo(n):Vo(n,r=>r.type==="wall"))}},Dn={setCampaignName(o,{payload:e}){const t=o;t.campaignInProgress.locator.campaignName=e},setCampaignUserId(o,{payload:e}){const t=o;t.campaignInProgress.locator.userId=e},setCampaignPublished(o,{payload:e}){const t=o;t.campaignInProgress.meta===void 0?t.campaignInProgress.meta={published:!1}:t.campaignInProgress.meta.published=e}},Hn={changeToRoom(o,{payload:e}){Po(o,e)},roomBack(o){const e=o,{editingRoomIdHistory:t}=e;if(t.back.length===0)return;const i=t.back.pop();t.forward.push(e.currentlyEditingRoomId),Po(e,i,!0)},roomForward(o){const e=o,{editingRoomIdHistory:t}=e;if(t.forward.length===0)return;const i=t.forward.pop();t.back.push(e.currentlyEditingRoomId),Po(e,i,!0)}},Yn={changeDragInProgress(o,{payload:e}){const t=o;t.dragInProgress=e}},Ln={changeGridResolution(o,{payload:e}){const t=o;t.gridResolution=e},changeWallsFloorsLocked(o,{payload:e}){const t=o;t.wallsFloorsLocked=e}},qn=(o,e)=>{const t=o.currentlyEditingRoomId,i=O(o);for(const n of so(o.campaignInProgress.rooms)){co(n).filter(r=>r.type==="door"||r.type==="teleporter").filter(r=>r.config.toRoom===t).forEach(r=>{r.config.toRoom=e});const s=n.meta?.nonContiguousRelationship?.with;s?.room===t&&(s.room=e)}o.campaignInProgress.rooms[e]={...i,id:e},delete o.campaignInProgress.rooms[t],o.currentlyEditingRoomId=e};function*ht(o,e){const t={type:"wall",config:rt(o.config.direction)?o.config.direction==="towards"?{direction:o.config.direction,times:{x:2}}:{direction:o.config.direction,times:{y:2}}:{direction:o.config.direction,tiles:[...lo(e.planet,2,o.position[o.config.direction==="away"?"x":"y"])]},position:{...o.position,z:0}};yield[ut(e,t,!1),t]}const Gn=(o,e)=>{const t=o.items[e];if(t.type==="door"){for(const[i,n]of ht(t,o))o.items[i]=n;o.items=de(o.items)}delete o.items[e]},Ge=(o,e)=>{co(o).filter(t=>t.type==="floor").filter(t=>t.position.z===0).forEach(t=>{t.config={...t.config,floorType:e,scenery:e==="standable"?o.planet:void 0}})},Kn={changeRoomColour(o,{payload:e}){const t=o,i=t.campaignInProgress.rooms[t.currentlyEditingRoomId].color;Q(t),Object.assign(i,e)},changeRoomScenery(o,{payload:e}){const t=o,i=O(t);Q(t),dt(i,e)},roomJsonEdited(o,{payload:e}){const t=o;Q(t);const{rooms:i}=t.campaignInProgress,n=i[t.currentlyEditingRoomId];i[t.currentlyEditingRoomId]=e;const s=t.selectedJsonItemIds.filter(a=>e.items[a]!==void 0);s.length!==t.selectedJsonItemIds.length&&(t.selectedJsonItemIds=s),e.id!==t.currentlyEditingRoomId&&qn(t,e.id),G(e.items,"door").filter(([a,d])=>n.items[a]?.type==="door").filter(([,a])=>i[a.config.toRoom]!==void 0).forEach(([a,d])=>{const f=i[d.config.toRoom],u=Ze(d.config.direction),l=G(f.items,"door").filter(([,y])=>y.config.direction===u).toArray();switch(l.length){case 0:mt({state:t,outgoingDoorEntry:[a,d],fromRoomJson:e,toRoomJson:f});break;case 1:{const[[,y]]=l;y.config.toRoom=e.id,y.config.toDoor=a;break}}});const r=n.meta?.nonContiguousRelationship,c=e.meta?.nonContiguousRelationship;if(c!==void 0){const a=i[c.with.room];a.meta={...a.meta,nonContiguousRelationship:{with:{room:e.id},gridOffset:Zo(c.gridOffset,-1)}}}if(r?.with.room!==void 0&&c?.with.room!==r.with.room){const a=i[r.with.room];a.meta?.nonContiguousRelationship?.with.room===t.currentlyEditingRoomId&&delete a.meta.nonContiguousRelationship}},deleteSelected(o){const e=o,t=O(e);Q(e),e.selectedJsonItemIds.forEach(i=>{Gn(t,i)}),e.selectedJsonItemIds=[]},clearRoom(o){const e=o,t=O(e);Q(e);for(const i of Uo(t.items)){const n=t.items[i];n.type!=="floor"&&n.type!=="wall"&&n.type!=="door"&&(delete t.items[i],e.selectedJsonItemIds=e.selectedJsonItemIds.filter(s=>s!==i))}},setRoomAboveOrBelow(o,{payload:e}){const t=o,i=e.direction==="above"?"roomAbove":"roomBelow",n=i==="roomAbove"?"roomBelow":"roomAbove",s=O(t),r=e.createNew?fe({state:t,scenery:s.planet,maybeColour:s.color}).id:e.roomId,c=s[i]&&Ko(t,s[i]);c?.[n]===t.currentlyEditingRoomId&&(c[n]=void 0),s[i]=r;const a=r&&Ko(t,r);a!==void 0&&(a[n]=s.id),a?Ge(i==="roomBelow"?s:a,"none"):Ge(i==="roomBelow"?s:c,"standable")}},Jn=(o,e)=>{const t=Ue(e);for(const[i,n]of t)n===null?delete o.items[i]:o.items[i]=n},Vn={setAutoCoalesce(o,e){o.autoCoalesce=e.payload},resetPreviewedEdits(o){o.previewedEdits={}},commitCurrentPreviewedEdits(o){Q(o),Jn(O(o),o.previewedEdits),o.autoCoalesce&&Vo(o),o.previewedEdits={}}},Un=(o,...e)=>({x:o(...e.map(t=>t.x)),y:o(...e.map(t=>t.y)),z:o(...e.map(t=>t.z))}),Ke=(o,e,t)=>{const i=t-o.length;i>0?o.push(...lo(e,i,o.length)):i<0&&o.splice(t)};function xt(o,e){const t=yo(o.config),i=m(e.position,e.config.times);switch(o.config.direction){case"towards":if(o.position.y===e.position.y&&o.position.x>=e.position.x&&o.position.x<i.x)return{tangentAxis:"x",normalAxis:"y",edgePosition:o.position.y,wallStart:o.position.x,wallLength:t.x??1,isOnFloorEdge:!0,wallFullySpansFloor:o.position.x===e.position.x&&t.x===e.config.times.x,wallTouchesFloorEnd:o.position.x+(t.x??1)===i.x};break;case"right":if(o.position.x===e.position.x&&o.position.y>=e.position.y&&o.position.y<i.y)return{tangentAxis:"y",normalAxis:"x",edgePosition:o.position.x,wallStart:o.position.y,wallLength:t.y??1,isOnFloorEdge:!0,wallFullySpansFloor:o.position.y===e.position.y&&t.y===e.config.times.y,wallTouchesFloorEnd:o.position.y+(t.y??1)===i.y};break;case"away":if(o.position.y===e.position.y+e.config.times.y&&o.position.x>=e.position.x&&o.position.x<i.x)return{tangentAxis:"x",normalAxis:"y",edgePosition:o.position.y,wallStart:o.position.x,wallLength:t.x??1,isOnFloorEdge:!0,wallFullySpansFloor:o.position.x===e.position.x&&t.x===e.config.times.x,wallTouchesFloorEnd:o.position.x+(t.x??1)===i.x};break;case"left":if(o.position.x===e.position.x+e.config.times.x&&o.position.y>=e.position.y&&o.position.y<i.y)return{tangentAxis:"y",normalAxis:"x",edgePosition:o.position.x,wallStart:o.position.y,wallLength:t.y??1,isOnFloorEdge:!0,wallFullySpansFloor:o.position.y===e.position.y&&t.y===e.config.times.y,wallTouchesFloorEnd:o.position.y+(t.y??1)===i.y};break}return null}function*bt(o,e,t,i,n){const s=m(e.position,i),r=e.config.times,c=n?m(r,n):e.config.times,a=m(e.position,r),d=m(s,c);for(const[f,u]of Y(o)){if(u.type==="wall"&&u.position.z!==e.position.z)continue;if(u.type==="door"){const p=u.config;let T=!1,A={...q(u.position)};switch(p.direction){case"towards":u.position.y===e.position.y&&u.position.x>=e.position.x&&u.position.x<e.position.x+r.x&&(T=!0,A=m(u.position,i));break;case"right":u.position.x===e.position.x&&u.position.y>=e.position.y&&u.position.y<e.position.y+r.y&&(T=!0,A=m(u.position,i));break;case"away":u.position.y===e.position.y+r.y&&u.position.x>=e.position.x&&u.position.x<e.position.x+r.x&&(T=!0,A=m(u.position,{x:i.x,y:i.y+(n?.y??0),z:i.z}));break;case"left":u.position.x===e.position.x+r.x&&u.position.y>=e.position.y&&u.position.y<e.position.y+r.y&&(T=!0,A=m(u.position,{x:i.x+(n?.x??0),y:i.y,z:i.z}));break}if(T){const I=structuredClone(q(u));I.position=A,yield[f,I]}continue}const l=u,y=xt(l,e);if(!y||!y.isOnFloorEdge)continue;const g=structuredClone(q(l));switch(l.config.direction){case"towards":case"right":g.position=m(l.position,i);break;case"away":{const p=s.y+c.y;g.position={...l.position,x:l.position.x+i.x,y:p};break}case"left":{const p=s.x+c.x;g.position={...l.position,x:p,y:l.position.y+i.y};break}}if(y.wallFullySpansFloor){const p=c[y.tangentAxis];l.config.direction==="away"||l.config.direction==="left"?Ke(g.config.tiles,t,p):g.config.times={[y.tangentAxis]:p},yield[f,g]}else{const p=e.position[y.tangentAxis],T=a[y.tangentAxis],A=s[y.tangentAxis],I=d[y.tangentAxis],k=g.position[y.tangentAxis];if(k>=I){yield[f,null];continue}const z=Math.max(y.wallStart,p),P=Math.min(y.wallStart+y.wallLength,T)-z;let E;if(l.config.direction==="away"||l.config.direction==="left"){const v=e.position[y.normalAxis]+r[y.normalAxis],M=s[y.normalAxis]+c[y.normalAxis];E=v!==M}else E=e.position[y.normalAxis]!==s[y.normalAxis];const F=Math.max(k,A);let x;y.wallTouchesFloorEnd&&!E?x=I:x=Math.min(k+P,I);const w=x-F;w<=0?yield[f,null]:(l.config.direction==="away"||l.config.direction==="left"?Ke(g.config.tiles,t,w):g.config.times={[y.tangentAxis]:w},yield[f,g])}}}function*Zn(o,e,t,i){for(const[n,s]of G(o.items,"floor")){const r=xt(e,s);if(!r)continue;const c={x:0,y:0,z:0},a={x:0,y:0,z:0},d=t[r.normalAxis],f=t[r.tangentAxis],u=i?i[r.tangentAxis]:0;if(d!==0&&(e.config.direction==="towards"||e.config.direction==="right"?(c[r.normalAxis]=d,a[r.normalAxis]=-d):a[r.normalAxis]=d),f!==0&&(r.wallStart===s.position[r.tangentAxis]?(c[r.tangentAxis]=f,a[r.tangentAxis]=-f):r.wallTouchesFloorEnd&&(a[r.tangentAxis]=f)),u!==0&&r.wallTouchesFloorEnd&&(a[r.tangentAxis]=u),c.x!==0||c.y!==0||a.x!==0||a.y!==0){const l=m(s.config.times,a),y={...s,position:m(s.position,c),config:{...s.config,times:{x:l.x,y:l.y}}};yield[n,y]}yield*bt(G(o.items,"wall","door"),s,o.planet,c,a)}}const Qn={moveOrResizeItemAsPreview(o,{payload:{jsonItemIds:e,timesDelta:t,positionDelta:i}}){const n=o,s=O(n);for(const r of e){const c=lt(n,r);if(c===void 0)throw new Error(`no json item found for some of the ids in resize ${r}`);if(c.type==="wall"){for(const[d,f]of Zn(s,c,i,t))n.previewedEdits[d]=f;continue}if(c.type==="floor")for(const[d,f]of bt(G(s.items,"wall","door"),c,s.planet,i,t))n.previewedEdits[d]=f;if(c.type==="door"){console.log("before healing, room items are",q(s.items));for(const[d,f]of ht(c,q(s)))console.log("healing",`"${d}"`,f),n.previewedEdits[d]=f}const a={...c,position:m(c.position,i),config:{...c.config}};if(n.previewedEdits[r]=a,jn(a,t),c.type==="door"){console.log("before cutting room plus previews is",{...q(s.items),...q(n.previewedEdits)});for(const[d,f]of gt({...q(s.items),...q(n.previewedEdits)},a.config.direction,a.position))console.log("cutting",`"${d}"`,f),n.previewedEdits[d]=f}}n.dragInProgress=!0}},jn=(o,e)=>{if(e!==void 0){const t=H(o),i=le(o),n=$t(e,i);if(oe(n)>0){const s=nt(Un((r,c)=>Math.max(1,r+c),t,n));s===void 0?delete o.config.times:o.config.times=s}}},os={loadCampaign(o,{payload:{campaign:e}}){const t=o;t.remoteCampaign=e,t.campaignInProgress=e,t.hoveredItem=void 0,t.selectedJsonItemIds=[],t.clickableAnnotationHovered=!1,t.dragInProgress=!1,t.history=ne.history;const i=Y(so(e.rooms)).find(n=>co(n).some(s=>s.type==="player"&&s.config.which==="head"))?.id??Y(so(e.rooms)).find(n=>co(n).some(s=>s.type==="player"&&s.config.which==="heels"))?.id??Yo(Uo(e.rooms));if(i===void 0)throw new Error("could not find any rooms in this campaign");t.currentlyEditingRoomId=i},setRemoteCampaign(o,{payload:{campaign:e}}){const t=o;t.remoteCampaign=e}},es={setSelectedItemsInRoom(o,{payload:{jsonItemIds:e}}){const t=O(o).items;e.forEach(i=>{if(!t[i])throw new Error(`Item with json item id "${i}" is not in the current room`)}),o.selectedJsonItemIds=e},toggleSelectedItemInRoom(o,{payload:{jsonItemId:e}}){const t=o.selectedJsonItemIds.indexOf(e);t===-1?o.selectedJsonItemIds.push(e):o.selectedJsonItemIds.splice(t,1)},setHoveredItemInRoom(o,e){o.hoveredItem=e.payload},setClickableAnnotationHovered(o,e){o.clickableAnnotationHovered=e.payload}},ts=[1,.5,.125],ue=Wt({name:"levelEditor",initialState:ne,reducers:{setTool(o,{payload:e}){const t=o;e.type==="item"&&(t.selectedJsonItemIds=[],t.hoveredItem=void 0),t.tool=e},injected(){},...Ln,...Wn,...Xn,...Yn,...es,...Kn,...Qn,...Vn,...os,...An,...Hn,...Dn},selectors:{selectCurrentCampaignInProgress:o=>o.campaignInProgress,selectCurrentEditingRoomJson:O,selectItem:lt,selectCurrentEditingRoomColour:o=>O(o).color,selectCurrentEditingRoomScenery:o=>O(o).planet,selectTool:o=>o.tool,selectSelectedJsonItemIds:o=>o.selectedJsonItemIds,selectHoveredItem:o=>o.hoveredItem,selectItemIsSelected:xn,...Bn}}),{addRoom:is,applyItemTool:ns,changeDragInProgress:ss,changeGridResolution:rs,changeRoomColour:as,changeRoomScenery:cs,changeToRoom:ls,changeWallsFloorsLocked:ds,clearRoom:fs,commitCurrentPreviewedEdits:us,deleteSelected:ys,injected:gs,loadCampaign:ps,moveOrResizeItemAsPreview:ms,redo:hs,removeRoom:xs,resetPreviewedEdits:bs,roomBack:ws,roomForward:vs,roomJsonEdited:Is,setAutoCoalesce:zs,setCampaignName:Rs,setCampaignPublished:ks,setCampaignUserId:Es,setClickableAnnotationHovered:Ps,setHoveredItemInRoom:As,setRemoteCampaign:Cs,setRoomAboveOrBelow:Ts,setSelectedItemsInRoom:Ss,setTool:Os,toggleSelectedItemInRoom:Fs,undo:Ns}=ue.actions,{selectCanRedo:$s,selectCanUndo:Ws,selectCurrentCampaignInProgress:Bs,selectCurrentEditingRoomColour:Ms,selectCurrentEditingRoomJson:_s,selectCurrentEditingRoomScenery:Xs,selectHoveredItem:Ds,selectItem:Hs,selectItemIsSelected:Ys,selectSelectedJsonItemIds:Ls,selectTool:qs}=ue.selectors,Gs=Bt.withTypes(),kr=Object.freeze(Object.defineProperty({__proto__:null,addRoom:is,applyItemTool:ns,changeDragInProgress:ss,changeGridResolution:rs,changeRoomColour:as,changeRoomScenery:cs,changeToRoom:ls,changeWallsFloorsLocked:ds,clearRoom:fs,commitCurrentPreviewedEdits:us,deleteSelected:ys,gridResolutions:ts,injected:gs,levelEditorSlice:ue,loadCampaign:ps,moveOrResizeItemAsPreview:ms,redo:hs,removeRoom:xs,resetPreviewedEdits:bs,roomBack:ws,roomForward:vs,roomJsonEdited:Is,selectCanRedo:$s,selectCanUndo:Ws,selectCurrentCampaignInProgress:Bs,selectCurrentEditingRoomColour:Ms,selectCurrentEditingRoomJson:_s,selectCurrentEditingRoomScenery:Xs,selectHoveredItem:Ds,selectItem:Hs,selectItemIsSelected:Ys,selectSelectedJsonItemIds:Ls,selectTool:qs,setAutoCoalesce:zs,setCampaignName:Rs,setCampaignPublished:ks,setCampaignUserId:Es,setClickableAnnotationHovered:Ps,setHoveredItemInRoom:As,setRemoteCampaign:Cs,setRoomAboveOrBelow:Ts,setSelectedItemsInRoom:Ss,setTool:Os,toggleSelectedItemInRoom:Fs,undo:Ns,useAppSelectorWithLevelEditorSlice:Gs},Symbol.toStringTag,{value:"Module"}));export{Oi as $,Hs as A,Ys as B,Ss as C,ce as D,ms as E,Fs as F,Di as G,us as H,gi as I,pn as J,hn as K,qs as L,ss as M,Rr as N,ls as O,Gs as P,B as Q,lr as R,rr as S,ar as T,Ci as U,fr as V,mi as W,js as X,Gi as Y,qo as Z,tr as _,Mi as a,lo as a$,mr as a0,X as a1,qi as a2,dr as a3,j as a4,br as a5,hr as a6,xr as a7,wr as a8,vr as a9,Is as aA,ys as aB,ts as aC,rs as aD,jn as aE,at as aF,oi as aG,nr as aH,Bs as aI,Ms as aJ,as as aK,Ts as aL,Xs as aM,cs as aN,Qe as aO,yi as aP,Qs as aQ,Rs as aR,ks as aS,Es as aT,Cs as aU,ps as aV,Ws as aW,$s as aX,Ns as aY,hs as aZ,ds as a_,Ps as aa,Ls as ab,C as ac,cr as ad,zi as ae,ai as af,re as ag,sr as ah,zr as ai,Mt as aj,Yt as ak,ui as al,ir as am,Zs as an,si as ao,Us as ap,te as aq,_s as ar,eo as as,is as at,xs as au,zs as av,ws as aw,vs as ax,fs as ay,O as az,Xi as b,kr as b0,_i as c,ur as d,yr as e,gr as f,Lo as g,or as h,io as i,h as j,As as k,lt as l,Os as m,er as n,Li as o,pr as p,Ir as q,zo as r,Ds as s,bs as t,$ as u,ns as v,yo as w,H as x,le as y,Un as z};
