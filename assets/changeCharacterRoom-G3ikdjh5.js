import{s as A,a as O,b as L,c as E,e as V,f as w,g as v,h as u,j as F,k as M,x as H,l as m,m as x,n as X,r as J,p as q,q as N,t as S,u as Y,w as Z,y as I,z as K,A as G,B as Q,C as U,D as _,E as P,F as j,H as tt,I as it,J as D,K as $,L as ot,M as et,N as st,O as z}from"./App-Cj1u-YlO.js";const nt=1e3/25,W=t=>{const i=A.animations[t],e=i.length,{animationSpeed:o}=i;return e*nt/o};W("bubbles.white");const at=W("head.fadeOut"),rt=({touchedItem:t,room:i,gameState:e})=>{O({room:i,item:t});const o=L({itemType:"bubbles",config:{style:"white",was:t.type==="pickup"?{type:"pickup",gives:t.config.gives}:t.type==="hushPuppy"?{type:"hushPuppy"}:{type:"disappearing"}},position:E,room:i,gameState:e}),s=V(t);o.state.position=w(s,v(o.aabb,.5)),o.state.expires=i.roomTime+at},dt=(t,i)=>{const e=u(t.items).filter(F("hushPuppy"));for(const o of e)rt({touchedItem:o,gameState:i,room:t})},lt=.5,b=(t,i,e,o)=>{const s=e.x+o.x-t.x,r=e.y+o.y-t.y,d=e.z+o.z-t.z,p=t.x+i.x-e.x,f=t.y+i.y-e.y,y=t.z+i.z-e.z,l=Math.abs(s)<Math.abs(p)?s:-p,h=Math.abs(r)<Math.abs(f)?r:-f,n=Math.abs(d)<Math.abs(y)?d:-y,a=Math.abs(l),c=Math.abs(h),k=Math.abs(n)*lt;return a<c&&a<k?{x:l,y:0,z:0}:c<k?{x:0,y:h,z:0}:{x:0,y:0,z:n}},C=(t,i)=>({x:t.x>0?i.state.position.x:i.state.position.x+i.aabb.x,y:t.y>0?i.state.position.y:i.state.position.y+i.aabb.y,z:t.z>0?i.state.position.z:i.state.position.z+i.aabb.z}),R={stopAutowalk:5,portal:5,wall:5,doorLegs:5,sceneryPlayer:5,bubbles:5,switch:10,doorFrame:15,ball:18,block:20,barrier:20,floor:20,floorEdge:20,hushPuppy:20,teleporter:20,lift:30,movingPlatform:30,pushableBlock:30,portableBlock:30,sceneryCrown:30,slidingBlock:30,spring:30,joystick:40,charles:40,conveyor:40,head:50,heels:50,headOverHeels:50,pickup:80,firedDoughnut:90,spikes:98,slidingDeadly:100,moveableDeadly:100,deadlyBlock:100,monster:100,floatingText:200,emitter:200},ct=(t,i)=>R[t.type]-R[i.type],pt=(t,i)=>i.toSorted((e,o)=>{const s=ct(e,o);if(s!==0)return s;const r=M(t,C(t,e)),d=M(t,C(t,o));return Math.abs(r-d)<1e-4?e.id<o.id?-1:1:r-d}),B=({subjectItem:t,posDelta:i,gameState:e,room:o,pusher:s,deltaMS:r,forceful:d=F("lift")(t)&&s===void 0,recursionDepth:p=0,onTouch:f})=>{if(H(i,E))return;const{state:{position:y}}=t;if(t.state.position=m(y,i),x(t)){const{actedOnAt:n}=t.state;n.roomTime===o.roomTime?s&&(n.by[s.id]=!0):(n.by=s?{[s.id]:!0}:{},n.roomTime=o.roomTime)}const l=pt(i,X(t,J(o.items)));let h=!1;for(const n of l){if(!q(t,n))continue;const a=N(n);if(s!==n&&!(h&&a)&&f!==void 0&&(f({movingItem:t,touchedItem:n,movementVector:w(t.state.position,y),gameState:e,deltaMS:r,room:o}),h=h||a),o.items[t.id]===void 0)return;if(o.items[n.id]===void 0||!S(n,t)||!S(t))continue;const c=b(t.state.position,t.aabb,n.state.position,n.aabb),k=Y(Z(b(y,t.aabb,n.state.position,n.aabb)),0);if(I(t,n,d)&&n!==s){const g=d||_(n)?-1:-.5,T=v(c,g);if(t.state.position=m(t.state.position,c,T),p<K&&B({subjectItem:n,posDelta:T,pusher:t,gameState:e,room:o,deltaMS:r,forceful:d,recursionDepth:p+1,onTouch:f}),o.items[n.id]===void 0)continue;t.state.position=m(t.state.position,b(t.state.position,t.aabb,n.state.position,n.aabb))}else t.state.position=m(t.state.position,c);if(x(t)&&c.z>0&&(t.state.standingOnItemId===null||!l.includes(G(t.state.standingOnItemId,o)))&&(Q(t,o),U({above:t,below:n})),x(t)&&!k){const{collidedWith:g}=t.state;g.roomTime===o.roomTime?s&&(g.by[n.id]=!0):(g.by={[n.id]:!0},g.roomTime=o.roomTime)}}},ft=(t,i,{changeType:e,sourceItem:o})=>{switch(e){case"portal":return u(t.items).find(s=>z(s)&&s.config.toRoom===i.id&&H(v(o.config.direction,-1),s.config.direction));case"level-select":return u(t.items).find(s=>z(s)&&s.config.toRoom===i.id&&s.config.direction.z===0)??u(t.items).find(s=>z(s)&&s.config.direction.z===0)??u(t.items).find(s=>z(s)&&s.config.direction.z>0)??u(t.items).find(z)}},yt=(t,i,e,o)=>{const s=1*$.w;t.state.position=m(t.state.position,v(i,s));for(let r=0;r<s;r++)B({subjectItem:t,posDelta:v(i,-1),gameState:e,room:o,deltaMS:16,forceful:!0,onTouch:void 0})},mt=t=>{const{playableItem:i,gameState:e,toRoomId:o,changeType:s,sourceItem:r}=t,d=e.characterRooms[i.id];if(d===void 0)throw new Error(`${i.id} is not in a room on the gameState`);if(o===d.id)throw new Error(`Can't move ${i.id} to the same room "${o}""`);let p;switch(s){case"portal":{const{config:{relativePoint:a},state:{position:c}}=r;p=w(i.state.position,m(c,a));break}case"teleport":{const{state:{position:a}}=r;p=w(i.state.position,a);break}case"level-select":p={x:0,y:0,z:0};break;default:throw new Error}const f=i.type==="headOverHeels"?void 0:e.characterRooms[P(i.id)],y=e.campaign.rooms[o];if(y===void 0)throw new Error(`room ${o} does not exist in campaign`);const l=f?.id===o?f:j({roomJson:y,roomPickupsCollected:e.pickupsCollected[o]??tt});O({room:d,item:i});const h=it(i);if(h!==void 0&&(h.carrying=null),i.state.latentMovement=[],(i.type==="head"||i.type==="headOverHeels")&&dt(l,e),O({room:l,item:i}),l.items[i.id]=i,e.characterRooms[i.id]=l,t.changeType==="teleport"){const{config:{toPosition:a}}=t.sourceItem;i.state.position=m(D(a),p)}else{const a=ft(l,d,t);if(console.log("putting",i.id,"into",o,"at portal",a,"because",s,"sourceportal",r),a===void 0)if(t.changeType==="level-select")i.state.position=D({x:1,y:1,z:8});else throw new Error(`trying to move ${i.id} from ${d.id} --to-> ${o} but no destination portal found to locate with`);else{i.state.position=m(a.state.position,a.config.relativePoint,p,s==="portal"&&r.config.direction.z>0?{z:$.h}:{});const{config:{direction:c}}=a;c.z===0&&(i.state.autoWalk=!0,i.state.facing=v(c,-1),i.state.action==="idle"&&(i.state.action="moving"),yt(i,c,e,l))}}const n=X(i,J(l.items));n.length>0&&console.warn("on entering room",o,"character",i.id,"at",i.state.position,"collides with",n),e.entryState[i.id]=ot(i),i.id==="headOverHeels"?(delete e.entryState.head,delete e.entryState.heels):(e.entryState[P(i.id)]||(e.entryState[P(i.id)]=e.entryState.headOverHeels),delete e.entryState.headOverHeels),et.dispatch(st(o))};export{ct as a,B as b,mt as c,rt as d,at as f,b as m,nt as o,dt as r};
