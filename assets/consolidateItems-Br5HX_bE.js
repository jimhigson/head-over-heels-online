import{l as R,o as P,u as B,g as X,b as W,c as K,e as $}from"./App-B0Q5mvB1.js";function Y(r){var t="";return n(r),t;function n(o){if(o===null||typeof o!="object"||o.toJSON!=null)t+=JSON.stringify(o);else if(Array.isArray(o)){t+="[";var f=!1;o.forEach(function(m){f&&(t+=","),f=!0,m===void 0&&(m=null),n(m)}),t+="]"}else{t+="{";var d=Object.keys(o).filter(function(m){return o[m]!==void 0}).sort();d.forEach(function(m,S){return i(o,m,S)}),t+="}"}}function i(o,f,d){d>0&&(t+=","),t+=JSON.stringify(f),t+=":",n(o[f])}}const J=r=>R(q(r))>0,q=r=>{switch(r.type){case"deadlyBlock":return B;case"conveyor":if(r.config.disappearing)return P;switch(r.config.direction){case"left":case"right":return{x:1,y:0,z:0};case"away":case"towards":return{x:0,y:1,z:0};default:throw r.config.direction,new Error}case"hushPuppy":return B;case"teleporter":return{x:1,y:1,z:0};case"floor":case"spikes":return{x:1,y:1,z:0};case"block":return r.config.disappearing?P:B;case"barrier":if(r.config.disappearing)return P;switch(r.config.axis){case"x":return{x:1,y:0,z:1};case"y":return{x:0,y:1,z:1};default:throw r.config.axis,new Error}case"wall":switch(r.config.direction){case"left":case"right":return{x:0,y:1,z:1};case"away":case"towards":return{x:1,y:0,z:1};default:throw r.config,new Error}default:return P}};class N{#i;#e;#t;constructor(t,n){this.#e={x:-t.x,y:-t.y,z:-t.z},this.#t={x:n.x-t.x+1,y:n.y-t.y+1,z:n.z-t.z+1},this.#i=Array.from({length:this.#t.x},()=>Array.from({length:this.#t.y},()=>Array.from({length:this.#t.z},()=>new Set)))}static fromItems(t){let n=1/0,i=1/0,o=1/0,f=-1/0,d=-1/0,m=-1/0;const S=[...t];for(const[,A]of S){const{x:e,y,z:l}=A.position,s=X(A);n=Math.min(n,e),i=Math.min(i,y),o=Math.min(o,l),f=Math.max(f,e+s.x-1),d=Math.max(d,y+s.y-1),m=Math.max(m,l+s.z-1)}if(S.length===0)return new N({x:0,y:0,z:0},{x:0,y:0,z:0});const C=new N({x:n,y:i,z:o},{x:f,y:d,z:m});for(const A of S){const[,e]=A,{x:y,y:l,z:s}=e.position,w=X(e);for(let I=0;I<w.x;I++)for(let k=0;k<w.y;k++)for(let M=0;M<w.z;M++)C.add({x:y+I,y:l+k,z:s+M},A)}return C}get(t){const n=t.x+this.#e.x,i=t.y+this.#e.y,o=t.z+this.#e.z;if(this.#o(n,i,o))return this.#i[n][i][o]}set(t,n){const i=t.x+this.#e.x,o=t.y+this.#e.y,f=t.z+this.#e.z;this.#o(i,o,f)&&(this.#i[i][o][f]=n)}add(t,n){const i=this.get(t);i&&i.add(n)}remove(t,n){const i=this.get(t);i&&i.delete(n)}get size(){return{...this.#t}}get minBounds(){return{x:-this.#e.x,y:-this.#e.y,z:-this.#e.z}}get maxBounds(){const t=this.minBounds;return{x:t.x+this.#t.x-1,y:t.y+this.#t.y-1,z:t.z+this.#t.z-1}}*iterate(){const{minBounds:t}=this;for(let n=0;n<this.#t.x;n++)for(let i=0;i<this.#t.y;i++)for(let o=0;o<this.#t.z;o++)yield[{x:n+t.x,y:i+t.y,z:o+t.z},this.#i[n][i][o]]}extractUniqueItems(){const t=new Set,n=[];for(const[,i]of this.iterate())for(const o of i)t.has(o)||(t.add(o),n.push(o));return n}#o(t,n,i){return t>=0&&t<this.#t.x&&n>=0&&n<this.#t.y&&i>=0&&i<this.#t.z}}const E=r=>r.type==="wall"?`wall/${r.config.direction}`:r.type==="teleporter"?Y({type:r.type,config:K(r.config,"toPosition","times")}):Y({type:r.type,config:K(r.config,"times")}),F=r=>J(r[1]),H=r=>({x:Math.floor(r.x%1*W.x),y:Math.floor(r.y%1*W.y)}),U=(r,t)=>`${r},${t}`,V=r=>{let t=r,n=t.length;for(;;){const i=[...D(t)];if(i.length===n)return i;n=i.length,t=i}},Z=r=>{const t=new Map,n=[];for(const o of r){const[,f]=o;if(J(f)){const d=H(f.position),m=U(d.x,d.y);t.has(m)||t.set(m,[]),t.get(m).push(o)}else n.push(o)}const i=[];for(const[o,f]of t)if(f.length>0){const d=f.map(([y,l])=>[y,{...l,position:{x:Math.floor(l.position.x),y:Math.floor(l.position.y),z:l.position.z}}]),m=V(d),[S,C]=o.split(",").map(Number),A=S/W.x,e=C/W.y;for(const[y,l]of m)i.push([y,{...l,position:{x:l.position.x+A,y:l.position.y+e,z:l.position.z}}])}return[...i,...n]},D=r=>{const t=[],n=[];for(const e of r)F(e)?t.push(e):n.push(e);const i=N.fromItems(t),o=i.size,{minBounds:f}=i,d=new Map,m=new Map;for(const[,e]of i.iterate())for(const[,y]of e){const l=E(y);m.has(l)||m.set(l,y)}for(const[e]of m)d.set(e,Array.from({length:o.x},()=>Array.from({length:o.y},()=>Array(o.z).fill(!1))));const S=(e,y)=>{const l=X(y),s={x:e.x+l.x-1,y:e.y+l.y-1,z:e.z+l.z-1},w=q(y),I=E(y),k=new Set;k.add(y);const M=a=>{const u=new Set;let z=!1;for(let{x:c}=e;c<=a.x;c++)for(let{y:x}=e;x<=a.y;x++)for(let{z:h}=e;h<=a.z;h++){const b=i.get({x:c,y:x,z:h});let T=!1,O=!1;if(b)for(const[,v]of b)E(v)===I?(T=!0,u.add(v)):J(v)&&v.type!=="wall"&&(O=!0);O&&!T&&(z=!0),(!b||b.size===0)&&(z=!0),T||(z=!0)}if(z)return!1;let p=!1;for(const c of u)k.has(c)||(p=!0,k.add(c));if(!p)return!1;for(const c of u){const x=X(c),h={x:c.position.x+x.x-1,y:c.position.y+x.y-1,z:c.position.z+x.z-1};if(c.position.x<e.x||c.position.y<e.y||c.position.z<e.z||h.x>a.x||h.y>a.y||h.z>a.z)return!1}return!0};let g=!0;for(;g;){if(g=!1,w.x>0&&s.x+1<f.x+o.x){let a=s.x;for(let{y:u}=e;u<=s.y;u++)for(let{z}=e;z<=s.z;z++){const p=i.get({x:s.x+1,y:u,z});if(p){for(const[,c]of p)if(E(c)===I){const x=X(c),h=c.position.x+x.x-1;a=Math.max(a,h)}}}a>s.x&&M({...s,x:a})&&(s.x=a,g=!0)}if(w.y>0&&s.y+1<f.y+o.y){let a=s.y;for(let{x:u}=e;u<=s.x;u++)for(let{z}=e;z<=s.z;z++){const p=i.get({x:u,y:s.y+1,z});if(p){for(const[,c]of p)if(E(c)===I){const x=X(c),h=c.position.y+x.y-1;a=Math.max(a,h)}}}a>s.y&&M({...s,y:a})&&(s.y=a,g=!0)}if(w.z>0&&s.z+1<f.z+o.z){let a=s.z;for(let{x:u}=e;u<=s.x;u++)for(let{y:z}=e;z<=s.y;z++){const p=i.get({x:u,y:z,z:s.z+1});if(p){for(const[,c]of p)if(E(c)===I){const x=X(c),h=c.position.z+x.z-1;a=Math.max(a,h)}}}a>s.z&&M({...s,z:a})&&(s.z=a,g=!0)}}return s},C=(e,y)=>{if(e.type==="wall"){if(y.type!=="wall")throw new Error("only walls can join walls");if(e.config.direction!==y.config.direction)throw new Error("walls must have the same direction to join");return e.config.direction==="right"||e.config.direction==="towards"?e:{...e,config:{...e.config,tiles:[...e.config.tiles,...y.config.tiles]}}}return e},A=({x:e,y,z:l},{x:s,y:w,z:I},k)=>{const[M,g]=k,a=E(g),u=s-e+1,z=w-y+1,p=I-l+1;let c=g;if(u+z+p>3){const x={...g.config};if(g.type==="wall")switch(g.config.direction){case"away":case"left":break;case"towards":u!==1&&(x.times={x:u});break;case"right":z!==1&&(x.times={y:z});break}else{const h={...$(X(g))};u!==1&&(h.x=u),z!==1&&(h.y=z),p!==1&&(h.z=p),x.times=h}c={...g,config:x}}for(let x=e;x<=s;x++)for(let h=y;h<=w;h++)for(let b=l;b<=I;b++)if(d.get(a)[x-f.x][h-f.y][b-f.z]=!0,x!==e||h!==y||b!==l){const T=i.get({x,y:h,z:b});if(T)t:for(const O of T){const[,v]=O;if(E(v)===a){v.position.x===x&&v.position.y===h&&v.position.z===b&&(c=C(c,v)),i.remove({x,y:h,z:b},O);break t}}}return[M,c]};for(const[e,y]of i.iterate())for(const l of y){const[,s]=l;if(s.position.x===e.x&&s.position.y===e.y&&s.position.z===e.z){const w=E(s),I=d.get(w),k=e.x-f.x,M=e.y-f.y,g=e.z-f.z;if(I&&!I[k][M][g]){const a=S(e,s),u=A(e,a,l);i.remove(e,l),i.add(e,u)}}}return[...i.extractUniqueItems(),...n]},G=r=>Object.fromEntries(Z(Object.entries(r)));export{G as c,q as g};
