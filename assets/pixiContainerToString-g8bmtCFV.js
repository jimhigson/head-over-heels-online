import{f as Y,h as $,j as Z,o as X,k as _,m as M,n as x,q as z,r as D,l as F,x as I,y as G,A as H,B as m,C as S,D as K,E as V,F as J,H as Q,I as A,J as R,K as N,L as j,M as tt,N as et,O as it,P as st,Q as ot,R as nt,S as at,T as O,U as rt,W as w,X as lt,Y as ct,Z as E,_ as W,$ as dt,a0 as ft,a1 as pt,a2 as ht,a3 as v,a4 as yt}from"./App-Ddvx4FGQ.js";const ut=1e3/25,b=t=>{const e=Y.animations[t],s=e.length,{animationSpeed:i}=e;return s*ut/i};b("bubbles.white");const gt=b("head.fadeOut"),mt=({touchedItem:t,room:e,gameState:s})=>{$({room:e,item:t});const i=Z({itemType:"bubbles",config:{style:"white",was:t.type==="pickup"?{type:"pickup",gives:t.config.gives}:t.type==="hushPuppy"?{type:"hushPuppy"}:{type:"disappearing"}},position:X,room:e,gameState:s}),o=_(t);i.state.position=M(o,x(i.aabb,.5)),i.state.expires=e.roomTime+gt},xt=(t,e)=>{const s=z(t.items).filter(D("hushPuppy"));for(const i of s)mt({touchedItem:i,gameState:e,room:t})},zt=.5,vt=(t,e,s,i)=>t.x<s.x+i.x&&t.x+e.x>s.x&&t.y<s.y+i.y&&t.y+e.y>s.y&&t.z<s.z+i.z&&t.z+e.z>s.z,Mt=(t,e,s,i,o)=>{if(F(o)<1e-4)return{x:0,y:0,z:0};const c=I(o);if(!vt(t,e,s,i))return{x:0,y:0,z:0};let d=-1/0,p=1/0;for(const l of G){const r=c[l];if(Math.abs(r)<1e-4){const L=t[l],B=t[l]+e[l],P=s[l],U=s[l]+i[l];if(B<=P||L>=U)return{x:0,y:0,z:0};continue}const u=s[l],n=s[l]+i[l],a=t[l],h=t[l]+e[l],y=(u-h)/r,T=(n-a)/r,g=Math.min(y,T),k=Math.max(y,T);d=Math.max(d,g),p=Math.min(p,k)}return d>p?{x:0,y:0,z:0}:p>0&&(d>=0||p<-d)?x(c,p):d<0?x(c,d):{x:0,y:0,z:0}},C=(t,e,s,i)=>{const o=s.x+i.x-t.x,f=s.y+i.y-t.y,c=s.z+i.z-t.z,d=t.x+e.x-s.x,p=t.y+e.y-s.y,l=t.z+e.z-s.z,r=Math.abs(o)<Math.abs(d)?o:-d,u=Math.abs(f)<Math.abs(p)?f:-p,n=Math.abs(c)<Math.abs(l)?c:-l,a=Math.abs(r),h=Math.abs(u),y=Math.abs(n)*zt;return a<h&&a<y?{x:r,y:0,z:0}:h<y?{x:0,y:u,z:0}:{x:0,y:0,z:n}},Tt=(t,e,s,i)=>{const o=N(t,e,s),f=C(t.state.position,t.aabb,e.state.position,e.aabb);if(o&&f.z===0){const c=M(i,t.state.position),d=ot(c);if(nt(f,c)/d>.44)return Mt(t.state.position,t.aabb,e.state.position,e.aabb,{...c,z:0})}return f},q=({subjectItem:t,posDelta:e,gameState:s,room:i,pusher:o,deltaMS:f,forceful:c=D("lift")(t)&&o===void 0,recursionDepth:d=0,onTouch:p})=>{if(H(e,X))return;const{state:{position:l}}=t;if(t.state.position=m(l,e),S(t)){const{actedOnAt:n}=t.state;n.roomTime===i.roomTime?o&&(n.by[o.id]=!0):(n.by=o?{[o.id]:!0}:{},n.roomTime=i.roomTime)}const r=K(e,V(t,J(i.items)));let u=!1;for(const n of r){if(!Q(t,n))continue;const a=A(n);if(o!==n&&!(u&&a)&&p!==void 0&&(p({movingItem:t,touchedItem:n,movementVector:M(t.state.position,l),gameState:s,deltaMS:f,room:i}),u=u||a),i.items[t.id]===void 0)return;if(i.items[n.id]===void 0||!R(n,t)||!R(t))continue;const h=N(t,n,c),y=Tt(t,n,c,l),T=j(F(C(l,t.aabb,n.state.position,n.aabb)),0);if(h&&n!==o){const g=c||at(n)?-1:-.5,k=x(y,g);if(t.state.position=m(t.state.position,y,k),d<tt&&q({subjectItem:n,posDelta:k,pusher:t,gameState:s,room:i,deltaMS:f,forceful:c,recursionDepth:d+1,onTouch:p}),i.items[n.id]===void 0)continue;t.state.position=m(t.state.position,C(t.state.position,t.aabb,n.state.position,n.aabb))}else t.state.position=m(t.state.position,y);if(S(t)&&y.z>0&&(t.state.standingOnItemId===null||!r.includes(et(t.state.standingOnItemId,i)))&&(it(t,i),st({above:t,below:n})),S(t)&&!T){const{collidedWith:g}=t.state;g.roomTime===i.roomTime?o&&(g.by[n.id]=!0):(g.by={[n.id]:!0},g.roomTime=i.roomTime)}}},kt=(t,e,{changeType:s,sourceItem:i})=>{switch(s){case"portal":return z(t.items).find(o=>v(o)&&o.config.toRoom===e.id&&(i.config.toDoor===void 0||o.jsonItemId===i.config.toDoor)&&H(x(i.config.direction,-1),o.config.direction));case"level-select":return z(t.items).find(o=>v(o)&&o.config.toRoom===e.id&&o.config.direction.z===0)??z(t.items).find(o=>v(o)&&o.config.direction.z===0)??z(t.items).find(o=>v(o)&&o.config.direction.z>0)??z(t.items).find(v)}},St=(t,e,s,i)=>{const o=1*W.w;t.state.position=m(t.state.position,x(e,o));for(let f=0;f<o;f++)q({subjectItem:t,posDelta:x(e,-1),gameState:s,room:i,deltaMS:16,forceful:!0,onTouch:void 0})},Ct=t=>{const{playableItem:e,gameState:s,toRoomId:i,changeType:o,sourceItem:f}=t,c=s.characterRooms[e.id];if(c===void 0)throw new Error(`${e.id} is not in a room on the gameState`);if(i===c.id)throw new Error(`Can't move ${e.id} to the same room "${i}""`);let d;switch(o){case"portal":{const{config:{relativePoint:a},state:{position:h}}=f;d=M(e.state.position,m(h,a));break}case"teleport":{const{state:{position:a}}=f;d=M(e.state.position,a);break}case"level-select":d={x:0,y:0,z:0};break;default:throw new Error}const p=e.type==="headOverHeels"?void 0:s.characterRooms[O(e.id)],l=s.campaign.rooms[i];if(l===void 0)throw new Error(`room ${i} does not exist in campaign`);const r=p?.id===i?p:rt({roomJson:l,roomPickupsCollected:s.pickupsCollected[i]??lt,scrollsRead:w.getState().gameMenus.scrollsRead});$({room:c,item:e});const u=ct(e);if(u!==void 0&&(u.carrying=null),e.state.latentMovement=[],(e.type==="head"||e.type==="headOverHeels")&&xt(r,s),$({room:r,item:e}),r.items[e.id]=e,s.characterRooms[e.id]=r,t.changeType==="teleport"){const{config:{toPosition:a}}=t.sourceItem;e.state.position=m(E(a),d)}else{const a=kt(r,c,t);if(console.log("putting",e.id,"into",i,"at portal",a,"because",o,"sourceportal",f),a===void 0)if(t.changeType==="level-select")e.state.position=E({x:1,y:1,z:8});else throw new Error(`trying to move ${e.id} from ${c.id} --to-> ${i} but no destination portal found to locate with`);else{e.state.position=m(a.state.position,a.config.relativePoint,d,o==="portal"&&f.config.direction.z>0?{z:W.h}:{});const{config:{direction:h}}=a;h.z===0&&(e.state.autoWalk=!0,e.state.facing=x(h,-1),e.state.action==="idle"&&(e.state.action="moving"),St(e,h,s,r))}}const n=V(e,dt(J(r.items)).filter(a=>a.type!=="portal"));n.length>0&&console.warn("on entering room",i,"character",e.id,"at",e.state.position,"collides with",n),s.entryState[e.id]=ft(e),e.id==="headOverHeels"?(delete s.entryState.head,delete s.entryState.heels):(s.entryState[O(e.id)]||(s.entryState[O(e.id)]=s.entryState.headOverHeels),delete s.entryState.headOverHeels),w.dispatch(pt(i)),w.dispatch(ht({characterName:e.type,roomId:i}))},Ot={Container:"📦",Sprite:"🖼️",UniqueTextureSprite:"✨",Graphics:"🎨",Text:"📝",AnimatedSprite:"🎬",TilingSprite:"🔲",BitmapText:"🔤",Mesh:"🔺",NineSliceSprite:"🔳"},wt=(t,e="",s=!0,i=!0,o=[])=>{const f=[];i&&f.push("");const c=t.constructor.name,d=c.startsWith("_")?c.slice(1):c;let p=Ot[d]||"📌";o.forEach((a,h)=>{a.mask===t&&(h===0?p+="😷":p+=`😷^${h+1}`)});const l=t.label&&t.label!==d?` "${t.label}"`:"",r=[];try{(t.x!==0||t.y!==0)&&r.push(`@(${t.x}, ${t.y})`)}catch{r.push("@(ERROR)")}if(t.children.length>2&&r.push(`children: ${t.children.length}`),t.visible||r.push("hidden"),t.alpha<1&&r.push(`alpha: ${t.alpha.toFixed(2)}`),t.mask&&r.push("😷 masked"),t instanceof yt){const a=t;if(a.texture===null||a.texture===void 0)r.push("texture: NO TEXTURE");else{const h=a.texture.label||"(anon texture)";r.push(`texture: "${h}"`)}}const u=i?"":e+(s?"└── ":"├── ");if(f.push(`${u}${p} ${d}${l}`),r.length>0){const a=t.children.length>0,h=i?a?"│  ":"   ":e+(s?"    ":"│   ")+(a?"│  ":"   ");r.forEach(y=>{f.push(`${h}→ ${y}`)})}const n=i?"":e+(s?"    ":"│   ");return t.children.forEach((a,h)=>{const y=h===t.children.length-1;f.push(wt(a,n,y,!1,[t,...o]))}),f.join(`
`)+(i?`
`:"")};export{q as a,mt as b,Ct as c,gt as f,C as m,ut as o,wt as p,xt as r};
