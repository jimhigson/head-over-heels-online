import{ag as K,ah as ne,ai as se,aj as re,ak as Z,al as L,am as Wo,an as $o,ao as U,ap as No,aq as ce,ar as Q,as as ho,at as xo,au as oo,av as Io,aw as ae,ax as le,ay as _o,az as N,aA as j,aB as wo,aC as Ro,aD as Mo,aE as de,aF as X,aG as me,aH as fe,aI as no,aJ as W,aK as ye,aL as Oo,e as ue,aM as ge,aN as Lo,aO as pe,aP as Eo,aQ as he,aR as P,aS as Xo,aT as Do,aU as xe,aV as Ie,aW as we,aX as F,aY as so,aZ as V,a_ as Re,a$ as qo,b0 as Ee,b1 as ve,b2 as be,b3 as ze,a5 as Ce}from"./App-BXuZWElz.js";import{g as Ho}from"./spritesheetPalette-CzWQoMjj.js";import{g as lo}from"./index-BWiMp7rh.js";var q={},vo;function ke(){if(vo)return q;vo=1;const{iterableCurry:o}=K(),{__toArray:e}=ne();function*t(n,s){const r=Array.isArray(n)?n:e(n);if(r.length)for(;s--;)yield*r}q.__cycleTimes=t;const i=o(t);return q.cycleTimes=i,q}var H={},bo;function Se(){if(bo)return H;bo=1;const{iterableCurry:o}=K();function*e(i,n){let s=0;for(const r of i)n(r,s++)&&(yield r)}H.__filter=e;const t=o(e);return H.filter=t,H}var B={},zo;function Ae(){if(zo)return B;zo=1;const{iterableCurry:o}=K(),{__cycleTimes:e}=ke();function t(n){return e(n,1/0)}B.__cycle=t;const i=o(t);return B.cycle=i,B}var J={},Co;function Pe(){if(Co)return J;Co=1;const{iterableCurry:o}=K();function*e(i,n){let s=0;for(const r of i)s++>=n&&(yield r)}J.__drop=e;const t=o(e);return J.drop=t,J}var eo,ko;function Te(){return ko||(ko=1,eo=Ae().cycle),eo}var Fe=Te();const We=lo(Fe);var to,So;function $e(){return So||(So=1,to=Pe().drop),to}var Ne=$e();const _e=lo(Ne);var io,Ao;function Me(){return Ao||(Ao=1,io=Se().filter),io}var Oe=Me();const Le=lo(Oe),Lt=(o,e)=>o==="infinite"||e==="infinite"?"infinite":o+e,Xt=o=>o==="infinite"?Number.POSITIVE_INFINITY:o,Bo=(o,e=!1)=>Ho(e)[o],Dt=(o,e=!1,t=!1)=>Bo(`swop_${o}${e?"Dim":""}`,t),qt=(o,e=!1,t="light-dark")=>{const i=Ho(e),n=t==="light-mid"||t==="mid-dark",s=`swop_${o}`;if(n){const r=`${s}Mid`;if(r in i)return t==="light-mid"?{replaceLight:i[s],replaceDark:i[r]}:{replaceLight:i[r],replaceDark:i[`${s}Dim`]}}return{replaceLight:i[s],replaceDark:i[`${s}Dim`]}},Ht=(o,e=!1)=>o?Bo("white",e):se.white,Xe={jail:["bars"],blacktooth:["plain","plain","armour","shield","shield","armour"],bookworld:["book","book","cowboy"],egyptus:["hieroglyphics","hieroglyphics","hieroglyphics","sarcophagus","sarcophagus"],market:["passage","more-fruits","fruits","more-fruits","fruits"],moonbase:["coil","window1","window2","window3"],penitentiary:["loop","loop","skeleton"],safari:["wall","shield","wall","window","window","wall","shield"]},D=(o,e,t=0)=>{const i=Xe[o],n=i.length,s=(t%n+n)%n,r=We(i);return _e(s,re(e+s,r))},De=o=>({awayWall:{type:"wall",config:{direction:"away",tiles:Array.from(D("blacktooth",o.x))},position:{x:0,y:o.y,z:0}},leftWall:{type:"wall",config:{direction:"left",tiles:Array.from(D("blacktooth",o.y))},position:{x:o.x,y:0,z:0}},towardsWall:{type:"wall",config:{direction:"towards",times:{x:o.x}},position:{x:0,y:0,z:0}},rightWall:{type:"wall",config:{direction:"right",times:{y:o.y}},position:{x:0,y:0,z:0}}}),Jo=o=>({planet:"blacktooth",color:{hue:"cyan",shade:"basic"},items:{floor:{type:"floor",config:{floorType:"standable",scenery:"blacktooth",times:o},position:{x:0,y:0,z:0}},...De(o)}}),mo="room_0",qe={id:mo,...Jo({x:8,y:8})},He={meta:{published:!1},locator:{campaignName:void 0,userId:"anon",version:0},rooms:{[mo]:qe}},fo={campaignInProgress:He,remoteCampaign:void 0,currentlyEditingRoomId:mo,editingRoomIdHistory:{back:[],forward:[]},previewedEdits:{},tool:{type:"pointer"},hoveredItem:void 0,clickableAnnotationHovered:!1,selectedJsonItemIds:[],gridResolution:1,autoCoalesce:!0,wallsFloorsLocked:!0,dragInProgress:!1,history:{undo:[],redo:[]}},Be=Z([o=>k(o.levelEditor),o=>o.levelEditor.previewedEdits],(o,e)=>L(o,t=>{const i=Wo(e);for(const[n,s]of i)s===null?delete t.items[n]:t.items[n]=s})),Je=Z([o=>k(o.levelEditor)],o=>$o({roomJson:o,roomPickupsCollected:U,scrollsRead:U,isNewGame:!0,userSettings:No}));Z([Be],o=>$o({roomJson:o,roomPickupsCollected:U,scrollsRead:U,isNewGame:!0,userSettings:No}));Z([Je],o=>{const{floors:{edgeLeftX:e,edgeRightX:t,bottomEdgeY:i},allItems:{topEdgeY:n}}=ce(o);return{l:e,r:t,w:t-e,b:i,t:n,h:i-n}});const k=o=>o.campaignInProgress.rooms[o.currentlyEditingRoomId],ro=(o,e)=>o.campaignInProgress.rooms[e],Yo=(o,e,t)=>o.campaignInProgress.rooms[t??o.currentlyEditingRoomId]?.items[e],Ye=(o,e)=>o.selectedJsonItemIds.includes(e),yo=o=>_o(uo(o))>0,uo=o=>{switch(o.type){case"deadlyBlock":return oo;case"conveyor":if(o.config.disappearing)return Q;switch(o.config.direction){case"left":case"right":return le;case"away":case"towards":return ae;default:throw o.config.direction,new Error}case"hushPuppy":return oo;case"teleporter":return Io;case"floor":case"spikes":return Io;case"block":return oo;case"barrier":if(o.config.disappearing)return Q;switch(o.config.axis){case"x":return ho;case"y":return xo;default:throw o.config.axis,new Error}case"wall":switch(o.config.direction){case"left":case"right":return xo;case"away":case"towards":return ho;default:throw o.config,new Error}default:return Q}};class G{#t;#e;#o;constructor(e,t){this.#e={x:-e.x,y:-e.y,z:-e.z},this.#o={x:t.x-e.x+1,y:t.y-e.y+1,z:t.z-e.z+1},this.#t=Array.from({length:this.#o.x},()=>Array.from({length:this.#o.y},()=>Array.from({length:this.#o.z},()=>new Set)))}static fromItems(e){let t=1/0,i=1/0,n=1/0,s=-1/0,r=-1/0,l=-1/0;const a=[...e];for(const[,f]of a){const{x:y,y:c,z:m}=f.position,u=N(f);t=Math.min(t,y),i=Math.min(i,c),n=Math.min(n,m),s=Math.max(s,y+u.x-1),r=Math.max(r,c+u.y-1),l=Math.max(l,m+u.z-1)}if(a.length===0)return new G({x:0,y:0,z:0},{x:0,y:0,z:0});const d=new G({x:t,y:i,z:n},{x:s,y:r,z:l});for(const f of a){const[,y]=f,{x:c,y:m,z:u}=y.position,g=N(y);for(let C=0;C<g.x;C++)for(let z=0;z<g.y;z++)for(let w=0;w<g.z;w++)d.add({x:c+C,y:m+z,z:u+w},f)}return d}get(e){const t=e.x+this.#e.x,i=e.y+this.#e.y,n=e.z+this.#e.z;if(this.#i(t,i,n))return this.#t[t][i][n]}set(e,t){const i=e.x+this.#e.x,n=e.y+this.#e.y,s=e.z+this.#e.z;this.#i(i,n,s)&&(this.#t[i][n][s]=t)}add(e,t){const i=this.get(e);i&&i.add(t)}remove(e,t){const i=this.get(e);i&&i.delete(t)}get size(){return{...this.#o}}get minBounds(){return{x:-this.#e.x,y:-this.#e.y,z:-this.#e.z}}get maxBounds(){const e=this.minBounds;return{x:e.x+this.#o.x-1,y:e.y+this.#o.y-1,z:e.z+this.#o.z-1}}*iterate(){const{minBounds:e}=this;for(let t=0;t<this.#o.x;t++)for(let i=0;i<this.#o.y;i++)for(let n=0;n<this.#o.z;n++)yield[{x:t+e.x,y:i+e.y,z:n+e.z},this.#t[t][i][n]]}extractUniqueItems(){const e=new Set,t=[];for(const[,i]of this.iterate())for(const n of i)e.has(n)||(e.add(n),t.push(n));return t}#i(e,t,i){return e>=0&&e<this.#o.x&&t>=0&&t<this.#o.y&&i>=0&&i<this.#o.z}}const $=o=>o.type==="wall"?`wall/${o.config.direction}`:o.type==="teleporter"?wo({type:o.type,config:Ro(o.config,"toPosition","times")}):wo({type:o.type,config:Ro(o.config,"times")}),Ue=o=>yo(o[1]),je=o=>({x:Math.floor(o.x%1*j.x),y:Math.floor(o.y%1*j.y)}),Ve=(o,e)=>`${o},${e}`,Ge=(o,e)=>{let t=o,i=t.length;for(;;){const n=[...Ze(t,e)];if(n.length===i)return n;i=n.length,t=n}},Ke=(o,e=()=>!0)=>{const t=new Map,i=[];for(const s of o){const[,r]=s;if(!e(s))i.push(s);else if(yo(r)){const l=je(r.position),a=Ve(l.x,l.y);t.has(a)||t.set(a,[]),t.get(a).push(s)}else i.push(s)}const n=[];for(const[s,r]of t)if(r.length>0){const l=r.map(([m,u])=>[m,{...u,position:{x:Math.floor(u.position.x),y:Math.floor(u.position.y),z:u.position.z}}]),a=Ge(l,e),[d,f]=s.split(",").map(Number),y=d/j.x,c=f/j.y;for(const[m,u]of a)n.push([m,{...u,position:{x:u.position.x+y,y:u.position.y+c,z:u.position.z}}])}return[...n,...i]},Ze=(o,e=()=>!0)=>{const t=[],i=[];for(const c of o)e(c)&&Ue(c)?t.push(c):i.push(c);const n=G.fromItems(t),s=n.size,{minBounds:r}=n,l=new Map,a=new Map;for(const[,c]of n.iterate())for(const[,m]of c){const u=$(m);a.has(u)||a.set(u,m)}for(const[c]of a)l.set(c,Array.from({length:s.x},()=>Array.from({length:s.y},()=>Array(s.z).fill(!1))));const d=(c,m)=>{const u=N(m),g={x:c.x+u.x-1,y:c.y+u.y-1,z:c.z+u.z-1},C=uo(m),z=$(m),w=new Set;w.add(m);const E=h=>{const b=new Set;let v=!1;for(let{x:p}=c;p<=h.x;p++)for(let{y:x}=c;x<=h.y;x++)for(let{z:I}=c;I<=h.z;I++){const A=n.get({x:p,y:x,z:I});let M=!1,O=!1;if(A)for(const[,T]of A)$(T)===z?(M=!0,b.add(T)):yo(T)&&T.type!=="wall"&&(O=!0);O&&!M&&(v=!0),(!A||A.size===0)&&(v=!0),M||(v=!0)}if(v)return!1;let S=!1;for(const p of b)w.has(p)||(S=!0,w.add(p));if(!S)return!1;for(const p of b){const x=N(p),I={x:p.position.x+x.x-1,y:p.position.y+x.y-1,z:p.position.z+x.z-1};if(p.position.x<c.x||p.position.y<c.y||p.position.z<c.z||I.x>h.x||I.y>h.y||I.z>h.z)return!1}return!0};let R=!0;for(;R;){if(R=!1,C.x>0&&g.x+1<r.x+s.x){let h=g.x;for(let{y:b}=c;b<=g.y;b++)for(let{z:v}=c;v<=g.z;v++){const S=n.get({x:g.x+1,y:b,z:v});if(S){for(const[,p]of S)if($(p)===z){const x=N(p),I=p.position.x+x.x-1;h=Math.max(h,I)}}}h>g.x&&E({...g,x:h})&&(g.x=h,R=!0)}if(C.y>0&&g.y+1<r.y+s.y){let h=g.y;for(let{x:b}=c;b<=g.x;b++)for(let{z:v}=c;v<=g.z;v++){const S=n.get({x:b,y:g.y+1,z:v});if(S){for(const[,p]of S)if($(p)===z){const x=N(p),I=p.position.y+x.y-1;h=Math.max(h,I)}}}h>g.y&&E({...g,y:h})&&(g.y=h,R=!0)}if(C.z>0&&g.z+1<r.z+s.z){let h=g.z;for(let{x:b}=c;b<=g.x;b++)for(let{y:v}=c;v<=g.y;v++){const S=n.get({x:b,y:v,z:g.z+1});if(S){for(const[,p]of S)if($(p)===z){const x=N(p),I=p.position.z+x.z-1;h=Math.max(h,I)}}}h>g.z&&E({...g,z:h})&&(g.z=h,R=!0)}}return g},f=(c,m)=>{if(c.type==="wall"){if(m.type!=="wall")throw new Error("only walls can join walls");if(c.config.direction!==m.config.direction)throw new Error("walls must have the same direction to join");return c.config.direction==="right"||c.config.direction==="towards"?c:{...c,config:{...c.config,tiles:[...c.config.tiles,...m.config.tiles]}}}return c},y=({x:c,y:m,z:u},{x:g,y:C,z},w)=>{const[E,R]=w,h=$(R),b=g-c+1,v=C-m+1,S=z-u+1;let p=R;if(b+v+S>3){const x={...R.config};if(R.type==="wall")switch(R.config.direction){case"away":case"left":break;case"towards":b!==1&&(x.times={x:b});break;case"right":v!==1&&(x.times={y:v});break}else{const I={...Mo(N(R))};b!==1&&(I.x=b),v!==1&&(I.y=v),S!==1&&(I.z=S),x.times=I}p={...R,config:x}}for(let x=c;x<=g;x++)for(let I=m;I<=C;I++)for(let A=u;A<=z;A++)if(l.get(h)[x-r.x][I-r.y][A-r.z]=!0,x!==c||I!==m||A!==u){const M=n.get({x,y:I,z:A});if(M)o:for(const O of M){const[,T]=O;if($(T)===h){T.position.x===x&&T.position.y===I&&T.position.z===A&&(p=f(p,T)),n.remove({x,y:I,z:A},O);break o}}}return[E,p]};for(const[c,m]of n.iterate())for(const u of m){const[,g]=u;if(g.position.x===c.x&&g.position.y===c.y&&g.position.z===c.z){const C=$(g),z=l.get(C),w=c.x-r.x,E=c.y-r.y,R=c.z-r.z;if(z&&!z[w][E][R]){const h=d(c,g),b=y(c,h,u);n.remove(c,u),n.add(c,b)}}}return[...n.extractUniqueItems(),...i]},go=(o,e)=>Object.fromEntries(Ke(Object.entries(o),e)),Qe=o=>o[Math.floor(Math.random()*o.length)],Uo=(o,e)=>{o.planet=e;for(const t of Object.values(o.items))t.type==="floor"&&t.config.floorType==="standable"&&(t.config.scenery=e),t.type==="wall"&&(t.config.direction==="away"||t.config.direction==="left")&&(t.config.tiles=Array.from(D(e,t.config.tiles.length))),t.type==="pickup"&&t.config.gives==="crown"&&de.includes(e)&&(t.config.planet=e)},ot={x:8,y:8},et=(o,e,t,i,n)=>{const s={};for(const f of n){const y={x:f.x*e.x,y:f.y*e.y},c=Jo(e);for(const[m,u]of Object.entries(c.items)){const g=`${m}_${f.x}_${f.y}`;s[g]={...u,position:{x:u.position.x+y.x,y:u.position.y+y.y,z:u.position.z}}}}const r=new Set;for(const f of n){const y=n.some(m=>m.x===f.x+1&&m.y===f.y),c=n.some(m=>m.x===f.x&&m.y===f.y+1);y&&(r.add(`leftWall_${f.x}_${f.y}`),r.add(`rightWall_${f.x+1}_${f.y}`)),c&&(r.add(`awayWall_${f.x}_${f.y}`),r.add(`towardsWall_${f.x}_${f.y+1}`))}for(const f of r)delete s[f];const l=go(s),a=n.length>1?Object.fromEntries(n.map((f,y)=>[y.toString(),{gridPosition:f,physicalPosition:{from:{x:f.x*e.x,y:f.y*e.y},to:{x:(f.x+1)*e.x-1,y:(f.y+1)*e.y-1}}}])):void 0,d={id:o,planet:"blacktooth",color:t,items:l,...a&&{meta:{subRooms:a}}};return Uo(d,i),d},po=({state:o,scenery:e,maybeColour:t,roomSize:i=ot,gridPositions:n=[{x:0,y:0}]})=>{const r=`room_${X(me({start:0})).find(d=>o.campaignInProgress.rooms[`room_${d}`]===void 0)}`,l=t??{hue:Qe(fe),shade:Math.random()<.66?"basic":"dimmed"},a=et(r,i,l,e,n);return o.campaignInProgress.rooms[r]=a,a},Y=(o,e,t=!1)=>{if(!o.campaignInProgress.rooms[e]){console.warn(`can't change to room ${e} - it doesn't exist`);return}t||o.editingRoomIdHistory.back.push(o.currentlyEditingRoomId),o.currentlyEditingRoomId=e,o.clickableAnnotationHovered=!1,o.hoveredItem=void 0,o.selectedJsonItemIds=[],t||(o.history=fo.history)},tt={addRoom(o,{payload:{roomSize:e,gridPositions:t=[{x:0,y:0}]}}){const{planet:i}=k(o),n=po({state:o,scenery:i,roomSize:e,gridPositions:t});Y(o,n.id)},removeRoom(o){const e=o.campaignInProgress.rooms[o.currentlyEditingRoomId],i=no(W(e.items,"door","teleporter"))?.[1].config.toRoom??no(Le(n=>n!==o.currentlyEditingRoomId,ye(o.campaignInProgress.rooms)));i===void 0||i===Oo||(delete o.campaignInProgress.rooms[o.currentlyEditingRoomId],o.currentlyEditingRoomId=i)}},jo=(o,e)=>{for(let t=1;;t++){const i=t===1?e:`${e}_${t}`;if(!o.items[i])return i}},Vo=(o,e,t)=>{if(e.type==="player"){const{which:n}=e.config;return t?`preview-${n}`:n}const i=e.type==="monster"?e.config.which:e.type;return jo(o,i)},co=(o,e,t,i)=>{const n=k(o),s=Vo(n,e,i),r=Go(o,i),l={type:e.type,config:e.config,position:t};return r[s]=l,[s,l]},Go=(o,e,t=o.currentlyEditingRoomId)=>e?o.previewedEdits:o.campaignInProgress.rooms[t].items;function*Ko(o,e,t){for(const i of ue(o)){const[n,s]=i;if(s===null||s.type!=="wall"||s.config.direction!==e)continue;const{position:r,config:l}=s,a=ge(Lo(l)),d=pe(Eo(l.direction)),f=Eo(l.direction),y=he(t,r);if(y[f]!==0||y[d]<-1||y[d]>=a[d])continue;if(y[d]===0&&a[d]===2){yield[n,null];continue}const c=2+y[d];if(c===1||c===2){const w=L(s,E=>{E.position=P(r,{[d]:c});const R=E.config;switch(R.direction){case"towards":case"right":R.times[d]=a[d]-c;break;default:R.tiles=R.tiles.slice(c)}});yield[n,w];continue}const u=a[d]-y[d];if(u===2||u===1){const w=L(s,E=>{const R=E.config;switch(R.direction){case"towards":case"right":R.times[d]=a[d]-u;break;default:R.tiles=R.tiles.slice(0,-u)}});yield[n,w];continue}const C=L(s,w=>{const E=w.config;switch(E.direction){case"towards":case"right":E.times[d]=y[d];break;default:E.tiles=E.tiles.slice(0,y[d])}});yield[`${n}/beforeDoor`,C];const z=L(s,w=>{w.position={...r,[d]:t[d]+2};const E=w.config;switch(E.direction){case"towards":case"right":E.times[d]=a[d]-y[d]-2;break;default:E.tiles=E.tiles.slice(y[d]+2)}});yield[`${n}/afterDoor`,z],yield[n,null]}}const Zo=(o,e,t,i,n)=>{const s=ro(o,e);if(s===void 0)throw new Error("can't cut hole in walls for a room that does not exist");const r=Go(o,n,e);for(const[l,a]of Ko(s.items,t,i))n?r[l]=a:a===null?delete r[l]:r[l]=a},it=({state:o,fromRoomJson:e,subRoomId:t,direction:i,isPreview:n,autoAddRooms:s})=>{const r=o.campaignInProgress,l=xe({campaign:r,roomId:e.id,subRoomId:t}),a=X(l).find(({gridPosition:d})=>Ie(d,we[i]));if(a)return r.rooms[a.roomId];if(!n)return s?po({state:o,scenery:e.planet}):void 0},nt=o=>W(o.items,"floor").reduce((e,[,t])=>{const i=t.position.y;return Math.min(e,i)},Number.POSITIVE_INFINITY),st=o=>W(o.items,"floor").reduce((e,[,t])=>{const i=t.position.y+t.config.times.y;return Math.max(e,i)},Number.NEGATIVE_INFINITY),rt=o=>W(o.items,"floor").reduce((e,[,t])=>{const i=t.position.x;return Math.min(e,i)},Number.POSITIVE_INFINITY),ct=o=>W(o.items,"floor").reduce((e,[,t])=>{const i=t.position.x+t.config.times.x;return Math.max(e,i)},Number.NEGATIVE_INFINITY),Qo=({state:o,fromRoomJson:e,toRoomJson:t,outgoingDoorEntry:[i,n]})=>{const s=n.config.direction,r=n.position,l=Xo(n.position,"block",e),a=jo(t,"door"),d={x:s==="left"?rt(t):s==="right"?ct(t):r.x,y:s==="away"?nt(t):s==="towards"?st(t):r.y,z:r.z},f=Do(s),y={type:"door",config:{toRoom:e.id,direction:f,meta:l==="*"?void 0:{toSubRoom:l}},position:d};t.items[a]=y,y.config.toDoor=i,n.config.toDoor=a,Zo(o,t.id,f,d,!1)},at=(o,e,t,i,n)=>{const s=k(o),r=t;Zo(o,s.id,r,e,n);const l=i.config.toRoom==="+",a=Xo(e,"block",s),d=it({state:o,fromRoomJson:s,subRoomId:a,direction:r,isPreview:n,autoAddRooms:l}),[f,y]=co(o,{type:"door",config:{...i.config,toRoom:d?d.id:i.config.toRoom,direction:r}},e,n);!n&&d&&Qo({state:o,fromRoomJson:s,toRoomJson:d,outgoingDoorEntry:[f,y]})},ao=(o,e)=>{const t=k(o);t.items=go(t.items,e);const i=o.selectedJsonItemIds.filter(n=>t.items[n]!==void 0);i.length!==o.selectedJsonItemIds.length&&(o.selectedJsonItemIds=i)},Po=o=>{const e=o,t=k(e).items;e.selectedJsonItemIds=e.selectedJsonItemIds.filter(i=>i in t)},lt={setSelectedItemsInRoom(o,{payload:{jsonItemIds:e}}){const t=k(o).items;e.forEach(i=>{if(!t[i])throw new Error(`Item with json item id "${i}" is not in the current room`)}),o.selectedJsonItemIds=e},toggleSelectedItemInRoom(o,{payload:{jsonItemId:e}}){const t=o.selectedJsonItemIds.indexOf(e);t===-1?o.selectedJsonItemIds.push(e):o.selectedJsonItemIds.splice(t,1)},setHoveredItemInRoom(o,e){o.hoveredItem=e.payload},setClickableAnnotationHovered(o,e){o.clickableAnnotationHovered=e.payload}},_=o=>{const e=structuredClone(F(k(o))),{history:t}=o;t.redo=[],t.undo.push(e)},dt={undo(o){const e=o,{campaignInProgress:t,history:{undo:i,redo:n},currentlyEditingRoomId:s}=e;i.length!==0&&(n.push(t.rooms[s]),t.rooms[s]=i.pop(),Po(e))},redo(o){const e=o,{campaignInProgress:t,history:{redo:i,undo:n},currentlyEditingRoomId:s}=e;i.length!==0&&(n.push(t.rooms[s]),t.rooms[s]=i.pop(),Po(e))}},mt={selectCanUndo:o=>o.history.undo.length>0,selectCanRedo:o=>o.history.redo.length>0},ft=o=>o.type==="door",yt=o=>o.type==="monster"&&o.config.which==="cyberman",ut={applyItemTool(o,{payload:{blockPosition:e,pointedAtItemJson:t,preview:i}}){const n=o,{tool:s}=n;if(s.type!=="item")throw new Error("applying item tool reducer while the current tool is not an item tool");switch(i||(_(n),n.previewedEdits={}),n.selectedJsonItemIds=[],!0){case ft(s.item):{if(t.type!=="wall")throw new Error("doors can only be added on walls");at(n,e,t.config.direction,s.item,i);break}case(yt(s.item)&&t.type==="deadlyBlock"&&t.config.style==="toaster"&&t.position.z+1===e.z):{co(n,{...s.item,config:{...s.item.config,activated:"off"}},e,i);break}default:co(n,s.item,e,i)}i||(n.autoCoalesce?ao(n):ao(n,r=>r.type==="wall"))}},gt={setCampaignName(o,{payload:e}){const t=o;t.campaignInProgress.locator.campaignName=e},setCampaignUserId(o,{payload:e}){const t=o;t.campaignInProgress.locator.userId=e},setCampaignPublished(o,{payload:e}){const t=o;t.campaignInProgress.meta===void 0?t.campaignInProgress.meta={published:!1}:t.campaignInProgress.meta.published=e}},pt={changeToRoom(o,{payload:e}){Y(o,e)},roomBack(o){const e=o,{editingRoomIdHistory:t}=e;if(t.back.length===0)return;const i=t.back.pop();t.forward.push(e.currentlyEditingRoomId),Y(e,i,!0)},roomForward(o){const e=o,{editingRoomIdHistory:t}=e;if(t.forward.length===0)return;const i=t.forward.pop();t.back.push(e.currentlyEditingRoomId),Y(e,i,!0)}},ht={changeDragInProgress(o,{payload:e}){const t=o;t.dragInProgress=e}},xt={changeGridResolution(o,{payload:e}){const t=o;t.gridResolution=e},changeWallsFloorsLocked(o,{payload:e}){const t=o;t.wallsFloorsLocked=e}},It=(o,e)=>{const t=o.currentlyEditingRoomId,i=k(o);for(const n of so(o.campaignInProgress.rooms)){V(n).filter(r=>r.type==="door"||r.type==="teleporter").filter(r=>r.config.toRoom===t).forEach(r=>{r.config.toRoom=e});const s=n.meta?.nonContiguousRelationship?.with;s?.room===t&&(s.room=e)}o.campaignInProgress.rooms[e]={...i,id:e},delete o.campaignInProgress.rooms[t],o.currentlyEditingRoomId=e};function*oe(o,e){const t={type:"wall",config:Re(o.config.direction)?o.config.direction==="towards"?{direction:o.config.direction,times:{x:2}}:{direction:o.config.direction,times:{y:2}}:{direction:o.config.direction,tiles:[...D(e.planet,2,o.position[o.config.direction==="away"?"x":"y"])]},position:{...o.position,z:0}};yield[Vo(e,t,!1),t]}const wt=(o,e)=>{const t=o.items[e];if(t.type==="door"){for(const[i,n]of oe(t,o))o.items[i]=n;o.items=go(o.items)}delete o.items[e]},To=(o,e)=>{V(o).filter(t=>t.type==="floor").filter(t=>t.position.z===0).forEach(t=>{t.config={...t.config,floorType:e,scenery:e==="standable"?o.planet:void 0}})},Rt={changeRoomColour(o,{payload:e}){const t=o,i=t.campaignInProgress.rooms[t.currentlyEditingRoomId].color;_(t),Object.assign(i,e)},changeRoomScenery(o,{payload:e}){const t=o,i=k(t);_(t),Uo(i,e)},roomJsonEdited(o,{payload:e}){const t=o;_(t);const{rooms:i}=t.campaignInProgress,n=i[t.currentlyEditingRoomId];i[t.currentlyEditingRoomId]=e;const s=t.selectedJsonItemIds.filter(a=>e.items[a]!==void 0);s.length!==t.selectedJsonItemIds.length&&(t.selectedJsonItemIds=s),e.id!==t.currentlyEditingRoomId&&It(t,e.id),W(e.items,"door").filter(([a,d])=>n.items[a]?.type==="door").filter(a=>{const[,d]=a;return d.config.toRoom!==Oo&&i[d.config.toRoom]!==void 0}).forEach(([a,d])=>{const f=i[d.config.toRoom],y=Do(d.config.direction),c=W(f.items,"door").filter(([,m])=>m.config.direction===y).toArray();switch(c.length){case 0:Qo({state:t,outgoingDoorEntry:[a,d],fromRoomJson:e,toRoomJson:f});break;case 1:{const[[,m]]=c;m.config.toRoom=e.id,m.config.toDoor=a;break}}});const r=n.meta?.nonContiguousRelationship,l=e.meta?.nonContiguousRelationship;if(l!==void 0){const a=i[l.with.room];a.meta={...a.meta,nonContiguousRelationship:{with:{room:e.id},gridOffset:Ee(l.gridOffset,-1)}}}if(r?.with.room!==void 0&&l?.with.room!==r.with.room){const a=i[r.with.room];a.meta?.nonContiguousRelationship?.with.room===t.currentlyEditingRoomId&&delete a.meta.nonContiguousRelationship}},deleteSelected(o){const e=o,t=k(e);_(e),e.selectedJsonItemIds.forEach(i=>{wt(t,i)}),e.selectedJsonItemIds=[]},clearRoom(o){const e=o,t=k(e);_(e);for(const i of qo(t.items)){const n=t.items[i];n.type!=="floor"&&n.type!=="wall"&&n.type!=="door"&&(delete t.items[i],e.selectedJsonItemIds=e.selectedJsonItemIds.filter(s=>s!==i))}},setRoomAboveOrBelow(o,{payload:e}){const t=o,i=e.direction==="above"?"roomAbove":"roomBelow",n=i==="roomAbove"?"roomBelow":"roomAbove",s=k(t),r=e.createNew?po({state:t,scenery:s.planet,maybeColour:s.color}).id:e.roomId,l=s[i]&&ro(t,s[i]);l?.[n]===t.currentlyEditingRoomId&&(l[n]=void 0),s[i]=r;const a=r&&ro(t,r);a!==void 0&&(a[n]=s.id),a?To(i==="roomBelow"?s:a,"none"):To(i==="roomBelow"?s:l,"standable")}},Et=(o,e)=>{const t=Wo(e);for(const[i,n]of t)n===null?delete o.items[i]:o.items[i]=n},vt={setAutoCoalesce(o,e){o.autoCoalesce=e.payload},resetPreviewedEdits(o){o.previewedEdits={}},commitCurrentPreviewedEdits(o){_(o),Et(k(o),o.previewedEdits),o.autoCoalesce&&ao(o),o.previewedEdits={}}},bt=(o,...e)=>({x:o(...e.map(t=>t.x)),y:o(...e.map(t=>t.y)),z:o(...e.map(t=>t.z))}),Fo=(o,e,t)=>{const i=t-o.length;i>0?o.push(...D(e,i,o.length)):i<0&&o.splice(t)};function ee(o,e){const t=Lo(o.config),i=P(e.position,e.config.times);switch(o.config.direction){case"towards":if(o.position.y===e.position.y&&o.position.x>=e.position.x&&o.position.x<i.x)return{tangentAxis:"x",normalAxis:"y",edgePosition:o.position.y,wallStart:o.position.x,wallLength:t.x??1,isOnFloorEdge:!0,wallFullySpansFloor:o.position.x===e.position.x&&t.x===e.config.times.x,wallTouchesFloorEnd:o.position.x+(t.x??1)===i.x};break;case"right":if(o.position.x===e.position.x&&o.position.y>=e.position.y&&o.position.y<i.y)return{tangentAxis:"y",normalAxis:"x",edgePosition:o.position.x,wallStart:o.position.y,wallLength:t.y??1,isOnFloorEdge:!0,wallFullySpansFloor:o.position.y===e.position.y&&t.y===e.config.times.y,wallTouchesFloorEnd:o.position.y+(t.y??1)===i.y};break;case"away":if(o.position.y===e.position.y+e.config.times.y&&o.position.x>=e.position.x&&o.position.x<i.x)return{tangentAxis:"x",normalAxis:"y",edgePosition:o.position.y,wallStart:o.position.x,wallLength:t.x??1,isOnFloorEdge:!0,wallFullySpansFloor:o.position.x===e.position.x&&t.x===e.config.times.x,wallTouchesFloorEnd:o.position.x+(t.x??1)===i.x};break;case"left":if(o.position.x===e.position.x+e.config.times.x&&o.position.y>=e.position.y&&o.position.y<i.y)return{tangentAxis:"y",normalAxis:"x",edgePosition:o.position.x,wallStart:o.position.y,wallLength:t.y??1,isOnFloorEdge:!0,wallFullySpansFloor:o.position.y===e.position.y&&t.y===e.config.times.y,wallTouchesFloorEnd:o.position.y+(t.y??1)===i.y};break}return null}function*te(o,e,t,i,n){const s=P(e.position,i),r=e.config.times,l=n?P(r,n):e.config.times,a=P(e.position,r),d=P(s,l);for(const[f,y]of X(o)){if(y.type==="wall"&&y.position.z!==e.position.z)continue;if(y.type==="door"){const g=y.config;let C=!1,z={...F(y.position)};switch(g.direction){case"towards":y.position.y===e.position.y&&y.position.x>=e.position.x&&y.position.x<e.position.x+r.x&&(C=!0,z=P(y.position,i));break;case"right":y.position.x===e.position.x&&y.position.y>=e.position.y&&y.position.y<e.position.y+r.y&&(C=!0,z=P(y.position,i));break;case"away":y.position.y===e.position.y+r.y&&y.position.x>=e.position.x&&y.position.x<e.position.x+r.x&&(C=!0,z=P(y.position,{x:i.x,y:i.y+(n?.y??0),z:i.z}));break;case"left":y.position.x===e.position.x+r.x&&y.position.y>=e.position.y&&y.position.y<e.position.y+r.y&&(C=!0,z=P(y.position,{x:i.x+(n?.x??0),y:i.y,z:i.z}));break}if(C){const w=structuredClone(F(y));w.position=z,yield[f,w]}continue}const c=y,m=ee(c,e);if(!m||!m.isOnFloorEdge)continue;const u=structuredClone(F(c));switch(c.config.direction){case"towards":case"right":u.position=P(c.position,i);break;case"away":{const g=s.y+l.y;u.position={...c.position,x:c.position.x+i.x,y:g};break}case"left":{const g=s.x+l.x;u.position={...c.position,x:g,y:c.position.y+i.y};break}}if(m.wallFullySpansFloor){const g=l[m.tangentAxis];c.config.direction==="away"||c.config.direction==="left"?Fo(u.config.tiles,t,g):u.config.times={[m.tangentAxis]:g},yield[f,u]}else{const g=e.position[m.tangentAxis],C=a[m.tangentAxis],z=s[m.tangentAxis],w=d[m.tangentAxis],E=u.position[m.tangentAxis];if(E>=w){yield[f,null];continue}const R=Math.max(m.wallStart,g),b=Math.min(m.wallStart+m.wallLength,C)-R;let v;if(c.config.direction==="away"||c.config.direction==="left"){const I=e.position[m.normalAxis]+r[m.normalAxis],A=s[m.normalAxis]+l[m.normalAxis];v=I!==A}else v=e.position[m.normalAxis]!==s[m.normalAxis];const S=Math.max(E,z);let p;m.wallTouchesFloorEnd&&!v?p=w:p=Math.min(E+b,w);const x=p-S;x<=0?yield[f,null]:(c.config.direction==="away"||c.config.direction==="left"?Fo(u.config.tiles,t,x):u.config.times={[m.tangentAxis]:x},yield[f,u])}}}function*zt(o,e,t,i){for(const[n,s]of W(o.items,"floor")){const r=ee(e,s);if(!r)continue;const l={x:0,y:0,z:0},a={x:0,y:0,z:0},d=t[r.normalAxis],f=t[r.tangentAxis],y=i?i[r.tangentAxis]:0;if(d!==0&&(e.config.direction==="towards"||e.config.direction==="right"?(l[r.normalAxis]=d,a[r.normalAxis]=-d):a[r.normalAxis]=d),f!==0&&(r.wallStart===s.position[r.tangentAxis]?(l[r.tangentAxis]=f,a[r.tangentAxis]=-f):r.wallTouchesFloorEnd&&(a[r.tangentAxis]=f)),y!==0&&r.wallTouchesFloorEnd&&(a[r.tangentAxis]=y),l.x!==0||l.y!==0||a.x!==0||a.y!==0){const c=P(s.config.times,a),m={...s,position:P(s.position,l),config:{...s.config,times:{x:c.x,y:c.y}}};yield[n,m]}yield*te(W(o.items,"wall","door"),s,o.planet,l,a)}}const Ct={moveOrResizeItemAsPreview(o,{payload:{jsonItemIds:e,timesDelta:t,positionDelta:i}}){const n=o,s=k(n);for(const r of e){const l=Yo(n,r);if(l===void 0)throw new Error(`no json item found for some of the ids in resize ${r}`);if(l.type==="wall"){for(const[d,f]of zt(s,l,i,t))n.previewedEdits[d]=f;continue}if(l.type==="floor")for(const[d,f]of te(W(s.items,"wall","door"),l,s.planet,i,t))n.previewedEdits[d]=f;if(l.type==="door"){console.log("before healing, room items are",F(s.items));for(const[d,f]of oe(l,F(s)))console.log("healing",`"${d}"`,f),n.previewedEdits[d]=f}const a={...l,position:P(l.position,i),config:{...l.config}};if(n.previewedEdits[r]=a,kt(a,t),l.type==="door"){console.log("before cutting room plus previews is",{...F(s.items),...F(n.previewedEdits)});for(const[d,f]of Ko({...F(s.items),...F(n.previewedEdits)},a.config.direction,a.position))console.log("cutting",`"${d}"`,f),n.previewedEdits[d]=f}}n.dragInProgress=!0}},kt=(o,e)=>{if(e!==void 0){const t=N(o),i=uo(o),n=ve(e,i);if(_o(n)>0){const s=Mo(bt((r,l)=>Math.max(1,r+l),t,n));s===void 0?delete o.config.times:o.config.times=s}}},St={loadCampaign(o,{payload:{campaign:e}}){const t=o;t.remoteCampaign=e,t.campaignInProgress=e,t.hoveredItem=void 0,t.selectedJsonItemIds=[],t.clickableAnnotationHovered=!1,t.dragInProgress=!1,t.history=fo.history;const i=X(so(e.rooms)).find(n=>V(n).some(s=>s.type==="player"&&s.config.which==="head"))?.id??X(so(e.rooms)).find(n=>V(n).some(s=>s.type==="player"&&s.config.which==="heels"))?.id??no(qo(e.rooms));if(i===void 0)throw new Error("could not find any rooms in this campaign");t.currentlyEditingRoomId=i},setRemoteCampaign(o,{payload:{campaign:e}}){const t=o;t.remoteCampaign=e}},ie=be({name:"levelEditor",initialState:fo,reducers:{setTool(o,{payload:e}){const t=o;e.type==="item"&&(t.selectedJsonItemIds=[],t.hoveredItem=void 0),t.tool=e},injected(){},...xt,...dt,...ut,...ht,...lt,...Rt,...Ct,...vt,...St,...tt,...pt,...gt},selectors:{selectCurrentCampaignInProgress:o=>o.campaignInProgress,selectCurrentEditingRoomJson:k,selectItem:Yo,selectCurrentEditingRoomColour:o=>k(o).color,selectCurrentEditingRoomScenery:o=>k(o).planet,selectTool:o=>o.tool,selectSelectedJsonItemIds:o=>o.selectedJsonItemIds,selectHoveredItem:o=>o.hoveredItem,selectItemIsSelected:Ye,...mt}}),{addRoom:Bt,applyItemTool:Jt,changeDragInProgress:Yt,changeGridResolution:Ut,changeRoomColour:jt,changeRoomScenery:Vt,changeToRoom:Gt,changeWallsFloorsLocked:Kt,clearRoom:Zt,commitCurrentPreviewedEdits:Qt,deleteSelected:oi,injected:ei,loadCampaign:ti,moveOrResizeItemAsPreview:ii,redo:ni,removeRoom:si,resetPreviewedEdits:ri,roomBack:ci,roomForward:ai,roomJsonEdited:li,setAutoCoalesce:di,setCampaignName:mi,setCampaignPublished:fi,setCampaignUserId:yi,setClickableAnnotationHovered:ui,setHoveredItemInRoom:gi,setRemoteCampaign:pi,setRoomAboveOrBelow:hi,setSelectedItemsInRoom:xi,setTool:Ii,toggleSelectedItemInRoom:wi,undo:Ri}=ie.actions,{selectCanRedo:Ei,selectCanUndo:vi,selectCurrentCampaignInProgress:bi,selectCurrentEditingRoomColour:zi,selectCurrentEditingRoomJson:Ci,selectCurrentEditingRoomScenery:ki,selectHoveredItem:Si,selectItem:Ai,selectItemIsSelected:Pi,selectSelectedJsonItemIds:Ti,selectTool:Fi}=ie.selectors;ze.withTypes();const At={Container:"ðŸ“¦",Sprite:"ðŸ–¼ï¸",UniqueTextureSprite:"âœ¨",Graphics:"ðŸŽ¨",Text:"ðŸ“",AnimatedSprite:"ðŸŽ¬",TilingSprite:"ðŸ”²",BitmapText:"ðŸ”¤",Mesh:"ðŸ”º",NineSliceSprite:"ðŸ”³"},Pt=o=>{const e=o.constructor.name;return e.startsWith("_")?e.slice(1):e},Tt=o=>At[o]||"ðŸ“Œ",Ft=o=>{const e=[];try{(o.x!==0||o.y!==0)&&e.push(`@(x=${o.x}, y=${o.y})`)}catch{e.push("@(ERROR)")}if(o.children.length>0&&e.push(`children: ${o.children.length}`),o.visible||e.push("hidden"),o.alpha<1&&e.push(`alpha: ${o.alpha.toFixed(2)}`),o.mask&&e.push("ðŸ˜· masked"),o instanceof Ce)if(o.texture===null||o.texture===void 0)e.push("texture: NO TEXTURE");else{const t=o.texture.label||"(anon texture)";e.push(`texture: "${t}"`)}return e},Wt=(o,e)=>o.label&&o.label!==e?` "${o.label}"`:"",$t=(o,e="",t=!0,i=!0,n=[])=>{const s=[];i&&s.push("");const r=Pt(o);let l=Tt(r);n.forEach((c,m)=>{c.mask===o&&(m===0?l+="ðŸ˜·":l+=`ðŸ˜·^${m+1}`)});const a=Wt(o,r),d=Ft(o),f=i?"":e+(t?"â””â”€â”€ ":"â”œâ”€â”€ ");if(s.push(`${f}${l} ${r}${a}`),d.length>0){const c=o.children.length>0,m=i?c?"â”‚  ":"   ":e+(t?"    ":"â”‚   ")+(c?"â”‚  ":"   ");d.forEach(u=>{s.push(`${m}â†’ ${u}`)})}const y=i?"":e+(t?"    ":"â”‚   ");return o.children.forEach((c,m)=>{const u=m===o.children.length-1;s.push($t(c,y,u,!1,[o,...n]))}),s.join(`
`)+(i?`
`:"")};export{Lt as a,Ht as b,Qe as c,Xt as d,Dt as e,Gt as f,Bo as g,Si as h,Ti as i,Fi as j,$t as p,qt as r,ui as s};
