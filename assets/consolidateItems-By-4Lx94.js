import{c as I,u as M,l as T,g as W,e as L}from"./App-Dv3cIET-.js";function G(o){var i="";return x(o),i;function x(r){if(r===null||typeof r!="object"||r.toJSON!=null)i+=JSON.stringify(r);else if(Array.isArray(r)){i+="[";var y=!1;r.forEach(function(d){y&&(i+=","),y=!0,d===void 0&&(d=null),x(d)}),i+="]"}else{i+="{";var a=Object.keys(r).filter(function(d){return r[d]!==void 0}).sort();a.forEach(function(d,w){return s(r,d,w)}),i+="}"}}function s(r,y,a){a>0&&(i+=","),i+=JSON.stringify(y),i+=":",x(r[y])}}const N=o=>T(J(o))>0,J=o=>{switch(o.type){case"deadlyBlock":return M;case"conveyor":if(o.config.disappearing)return I;switch(o.config.direction){case"left":case"right":return{x:1,y:0,z:0};case"away":case"towards":return{x:0,y:1,z:0};default:throw o.config.direction,new Error}case"hushPuppy":return M;case"teleporter":return{x:1,y:1,z:0};case"floor":case"spikes":return{x:1,y:1,z:0};case"block":return o.config.disappearing?I:M;case"barrier":if(o.config.disappearing)return I;switch(o.config.axis){case"x":return{x:1,y:0,z:1};case"y":return{x:0,y:1,z:1};default:throw o.config.axis,new Error}case"wall":switch(o.config.direction){case"left":case"right":return{x:0,y:1,z:1};case"away":case"towards":return{x:1,y:0,z:1};default:throw o.config,new Error}default:return I}},p=o=>o.type==="wall"?`wall/${o.config.direction}`:o.type==="teleporter"?G({type:o.type,config:L(o.config,"toPosition")}):G({type:o.type,config:o.config}),P=o=>N(o[1]),V=o=>{const i=[];let x=0,s=0,r=0;for(const[,a]of o){const{x:d,y:w,z:A}=a.position,e=W(a),n=e.x,t=e.y,l=e.z;x=Math.max(x,d+n-1),s=Math.max(s,w+t-1),r=Math.max(r,A+l-1)}const y=Array.from({length:x+1},()=>Array.from({length:s+1},()=>Array.from({length:r+1},()=>new Set)));for(const a of o)if(!P(a))i.push(a);else{const[,d]=a,{x:w,y:A,z:e}=d.position,n=W(d),t=n.x,l=n.y,c=n.z;for(let g=0;g<t;g++)for(let u=0;u<l;u++)for(let f=0;f<c;f++){const m=w+g,h=A+u,z=e+f;m<y.length&&h<y[m].length&&z<y[m][h].length&&y[m][h][z].add(a)}}return{consolidatableGrid:y,nonConsolidatable:i}},H=o=>{const i=[],x=new Set;for(const s of o)for(const r of s)for(const y of r)for(const a of y){const[d]=a;x.has(d)||(x.add(d),i.push(a))}return i},X=o=>{const{consolidatableGrid:i,nonConsolidatable:x}=V(o),s={x:i.length,y:i[0].length,z:i[0][0].length},r=new Map,y=new Map;for(let e=0;e<s.x;e++)for(let n=0;n<s.y;n++)for(let t=0;t<s.z;t++)for(const[,l]of i[e][n][t]){const c=p(l);y.has(c)||y.set(c,l)}for(const[e]of y)r.set(e,Array.from({length:s.x},()=>Array.from({length:s.y},()=>Array(s.z).fill(!1))));const a=({x:e,y:n,z:t},l)=>{const c=p(l);return!r.get(c)[e][n][t]&&Array.from(i[e][n][t]).some(([,g])=>p(g)===p(l))},d=(e,n)=>{const t={...e},l=J(n);if(l.x>0)for(;t.x+1<s.x&&a({...t,x:t.x+1},n);)t.x++;if(l.y>0)for(let c=e.x;c<=t.x;c++)for(;t.y+1<s.y&&Array.from({length:t.x-e.x+1}).every((g,u)=>a({x:e.x+u,y:t.y+1,z:e.z},n));)t.y++;if(l.z>0)for(let c=e.x;c<=t.x;c++)for(let g=e.y;g<=t.y;g++)for(;t.z+1<s.z&&Array.from({length:t.x-e.x+1}).every((u,f)=>Array.from({length:t.y-e.y+1}).every((m,h)=>a({x:e.x+f,y:e.y+h,z:t.z+1},n)));)t.z++;return t},w=(e,n)=>{if(e.type==="wall"){if(n.type!=="wall")throw new Error("only walls can join walls");if(e.config.direction!==n.config.direction)throw new Error("walls must have the same direction to join");if(e.config.direction==="right"||e.config.direction==="towards")return;e.config.tiles=[...e.config.tiles,...n.config.tiles]}},A=({x:e,y:n,z:t},{x:l,y:c,z:g},u)=>{const[,f]=u,m=p(f),h=l-e+1,z=c-n+1,C=g-t+1;if(h+z+C>3)if(f.type==="wall")switch(f.config.direction){case"away":case"left":break;case"towards":h!==1&&(f.config.times={x:h});break;case"right":z!==1&&(f.config.times={y:z});break}else h!==1&&(f.config.times={...f.config.times,x:h}),z!==1&&(f.config.times={...f.config.times,y:z}),C!==1&&(f.config.times={...f.config.times,z:C});for(let k=e;k<=l;k++)for(let E=n;E<=c;E++)for(let b=t;b<=g;b++)if(r.get(m)[k][E][b]=!0,k!==e||E!==n||b!==t){const O=i[k][E][b];e:for(const S of O){const[,v]=S;if(p(v)===m){v.position.x===k&&v.position.y===E&&v.position.z===b&&w(f,v),O.delete(S);break e}}}};for(let e=0;e<s.x;e++)for(let n=0;n<s.y;n++)for(let t=0;t<s.z;t++)for(const l of i[e][n][t]){const[,c]=l;if(c.position.x===e&&c.position.y===n&&c.position.z===t){const g=p(c),u=r.get(g);if(u&&!u[e][n][t]){const f=d({x:e,y:n,z:t},c);A({x:e,y:n,z:t},f,l)}}}return[...H(i),...x]},B=o=>Object.fromEntries(X(Object.entries(o)));export{B as c,J as g};
