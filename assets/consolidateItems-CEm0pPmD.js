import{b as I,u as C,l as L,c as N,e as T,f as P}from"./App-BYUSQGEa.js";function W(o){var i="";return g(o),i;function g(r){if(r===null||typeof r!="object"||r.toJSON!=null)i+=JSON.stringify(r);else if(Array.isArray(r)){i+="[";var y=!1;r.forEach(function(d){y&&(i+=","),y=!0,d===void 0&&(d=null),g(d)}),i+="]"}else{i+="{";var a=Object.keys(r).filter(function(d){return r[d]!==void 0}).sort();a.forEach(function(d,w){return c(r,d,w)}),i+="}"}}function c(r,y,a){a>0&&(i+=","),i+=JSON.stringify(y),i+=":",g(r[y])}}const V=o=>L(J(o))>0,J=o=>{switch(o.type){case"deadlyBlock":return C;case"conveyor":if(o.config.disappearing)return I;switch(o.config.direction){case"left":case"right":return{x:1,y:0,z:0};case"away":case"towards":return{x:0,y:1,z:0};default:throw o.config.direction,new Error}case"hushPuppy":return C;case"teleporter":return{x:1,y:1,z:0};case"floor":case"spikes":return{x:1,y:1,z:0};case"block":return o.config.disappearing?I:C;case"barrier":if(o.config.disappearing)return I;switch(o.config.axis){case"x":return{x:1,y:0,z:1};case"y":return{x:0,y:1,z:1};default:throw o.config.axis,new Error}case"wall":switch(o.config.direction){case"left":case"right":return{x:0,y:1,z:1};case"away":case"towards":return{x:1,y:0,z:1};default:throw o.config,new Error}default:return I}},G=o=>{const i=g=>g.config.times!==void 0;return o.type==="wall"?T(P(o.config)):i(o)?T(o.config.times):C},p=o=>o.type==="wall"?`wall/${o.config.direction}`:o.type==="teleporter"?W({type:o.type,config:N(o.config,"toPosition")}):W({type:o.type,config:o.config}),X=o=>V(o[1]),H=o=>{const i=[];let g=0,c=0,r=0;for(const[,a]of o){const{x:d,y:w,z:A}=a.position,e=G(a),n=e.x,t=e.y,l=e.z;g=Math.max(g,d+n-1),c=Math.max(c,w+t-1),r=Math.max(r,A+l-1)}const y=Array.from({length:g+1},()=>Array.from({length:c+1},()=>Array.from({length:r+1},()=>new Set)));for(const a of o)if(!X(a))i.push(a);else{const[,d]=a,{x:w,y:A,z:e}=d.position,n=G(d),t=n.x,l=n.y,s=n.z;for(let x=0;x<t;x++)for(let u=0;u<l;u++)for(let f=0;f<s;f++){const m=w+x,h=A+u,z=e+f;m<y.length&&h<y[m].length&&z<y[m][h].length&&y[m][h][z].add(a)}}return{consolidatableGrid:y,nonConsolidatable:i}},_=o=>{const i=[],g=new Set;for(const c of o)for(const r of c)for(const y of r)for(const a of y){const[d]=a;g.has(d)||(g.add(d),i.push(a))}return i},q=o=>{const{consolidatableGrid:i,nonConsolidatable:g}=H(o),c={x:i.length,y:i[0].length,z:i[0][0].length},r=new Map,y=new Map;for(let e=0;e<c.x;e++)for(let n=0;n<c.y;n++)for(let t=0;t<c.z;t++)for(const[,l]of i[e][n][t]){const s=p(l);y.has(s)||y.set(s,l)}for(const[e]of y)r.set(e,Array.from({length:c.x},()=>Array.from({length:c.y},()=>Array(c.z).fill(!1))));const a=({x:e,y:n,z:t},l)=>{const s=p(l);return!r.get(s)[e][n][t]&&Array.from(i[e][n][t]).some(([,x])=>p(x)===p(l))},d=(e,n)=>{const t={...e},l=J(n);if(l.x>0)for(;t.x+1<c.x&&a({...t,x:t.x+1},n);)t.x++;if(l.y>0)for(let s=e.x;s<=t.x;s++)for(;t.y+1<c.y&&Array.from({length:t.x-e.x+1}).every((x,u)=>a({x:e.x+u,y:t.y+1,z:e.z},n));)t.y++;if(l.z>0)for(let s=e.x;s<=t.x;s++)for(let x=e.y;x<=t.y;x++)for(;t.z+1<c.z&&Array.from({length:t.x-e.x+1}).every((u,f)=>Array.from({length:t.y-e.y+1}).every((m,h)=>a({x:e.x+f,y:e.y+h,z:t.z+1},n)));)t.z++;return t},w=(e,n)=>{if(e.type==="wall"){if(n.type!=="wall")throw new Error("only walls can join walls");if(e.config.direction!==n.config.direction)throw new Error("walls must have the same direction to join");if(e.config.direction==="right"||e.config.direction==="towards")return;e.config.tiles=[...e.config.tiles,...n.config.tiles]}},A=({x:e,y:n,z:t},{x:l,y:s,z:x},u)=>{const[,f]=u,m=p(f),h=l-e+1,z=s-n+1,M=x-t+1;if(h+z+M>3)if(f.type==="wall")switch(f.config.direction){case"away":case"left":break;case"towards":h!==1&&(f.config.times={x:h});break;case"right":z!==1&&(f.config.times={y:z});break}else h!==1&&(f.config.times={...f.config.times,x:h}),z!==1&&(f.config.times={...f.config.times,y:z}),M!==1&&(f.config.times={...f.config.times,z:M});for(let b=e;b<=l;b++)for(let k=n;k<=s;k++)for(let E=t;E<=x;E++)if(r.get(m)[b][k][E]=!0,b!==e||k!==n||E!==t){const O=i[b][k][E];e:for(const S of O){const[,v]=S;if(p(v)===m){v.position.x===b&&v.position.y===k&&v.position.z===E&&w(f,v),O.delete(S);break e}}}};for(let e=0;e<c.x;e++)for(let n=0;n<c.y;n++)for(let t=0;t<c.z;t++)for(const l of i[e][n][t]){const[,s]=l;if(s.position.x===e&&s.position.y===n&&s.position.z===t){const x=p(s),u=r.get(x);if(u&&!u[e][n][t]){const f=d({x:e,y:n,z:t},s);A({x:e,y:n,z:t},f,l)}}}return[..._(i),...g]},K=o=>Object.fromEntries(q(Object.entries(o)));export{K as c};
