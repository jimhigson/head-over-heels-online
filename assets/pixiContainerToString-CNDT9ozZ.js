import{ai as K,aj as ie,ak as ne,al as se,am as Z,an as L,ao as Wo,ap as $o,aq as U,ar as re,as as Q,at as ho,au as xo,av as oo,aw as Io,ax as ce,ay as ae,az as No,aA as N,aB as j,aC as wo,aD as Ro,aE as _o,aF as le,aG as X,aH as de,aI as me,aJ as no,aK as W,aL as fe,aM as Mo,e as ye,aN as ue,aO as Oo,aP as pe,aQ as Eo,aR as ge,aS as S,aT as Lo,aU as Xo,aV as he,aW as xe,aX as Ie,aY as F,aZ as so,a_ as V,a$ as we,b0 as Do,b1 as Re,b2 as Ee,b3 as be,b4 as ve,a1 as ze}from"./App-CJ_JOKAG.js";import{g as qo}from"./spritesheetPalette-hcmYXtMp.js";import{g as lo}from"./index-DnJ6meqD.js";var q={},bo;function Ce(){if(bo)return q;bo=1;const{iterableCurry:o}=K(),{__toArray:e}=ie();function*t(n,s){const r=Array.isArray(n)?n:e(n);if(r.length)for(;s--;)yield*r}q.__cycleTimes=t;const i=o(t);return q.cycleTimes=i,q}var H={},vo;function ke(){if(vo)return H;vo=1;const{iterableCurry:o}=K();function*e(i,n){let s=0;for(const r of i)n(r,s++)&&(yield r)}H.__filter=e;const t=o(e);return H.filter=t,H}var B={},zo;function Ae(){if(zo)return B;zo=1;const{iterableCurry:o}=K(),{__cycleTimes:e}=Ce();function t(n){return e(n,1/0)}B.__cycle=t;const i=o(t);return B.cycle=i,B}var J={},Co;function Pe(){if(Co)return J;Co=1;const{iterableCurry:o}=K();function*e(i,n){let s=0;for(const r of i)s++>=n&&(yield r)}J.__drop=e;const t=o(e);return J.drop=t,J}var eo,ko;function Se(){return ko||(ko=1,eo=Ae().cycle),eo}var Te=Se();const Fe=lo(Te);var to,Ao;function We(){return Ao||(Ao=1,to=Pe().drop),to}var $e=We();const Ne=lo($e);var io,Po;function _e(){return Po||(Po=1,io=ke().filter),io}var Me=_e();const Oe=lo(Me),Ot=(o,e)=>o==="infinite"||e==="infinite"?"infinite":o+e,Lt=o=>o==="infinite"?Number.POSITIVE_INFINITY:o,Ho=(o,e=!1)=>qo(e)[o],Xt=(o,e=!1,t=!1)=>Ho(`swop_${o}${e?"Dim":""}`,t),Dt=(o,e=!1,t="light-dark")=>{const i=qo(e),n=t==="light-mid"||t==="mid-dark",s=`swop_${o}`;if(n){const r=`${s}Mid`;if(r in i)return t==="light-mid"?{replaceLight:i[s],replaceDark:i[r]}:{replaceLight:i[r],replaceDark:i[`${s}Dim`]}}return{replaceLight:i[s],replaceDark:i[`${s}Dim`]}},qt=(o,e=!1)=>o?Ho("white",e):ne.white,Le={jail:["bars"],blacktooth:["plain","plain","armour","shield","shield","armour"],bookworld:["book","book","cowboy"],egyptus:["hieroglyphics","hieroglyphics","hieroglyphics","sarcophagus","sarcophagus"],market:["passage","more-fruits","fruits","more-fruits","fruits"],moonbase:["coil","window1","window2","window3"],penitentiary:["loop","loop","skeleton"],safari:["wall","shield","wall","window","window","wall","shield"]},D=(o,e,t=0)=>{const i=Le[o],n=i.length,s=(t%n+n)%n,r=Fe(i);return Ne(s,se(e+s,r))},Xe=o=>({awayWall:{type:"wall",config:{direction:"away",tiles:Array.from(D("blacktooth",o.x))},position:{x:0,y:o.y,z:0}},leftWall:{type:"wall",config:{direction:"left",tiles:Array.from(D("blacktooth",o.y))},position:{x:o.x,y:0,z:0}},towardsWall:{type:"wall",config:{direction:"towards",times:{x:o.x}},position:{x:0,y:0,z:0}},rightWall:{type:"wall",config:{direction:"right",times:{y:o.y}},position:{x:0,y:0,z:0}}}),Bo=o=>({planet:"blacktooth",color:{hue:"cyan",shade:"basic"},items:{floor:{type:"floor",config:{floorType:"standable",scenery:"blacktooth",times:o},position:{x:0,y:0,z:0}},...Xe(o)}}),mo="room_0",De={id:mo,...Bo({x:8,y:8})},qe={meta:{published:!1},locator:{campaignName:void 0,userId:"anon",version:0},rooms:{[mo]:De}},fo={campaignInProgress:qe,remoteCampaign:void 0,currentlyEditingRoomId:mo,editingRoomIdHistory:{back:[],forward:[]},previewedEdits:{},tool:{type:"pointer"},hoveredItem:void 0,clickableAnnotationHovered:!1,selectedJsonItemIds:[],gridResolution:1,autoCoalesce:!0,wallsFloorsLocked:!0,dragInProgress:!1,history:{undo:[],redo:[]}},He=Z([o=>k(o.levelEditor),o=>o.levelEditor.previewedEdits],(o,e)=>L(o,t=>{const i=Wo(e);for(const[n,s]of i)s===null?delete t.items[n]:t.items[n]=s})),Be=Z([o=>k(o.levelEditor)],o=>$o({roomJson:o,roomPickupsCollected:U,scrollsRead:U,isNewGame:!0}));Z([He],o=>$o({roomJson:o,roomPickupsCollected:U,scrollsRead:U,isNewGame:!0}));Z([Be],o=>{const{floors:{edgeLeftX:e,edgeRightX:t,bottomEdgeY:i},allItems:{topEdgeY:n}}=re(o);return{l:e,r:t,w:t-e,b:i,t:n,h:i-n}});const k=o=>o.campaignInProgress.rooms[o.currentlyEditingRoomId],ro=(o,e)=>o.campaignInProgress.rooms[e],Jo=(o,e,t)=>o.campaignInProgress.rooms[t??o.currentlyEditingRoomId]?.items[e],Je=(o,e)=>o.selectedJsonItemIds.includes(e),yo=o=>No(uo(o))>0,uo=o=>{switch(o.type){case"deadlyBlock":return oo;case"conveyor":if(o.config.disappearing)return Q;switch(o.config.direction){case"left":case"right":return ae;case"away":case"towards":return ce;default:throw o.config.direction,new Error}case"hushPuppy":return oo;case"teleporter":return Io;case"floor":case"spikes":return Io;case"block":return oo;case"barrier":if(o.config.disappearing)return Q;switch(o.config.axis){case"x":return ho;case"y":return xo;default:throw o.config.axis,new Error}case"wall":switch(o.config.direction){case"left":case"right":return xo;case"away":case"towards":return ho;default:throw o.config,new Error}default:return Q}};class G{#t;#e;#o;constructor(e,t){this.#e={x:-e.x,y:-e.y,z:-e.z},this.#o={x:t.x-e.x+1,y:t.y-e.y+1,z:t.z-e.z+1},this.#t=Array.from({length:this.#o.x},()=>Array.from({length:this.#o.y},()=>Array.from({length:this.#o.z},()=>new Set)))}static fromItems(e){let t=1/0,i=1/0,n=1/0,s=-1/0,r=-1/0,l=-1/0;const a=[...e];for(const[,f]of a){const{x:y,y:c,z:m}=f.position,u=N(f);t=Math.min(t,y),i=Math.min(i,c),n=Math.min(n,m),s=Math.max(s,y+u.x-1),r=Math.max(r,c+u.y-1),l=Math.max(l,m+u.z-1)}if(a.length===0)return new G({x:0,y:0,z:0},{x:0,y:0,z:0});const d=new G({x:t,y:i,z:n},{x:s,y:r,z:l});for(const f of a){const[,y]=f,{x:c,y:m,z:u}=y.position,p=N(y);for(let C=0;C<p.x;C++)for(let z=0;z<p.y;z++)for(let w=0;w<p.z;w++)d.add({x:c+C,y:m+z,z:u+w},f)}return d}get(e){const t=e.x+this.#e.x,i=e.y+this.#e.y,n=e.z+this.#e.z;if(this.#i(t,i,n))return this.#t[t][i][n]}set(e,t){const i=e.x+this.#e.x,n=e.y+this.#e.y,s=e.z+this.#e.z;this.#i(i,n,s)&&(this.#t[i][n][s]=t)}add(e,t){const i=this.get(e);i&&i.add(t)}remove(e,t){const i=this.get(e);i&&i.delete(t)}get size(){return{...this.#o}}get minBounds(){return{x:-this.#e.x,y:-this.#e.y,z:-this.#e.z}}get maxBounds(){const e=this.minBounds;return{x:e.x+this.#o.x-1,y:e.y+this.#o.y-1,z:e.z+this.#o.z-1}}*iterate(){const{minBounds:e}=this;for(let t=0;t<this.#o.x;t++)for(let i=0;i<this.#o.y;i++)for(let n=0;n<this.#o.z;n++)yield[{x:t+e.x,y:i+e.y,z:n+e.z},this.#t[t][i][n]]}extractUniqueItems(){const e=new Set,t=[];for(const[,i]of this.iterate())for(const n of i)e.has(n)||(e.add(n),t.push(n));return t}#i(e,t,i){return e>=0&&e<this.#o.x&&t>=0&&t<this.#o.y&&i>=0&&i<this.#o.z}}const $=o=>o.type==="wall"?`wall/${o.config.direction}`:o.type==="teleporter"?wo({type:o.type,config:Ro(o.config,"toPosition","times")}):wo({type:o.type,config:Ro(o.config,"times")}),Ye=o=>yo(o[1]),Ue=o=>({x:Math.floor(o.x%1*j.x),y:Math.floor(o.y%1*j.y)}),je=(o,e)=>`${o},${e}`,Ve=(o,e)=>{let t=o,i=t.length;for(;;){const n=[...Ke(t,e)];if(n.length===i)return n;i=n.length,t=n}},Ge=(o,e=()=>!0)=>{const t=new Map,i=[];for(const s of o){const[,r]=s;if(!e(s))i.push(s);else if(yo(r)){const l=Ue(r.position),a=je(l.x,l.y);t.has(a)||t.set(a,[]),t.get(a).push(s)}else i.push(s)}const n=[];for(const[s,r]of t)if(r.length>0){const l=r.map(([m,u])=>[m,{...u,position:{x:Math.floor(u.position.x),y:Math.floor(u.position.y),z:u.position.z}}]),a=Ve(l,e),[d,f]=s.split(",").map(Number),y=d/j.x,c=f/j.y;for(const[m,u]of a)n.push([m,{...u,position:{x:u.position.x+y,y:u.position.y+c,z:u.position.z}}])}return[...n,...i]},Ke=(o,e=()=>!0)=>{const t=[],i=[];for(const c of o)e(c)&&Ye(c)?t.push(c):i.push(c);const n=G.fromItems(t),s=n.size,{minBounds:r}=n,l=new Map,a=new Map;for(const[,c]of n.iterate())for(const[,m]of c){const u=$(m);a.has(u)||a.set(u,m)}for(const[c]of a)l.set(c,Array.from({length:s.x},()=>Array.from({length:s.y},()=>Array(s.z).fill(!1))));const d=(c,m)=>{const u=N(m),p={x:c.x+u.x-1,y:c.y+u.y-1,z:c.z+u.z-1},C=uo(m),z=$(m),w=new Set;w.add(m);const E=h=>{const v=new Set;let b=!1;for(let{x:g}=c;g<=h.x;g++)for(let{y:x}=c;x<=h.y;x++)for(let{z:I}=c;I<=h.z;I++){const P=n.get({x:g,y:x,z:I});let M=!1,O=!1;if(P)for(const[,T]of P)$(T)===z?(M=!0,v.add(T)):yo(T)&&T.type!=="wall"&&(O=!0);O&&!M&&(b=!0),(!P||P.size===0)&&(b=!0),M||(b=!0)}if(b)return!1;let A=!1;for(const g of v)w.has(g)||(A=!0,w.add(g));if(!A)return!1;for(const g of v){const x=N(g),I={x:g.position.x+x.x-1,y:g.position.y+x.y-1,z:g.position.z+x.z-1};if(g.position.x<c.x||g.position.y<c.y||g.position.z<c.z||I.x>h.x||I.y>h.y||I.z>h.z)return!1}return!0};let R=!0;for(;R;){if(R=!1,C.x>0&&p.x+1<r.x+s.x){let h=p.x;for(let{y:v}=c;v<=p.y;v++)for(let{z:b}=c;b<=p.z;b++){const A=n.get({x:p.x+1,y:v,z:b});if(A){for(const[,g]of A)if($(g)===z){const x=N(g),I=g.position.x+x.x-1;h=Math.max(h,I)}}}h>p.x&&E({...p,x:h})&&(p.x=h,R=!0)}if(C.y>0&&p.y+1<r.y+s.y){let h=p.y;for(let{x:v}=c;v<=p.x;v++)for(let{z:b}=c;b<=p.z;b++){const A=n.get({x:v,y:p.y+1,z:b});if(A){for(const[,g]of A)if($(g)===z){const x=N(g),I=g.position.y+x.y-1;h=Math.max(h,I)}}}h>p.y&&E({...p,y:h})&&(p.y=h,R=!0)}if(C.z>0&&p.z+1<r.z+s.z){let h=p.z;for(let{x:v}=c;v<=p.x;v++)for(let{y:b}=c;b<=p.y;b++){const A=n.get({x:v,y:b,z:p.z+1});if(A){for(const[,g]of A)if($(g)===z){const x=N(g),I=g.position.z+x.z-1;h=Math.max(h,I)}}}h>p.z&&E({...p,z:h})&&(p.z=h,R=!0)}}return p},f=(c,m)=>{if(c.type==="wall"){if(m.type!=="wall")throw new Error("only walls can join walls");if(c.config.direction!==m.config.direction)throw new Error("walls must have the same direction to join");return c.config.direction==="right"||c.config.direction==="towards"?c:{...c,config:{...c.config,tiles:[...c.config.tiles,...m.config.tiles]}}}return c},y=({x:c,y:m,z:u},{x:p,y:C,z},w)=>{const[E,R]=w,h=$(R),v=p-c+1,b=C-m+1,A=z-u+1;let g=R;if(v+b+A>3){const x={...R.config};if(R.type==="wall")switch(R.config.direction){case"away":case"left":break;case"towards":v!==1&&(x.times={x:v});break;case"right":b!==1&&(x.times={y:b});break}else{const I={..._o(N(R))};v!==1&&(I.x=v),b!==1&&(I.y=b),A!==1&&(I.z=A),x.times=I}g={...R,config:x}}for(let x=c;x<=p;x++)for(let I=m;I<=C;I++)for(let P=u;P<=z;P++)if(l.get(h)[x-r.x][I-r.y][P-r.z]=!0,x!==c||I!==m||P!==u){const M=n.get({x,y:I,z:P});if(M)o:for(const O of M){const[,T]=O;if($(T)===h){T.position.x===x&&T.position.y===I&&T.position.z===P&&(g=f(g,T)),n.remove({x,y:I,z:P},O);break o}}}return[E,g]};for(const[c,m]of n.iterate())for(const u of m){const[,p]=u;if(p.position.x===c.x&&p.position.y===c.y&&p.position.z===c.z){const C=$(p),z=l.get(C),w=c.x-r.x,E=c.y-r.y,R=c.z-r.z;if(z&&!z[w][E][R]){const h=d(c,p),v=y(c,h,u);n.remove(c,u),n.add(c,v)}}}return[...n.extractUniqueItems(),...i]},po=(o,e)=>Object.fromEntries(Ge(Object.entries(o),e)),Ze=o=>o[Math.floor(Math.random()*o.length)],Yo=(o,e)=>{o.planet=e;for(const t of Object.values(o.items))t.type==="floor"&&t.config.floorType==="standable"&&(t.config.scenery=e),t.type==="wall"&&(t.config.direction==="away"||t.config.direction==="left")&&(t.config.tiles=Array.from(D(e,t.config.tiles.length))),t.type==="pickup"&&t.config.gives==="crown"&&le.includes(e)&&(t.config.planet=e)},Qe={x:8,y:8},ot=(o,e,t,i,n)=>{const s={};for(const f of n){const y={x:f.x*e.x,y:f.y*e.y},c=Bo(e);for(const[m,u]of Object.entries(c.items)){const p=`${m}_${f.x}_${f.y}`;s[p]={...u,position:{x:u.position.x+y.x,y:u.position.y+y.y,z:u.position.z}}}}const r=new Set;for(const f of n){const y=n.some(m=>m.x===f.x+1&&m.y===f.y),c=n.some(m=>m.x===f.x&&m.y===f.y+1);y&&(r.add(`leftWall_${f.x}_${f.y}`),r.add(`rightWall_${f.x+1}_${f.y}`)),c&&(r.add(`awayWall_${f.x}_${f.y}`),r.add(`towardsWall_${f.x}_${f.y+1}`))}for(const f of r)delete s[f];const l=po(s),a=n.length>1?Object.fromEntries(n.map((f,y)=>[y.toString(),{gridPosition:f,physicalPosition:{from:{x:f.x*e.x,y:f.y*e.y},to:{x:(f.x+1)*e.x-1,y:(f.y+1)*e.y-1}}}])):void 0,d={id:o,planet:"blacktooth",color:t,items:l,...a&&{meta:{subRooms:a}}};return Yo(d,i),d},go=({state:o,scenery:e,maybeColour:t,roomSize:i=Qe,gridPositions:n=[{x:0,y:0}]})=>{const r=`room_${X(de({start:0})).find(d=>o.campaignInProgress.rooms[`room_${d}`]===void 0)}`,l=t??{hue:Ze(me),shade:Math.random()<.66?"basic":"dimmed"},a=ot(r,i,l,e,n);return o.campaignInProgress.rooms[r]=a,a},Y=(o,e,t=!1)=>{if(!o.campaignInProgress.rooms[e]){console.warn(`can't change to room ${e} - it doesn't exist`);return}t||o.editingRoomIdHistory.back.push(o.currentlyEditingRoomId),o.currentlyEditingRoomId=e,o.clickableAnnotationHovered=!1,o.hoveredItem=void 0,o.selectedJsonItemIds=[],t||(o.history=fo.history)},et={addRoom(o,{payload:{roomSize:e,gridPositions:t=[{x:0,y:0}]}}){const{planet:i}=k(o),n=go({state:o,scenery:i,roomSize:e,gridPositions:t});Y(o,n.id)},removeRoom(o){const e=o.campaignInProgress.rooms[o.currentlyEditingRoomId],i=no(W(e.items,"door","teleporter"))?.[1].config.toRoom??no(Oe(n=>n!==o.currentlyEditingRoomId,fe(o.campaignInProgress.rooms)));i===void 0||i===Mo||(delete o.campaignInProgress.rooms[o.currentlyEditingRoomId],o.currentlyEditingRoomId=i)}},Uo=(o,e)=>{for(let t=1;;t++){const i=t===1?e:`${e}_${t}`;if(!o.items[i])return i}},jo=(o,e,t)=>{if(e.type==="player"){const{which:n}=e.config;return t?`preview-${n}`:n}const i=e.type==="monster"?e.config.which:e.type;return Uo(o,i)},co=(o,e,t,i)=>{const n=k(o),s=jo(n,e,i),r=Vo(o,i),l={type:e.type,config:e.config,position:t};return r[s]=l,[s,l]},Vo=(o,e,t=o.currentlyEditingRoomId)=>e?o.previewedEdits:o.campaignInProgress.rooms[t].items;function*Go(o,e,t){for(const i of ye(o)){const[n,s]=i;if(s===null||s.type!=="wall"||s.config.direction!==e)continue;const{position:r,config:l}=s,a=ue(Oo(l)),d=pe(Eo(l.direction)),f=Eo(l.direction),y=ge(t,r);if(y[f]!==0||y[d]<-1||y[d]>=a[d])continue;if(y[d]===0&&a[d]===2){yield[n,null];continue}const c=2+y[d];if(c===1||c===2){const w=L(s,E=>{E.position=S(r,{[d]:c});const R=E.config;switch(R.direction){case"towards":case"right":R.times[d]=a[d]-c;break;default:R.tiles=R.tiles.slice(c)}});yield[n,w];continue}const u=a[d]-y[d];if(u===2||u===1){const w=L(s,E=>{const R=E.config;switch(R.direction){case"towards":case"right":R.times[d]=a[d]-u;break;default:R.tiles=R.tiles.slice(0,-u)}});yield[n,w];continue}const C=L(s,w=>{const E=w.config;switch(E.direction){case"towards":case"right":E.times[d]=y[d];break;default:E.tiles=E.tiles.slice(0,y[d])}});yield[`${n}/beforeDoor`,C];const z=L(s,w=>{w.position={...r,[d]:t[d]+2};const E=w.config;switch(E.direction){case"towards":case"right":E.times[d]=a[d]-y[d]-2;break;default:E.tiles=E.tiles.slice(y[d]+2)}});yield[`${n}/afterDoor`,z],yield[n,null]}}const Ko=(o,e,t,i,n)=>{const s=ro(o,e);if(s===void 0)throw new Error("can't cut hole in walls for a room that does not exist");const r=Vo(o,n,e);for(const[l,a]of Go(s.items,t,i))n?r[l]=a:a===null?delete r[l]:r[l]=a},tt=({state:o,fromRoomJson:e,subRoomId:t,direction:i,isPreview:n,autoAddRooms:s})=>{const r=o.campaignInProgress,l=he({campaign:r,roomId:e.id,subRoomId:t}),a=X(l).find(({gridPosition:d})=>xe(d,Ie[i]));if(a)return r.rooms[a.roomId];if(!n)return s?go({state:o,scenery:e.planet}):void 0},it=o=>W(o.items,"floor").reduce((e,[,t])=>{const i=t.position.y;return Math.min(e,i)},Number.POSITIVE_INFINITY),nt=o=>W(o.items,"floor").reduce((e,[,t])=>{const i=t.position.y+t.config.times.y;return Math.max(e,i)},Number.NEGATIVE_INFINITY),st=o=>W(o.items,"floor").reduce((e,[,t])=>{const i=t.position.x;return Math.min(e,i)},Number.POSITIVE_INFINITY),rt=o=>W(o.items,"floor").reduce((e,[,t])=>{const i=t.position.x+t.config.times.x;return Math.max(e,i)},Number.NEGATIVE_INFINITY),Zo=({state:o,fromRoomJson:e,toRoomJson:t,outgoingDoorEntry:[i,n]})=>{const s=n.config.direction,r=n.position,l=Lo(n.position,"block",e),a=Uo(t,"door"),d={x:s==="left"?st(t):s==="right"?rt(t):r.x,y:s==="away"?it(t):s==="towards"?nt(t):r.y,z:r.z},f=Xo(s),y={type:"door",config:{toRoom:e.id,direction:f,meta:l==="*"?void 0:{toSubRoom:l}},position:d};t.items[a]=y,y.config.toDoor=i,n.config.toDoor=a,Ko(o,t.id,f,d,!1)},ct=(o,e,t,i,n)=>{const s=k(o),r=t;Ko(o,s.id,r,e,n);const l=i.config.toRoom==="+",a=Lo(e,"block",s),d=tt({state:o,fromRoomJson:s,subRoomId:a,direction:r,isPreview:n,autoAddRooms:l}),[f,y]=co(o,{type:"door",config:{...i.config,toRoom:d?d.id:i.config.toRoom,direction:r}},e,n);!n&&d&&Zo({state:o,fromRoomJson:s,toRoomJson:d,outgoingDoorEntry:[f,y]})},ao=(o,e)=>{const t=k(o);t.items=po(t.items,e);const i=o.selectedJsonItemIds.filter(n=>t.items[n]!==void 0);i.length!==o.selectedJsonItemIds.length&&(o.selectedJsonItemIds=i)},So=o=>{const e=o,t=k(e).items;e.selectedJsonItemIds=e.selectedJsonItemIds.filter(i=>i in t)},at={setSelectedItemsInRoom(o,{payload:{jsonItemIds:e}}){const t=k(o).items;e.forEach(i=>{if(!t[i])throw new Error(`Item with json item id "${i}" is not in the current room`)}),o.selectedJsonItemIds=e},toggleSelectedItemInRoom(o,{payload:{jsonItemId:e}}){const t=o.selectedJsonItemIds.indexOf(e);t===-1?o.selectedJsonItemIds.push(e):o.selectedJsonItemIds.splice(t,1)},setHoveredItemInRoom(o,e){o.hoveredItem=e.payload},setClickableAnnotationHovered(o,e){o.clickableAnnotationHovered=e.payload}},_=o=>{const e=structuredClone(F(k(o))),{history:t}=o;t.redo=[],t.undo.push(e)},lt={undo(o){const e=o,{campaignInProgress:t,history:{undo:i,redo:n},currentlyEditingRoomId:s}=e;i.length!==0&&(n.push(t.rooms[s]),t.rooms[s]=i.pop(),So(e))},redo(o){const e=o,{campaignInProgress:t,history:{redo:i,undo:n},currentlyEditingRoomId:s}=e;i.length!==0&&(n.push(t.rooms[s]),t.rooms[s]=i.pop(),So(e))}},dt={selectCanUndo:o=>o.history.undo.length>0,selectCanRedo:o=>o.history.redo.length>0},mt=o=>o.type==="door",ft=o=>o.type==="monster"&&o.config.which==="cyberman",yt={applyItemTool(o,{payload:{blockPosition:e,pointedAtItemJson:t,preview:i}}){const n=o,{tool:s}=n;if(s.type!=="item")throw new Error("applying item tool reducer while the current tool is not an item tool");switch(i||(_(n),n.previewedEdits={}),n.selectedJsonItemIds=[],!0){case mt(s.item):{if(t.type!=="wall")throw new Error("doors can only be added on walls");ct(n,e,t.config.direction,s.item,i);break}case(ft(s.item)&&t.type==="deadlyBlock"&&t.config.style==="toaster"&&t.position.z+1===e.z):{co(n,{...s.item,config:{...s.item.config,activated:"off"}},e,i);break}default:co(n,s.item,e,i)}i||(n.autoCoalesce?ao(n):ao(n,r=>r.type==="wall"))}},ut={setCampaignName(o,{payload:e}){const t=o;t.campaignInProgress.locator.campaignName=e},setCampaignUserId(o,{payload:e}){const t=o;t.campaignInProgress.locator.userId=e},setCampaignPublished(o,{payload:e}){const t=o;t.campaignInProgress.meta===void 0?t.campaignInProgress.meta={published:!1}:t.campaignInProgress.meta.published=e}},pt={changeToRoom(o,{payload:e}){Y(o,e)},roomBack(o){const e=o,{editingRoomIdHistory:t}=e;if(t.back.length===0)return;const i=t.back.pop();t.forward.push(e.currentlyEditingRoomId),Y(e,i,!0)},roomForward(o){const e=o,{editingRoomIdHistory:t}=e;if(t.forward.length===0)return;const i=t.forward.pop();t.back.push(e.currentlyEditingRoomId),Y(e,i,!0)}},gt={changeDragInProgress(o,{payload:e}){const t=o;t.dragInProgress=e}},ht={changeGridResolution(o,{payload:e}){const t=o;t.gridResolution=e},changeWallsFloorsLocked(o,{payload:e}){const t=o;t.wallsFloorsLocked=e}},xt=(o,e)=>{const t=o.currentlyEditingRoomId,i=k(o);for(const n of so(o.campaignInProgress.rooms)){V(n).filter(r=>r.type==="door"||r.type==="teleporter").filter(r=>r.config.toRoom===t).forEach(r=>{r.config.toRoom=e});const s=n.meta?.nonContiguousRelationship?.with;s?.room===t&&(s.room=e)}o.campaignInProgress.rooms[e]={...i,id:e},delete o.campaignInProgress.rooms[t],o.currentlyEditingRoomId=e};function*Qo(o,e){const t={type:"wall",config:we(o.config.direction)?o.config.direction==="towards"?{direction:o.config.direction,times:{x:2}}:{direction:o.config.direction,times:{y:2}}:{direction:o.config.direction,tiles:[...D(e.planet,2,o.position[o.config.direction==="away"?"x":"y"])]},position:{...o.position,z:0}};yield[jo(e,t,!1),t]}const It=(o,e)=>{const t=o.items[e];if(t.type==="door"){for(const[i,n]of Qo(t,o))o.items[i]=n;o.items=po(o.items)}delete o.items[e]},To=(o,e)=>{V(o).filter(t=>t.type==="floor").filter(t=>t.position.z===0).forEach(t=>{t.config={...t.config,floorType:e,scenery:e==="standable"?o.planet:void 0}})},wt={changeRoomColour(o,{payload:e}){const t=o,i=t.campaignInProgress.rooms[t.currentlyEditingRoomId].color;_(t),Object.assign(i,e)},changeRoomScenery(o,{payload:e}){const t=o,i=k(t);_(t),Yo(i,e)},roomJsonEdited(o,{payload:e}){const t=o;_(t);const{rooms:i}=t.campaignInProgress,n=i[t.currentlyEditingRoomId];i[t.currentlyEditingRoomId]=e;const s=t.selectedJsonItemIds.filter(a=>e.items[a]!==void 0);s.length!==t.selectedJsonItemIds.length&&(t.selectedJsonItemIds=s),e.id!==t.currentlyEditingRoomId&&xt(t,e.id),W(e.items,"door").filter(([a,d])=>n.items[a]?.type==="door").filter(a=>{const[,d]=a;return d.config.toRoom!==Mo&&i[d.config.toRoom]!==void 0}).forEach(([a,d])=>{const f=i[d.config.toRoom],y=Xo(d.config.direction),c=W(f.items,"door").filter(([,m])=>m.config.direction===y).toArray();switch(c.length){case 0:Zo({state:t,outgoingDoorEntry:[a,d],fromRoomJson:e,toRoomJson:f});break;case 1:{const[[,m]]=c;m.config.toRoom=e.id,m.config.toDoor=a;break}}});const r=n.meta?.nonContiguousRelationship,l=e.meta?.nonContiguousRelationship;if(l!==void 0){const a=i[l.with.room];a.meta={...a.meta,nonContiguousRelationship:{with:{room:e.id},gridOffset:Re(l.gridOffset,-1)}}}if(r?.with.room!==void 0&&l?.with.room!==r.with.room){const a=i[r.with.room];a.meta?.nonContiguousRelationship?.with.room===t.currentlyEditingRoomId&&delete a.meta.nonContiguousRelationship}},deleteSelected(o){const e=o,t=k(e);_(e),e.selectedJsonItemIds.forEach(i=>{It(t,i)}),e.selectedJsonItemIds=[]},clearRoom(o){const e=o,t=k(e);_(e);for(const i of Do(t.items)){const n=t.items[i];n.type!=="floor"&&n.type!=="wall"&&n.type!=="door"&&(delete t.items[i],e.selectedJsonItemIds=e.selectedJsonItemIds.filter(s=>s!==i))}},setRoomAboveOrBelow(o,{payload:e}){const t=o,i=e.direction==="above"?"roomAbove":"roomBelow",n=i==="roomAbove"?"roomBelow":"roomAbove",s=k(t),r=e.createNew?go({state:t,scenery:s.planet,maybeColour:s.color}).id:e.roomId,l=s[i]&&ro(t,s[i]);l?.[n]===t.currentlyEditingRoomId&&(l[n]=void 0),s[i]=r;const a=r&&ro(t,r);a!==void 0&&(a[n]=s.id),a?To(i==="roomBelow"?s:a,"none"):To(i==="roomBelow"?s:l,"standable")}},Rt=(o,e)=>{const t=Wo(e);for(const[i,n]of t)n===null?delete o.items[i]:o.items[i]=n},Et={setAutoCoalesce(o,e){o.autoCoalesce=e.payload},resetPreviewedEdits(o){o.previewedEdits={}},commitCurrentPreviewedEdits(o){_(o),Rt(k(o),o.previewedEdits),o.autoCoalesce&&ao(o),o.previewedEdits={}}},bt=(o,...e)=>({x:o(...e.map(t=>t.x)),y:o(...e.map(t=>t.y)),z:o(...e.map(t=>t.z))}),Fo=(o,e,t)=>{const i=t-o.length;i>0?o.push(...D(e,i,o.length)):i<0&&o.splice(t)};function oe(o,e){const t=Oo(o.config),i=S(e.position,e.config.times);switch(o.config.direction){case"towards":if(o.position.y===e.position.y&&o.position.x>=e.position.x&&o.position.x<i.x)return{tangentAxis:"x",normalAxis:"y",edgePosition:o.position.y,wallStart:o.position.x,wallLength:t.x??1,isOnFloorEdge:!0,wallFullySpansFloor:o.position.x===e.position.x&&t.x===e.config.times.x,wallTouchesFloorEnd:o.position.x+(t.x??1)===i.x};break;case"right":if(o.position.x===e.position.x&&o.position.y>=e.position.y&&o.position.y<i.y)return{tangentAxis:"y",normalAxis:"x",edgePosition:o.position.x,wallStart:o.position.y,wallLength:t.y??1,isOnFloorEdge:!0,wallFullySpansFloor:o.position.y===e.position.y&&t.y===e.config.times.y,wallTouchesFloorEnd:o.position.y+(t.y??1)===i.y};break;case"away":if(o.position.y===e.position.y+e.config.times.y&&o.position.x>=e.position.x&&o.position.x<i.x)return{tangentAxis:"x",normalAxis:"y",edgePosition:o.position.y,wallStart:o.position.x,wallLength:t.x??1,isOnFloorEdge:!0,wallFullySpansFloor:o.position.x===e.position.x&&t.x===e.config.times.x,wallTouchesFloorEnd:o.position.x+(t.x??1)===i.x};break;case"left":if(o.position.x===e.position.x+e.config.times.x&&o.position.y>=e.position.y&&o.position.y<i.y)return{tangentAxis:"y",normalAxis:"x",edgePosition:o.position.x,wallStart:o.position.y,wallLength:t.y??1,isOnFloorEdge:!0,wallFullySpansFloor:o.position.y===e.position.y&&t.y===e.config.times.y,wallTouchesFloorEnd:o.position.y+(t.y??1)===i.y};break}return null}function*ee(o,e,t,i,n){const s=S(e.position,i),r=e.config.times,l=n?S(r,n):e.config.times,a=S(e.position,r),d=S(s,l);for(const[f,y]of X(o)){if(y.type==="wall"&&y.position.z!==e.position.z)continue;if(y.type==="door"){const p=y.config;let C=!1,z={...F(y.position)};switch(p.direction){case"towards":y.position.y===e.position.y&&y.position.x>=e.position.x&&y.position.x<e.position.x+r.x&&(C=!0,z=S(y.position,i));break;case"right":y.position.x===e.position.x&&y.position.y>=e.position.y&&y.position.y<e.position.y+r.y&&(C=!0,z=S(y.position,i));break;case"away":y.position.y===e.position.y+r.y&&y.position.x>=e.position.x&&y.position.x<e.position.x+r.x&&(C=!0,z=S(y.position,{x:i.x,y:i.y+(n?.y??0),z:i.z}));break;case"left":y.position.x===e.position.x+r.x&&y.position.y>=e.position.y&&y.position.y<e.position.y+r.y&&(C=!0,z=S(y.position,{x:i.x+(n?.x??0),y:i.y,z:i.z}));break}if(C){const w=structuredClone(F(y));w.position=z,yield[f,w]}continue}const c=y,m=oe(c,e);if(!m||!m.isOnFloorEdge)continue;const u=structuredClone(F(c));switch(c.config.direction){case"towards":case"right":u.position=S(c.position,i);break;case"away":{const p=s.y+l.y;u.position={...c.position,x:c.position.x+i.x,y:p};break}case"left":{const p=s.x+l.x;u.position={...c.position,x:p,y:c.position.y+i.y};break}}if(m.wallFullySpansFloor){const p=l[m.tangentAxis];c.config.direction==="away"||c.config.direction==="left"?Fo(u.config.tiles,t,p):u.config.times={[m.tangentAxis]:p},yield[f,u]}else{const p=e.position[m.tangentAxis],C=a[m.tangentAxis],z=s[m.tangentAxis],w=d[m.tangentAxis],E=u.position[m.tangentAxis];if(E>=w){yield[f,null];continue}const R=Math.max(m.wallStart,p),v=Math.min(m.wallStart+m.wallLength,C)-R;let b;if(c.config.direction==="away"||c.config.direction==="left"){const I=e.position[m.normalAxis]+r[m.normalAxis],P=s[m.normalAxis]+l[m.normalAxis];b=I!==P}else b=e.position[m.normalAxis]!==s[m.normalAxis];const A=Math.max(E,z);let g;m.wallTouchesFloorEnd&&!b?g=w:g=Math.min(E+v,w);const x=g-A;x<=0?yield[f,null]:(c.config.direction==="away"||c.config.direction==="left"?Fo(u.config.tiles,t,x):u.config.times={[m.tangentAxis]:x},yield[f,u])}}}function*vt(o,e,t,i){for(const[n,s]of W(o.items,"floor")){const r=oe(e,s);if(!r)continue;const l={x:0,y:0,z:0},a={x:0,y:0,z:0},d=t[r.normalAxis],f=t[r.tangentAxis],y=i?i[r.tangentAxis]:0;if(d!==0&&(e.config.direction==="towards"||e.config.direction==="right"?(l[r.normalAxis]=d,a[r.normalAxis]=-d):a[r.normalAxis]=d),f!==0&&(r.wallStart===s.position[r.tangentAxis]?(l[r.tangentAxis]=f,a[r.tangentAxis]=-f):r.wallTouchesFloorEnd&&(a[r.tangentAxis]=f)),y!==0&&r.wallTouchesFloorEnd&&(a[r.tangentAxis]=y),l.x!==0||l.y!==0||a.x!==0||a.y!==0){const c=S(s.config.times,a),m={...s,position:S(s.position,l),config:{...s.config,times:{x:c.x,y:c.y}}};yield[n,m]}yield*ee(W(o.items,"wall","door"),s,o.planet,l,a)}}const zt={moveOrResizeItemAsPreview(o,{payload:{jsonItemIds:e,timesDelta:t,positionDelta:i}}){const n=o,s=k(n);for(const r of e){const l=Jo(n,r);if(l===void 0)throw new Error(`no json item found for some of the ids in resize ${r}`);if(l.type==="wall"){for(const[d,f]of vt(s,l,i,t))n.previewedEdits[d]=f;continue}if(l.type==="floor")for(const[d,f]of ee(W(s.items,"wall","door"),l,s.planet,i,t))n.previewedEdits[d]=f;if(l.type==="door"){console.log("before healing, room items are",F(s.items));for(const[d,f]of Qo(l,F(s)))console.log("healing",`"${d}"`,f),n.previewedEdits[d]=f}const a={...l,position:S(l.position,i),config:{...l.config}};if(n.previewedEdits[r]=a,Ct(a,t),l.type==="door"){console.log("before cutting room plus previews is",{...F(s.items),...F(n.previewedEdits)});for(const[d,f]of Go({...F(s.items),...F(n.previewedEdits)},a.config.direction,a.position))console.log("cutting",`"${d}"`,f),n.previewedEdits[d]=f}}n.dragInProgress=!0}},Ct=(o,e)=>{if(e!==void 0){const t=N(o),i=uo(o),n=Ee(e,i);if(No(n)>0){const s=_o(bt((r,l)=>Math.max(1,r+l),t,n));s===void 0?delete o.config.times:o.config.times=s}}},kt={loadCampaign(o,{payload:{campaign:e}}){const t=o;t.remoteCampaign=e,t.campaignInProgress=e,t.hoveredItem=void 0,t.selectedJsonItemIds=[],t.clickableAnnotationHovered=!1,t.dragInProgress=!1,t.history=fo.history;const i=X(so(e.rooms)).find(n=>V(n).some(s=>s.type==="player"&&s.config.which==="head"))?.id??X(so(e.rooms)).find(n=>V(n).some(s=>s.type==="player"&&s.config.which==="heels"))?.id??no(Do(e.rooms));if(i===void 0)throw new Error("could not find any rooms in this campaign");t.currentlyEditingRoomId=i},setRemoteCampaign(o,{payload:{campaign:e}}){const t=o;t.remoteCampaign=e}},te=be({name:"levelEditor",initialState:fo,reducers:{setTool(o,{payload:e}){const t=o;e.type==="item"&&(t.selectedJsonItemIds=[],t.hoveredItem=void 0),t.tool=e},injected(){},...ht,...lt,...yt,...gt,...at,...wt,...zt,...Et,...kt,...et,...pt,...ut},selectors:{selectCurrentCampaignInProgress:o=>o.campaignInProgress,selectCurrentEditingRoomJson:k,selectItem:Jo,selectCurrentEditingRoomColour:o=>k(o).color,selectCurrentEditingRoomScenery:o=>k(o).planet,selectTool:o=>o.tool,selectSelectedJsonItemIds:o=>o.selectedJsonItemIds,selectHoveredItem:o=>o.hoveredItem,selectItemIsSelected:Je,...dt}}),{addRoom:Ht,applyItemTool:Bt,changeDragInProgress:Jt,changeGridResolution:Yt,changeRoomColour:Ut,changeRoomScenery:jt,changeToRoom:Vt,changeWallsFloorsLocked:Gt,clearRoom:Kt,commitCurrentPreviewedEdits:Zt,deleteSelected:Qt,injected:oi,loadCampaign:ei,moveOrResizeItemAsPreview:ti,redo:ii,removeRoom:ni,resetPreviewedEdits:si,roomBack:ri,roomForward:ci,roomJsonEdited:ai,setAutoCoalesce:li,setCampaignName:di,setCampaignPublished:mi,setCampaignUserId:fi,setClickableAnnotationHovered:yi,setHoveredItemInRoom:ui,setRemoteCampaign:pi,setRoomAboveOrBelow:gi,setSelectedItemsInRoom:hi,setTool:xi,toggleSelectedItemInRoom:Ii,undo:wi}=te.actions,{selectCanRedo:Ri,selectCanUndo:Ei,selectCurrentCampaignInProgress:bi,selectCurrentEditingRoomColour:vi,selectCurrentEditingRoomJson:zi,selectCurrentEditingRoomScenery:Ci,selectHoveredItem:ki,selectItem:Ai,selectItemIsSelected:Pi,selectSelectedJsonItemIds:Si,selectTool:Ti}=te.selectors;ve.withTypes();const At={Container:"ðŸ“¦",Sprite:"ðŸ–¼ï¸",UniqueTextureSprite:"âœ¨",Graphics:"ðŸŽ¨",Text:"ðŸ“",AnimatedSprite:"ðŸŽ¬",TilingSprite:"ðŸ”²",BitmapText:"ðŸ”¤",Mesh:"ðŸ”º",NineSliceSprite:"ðŸ”³"},Pt=o=>{const e=o.constructor.name;return e.startsWith("_")?e.slice(1):e},St=o=>At[o]||"ðŸ“Œ",Tt=o=>{const e=[];try{(o.x!==0||o.y!==0)&&e.push(`@(x=${o.x}, y=${o.y})`)}catch{e.push("@(ERROR)")}if(o.children.length>0&&e.push(`children: ${o.children.length}`),o.visible||e.push("hidden"),o.alpha<1&&e.push(`alpha: ${o.alpha.toFixed(2)}`),o.mask&&e.push("ðŸ˜· masked"),o instanceof ze)if(o.texture===null||o.texture===void 0)e.push("texture: NO TEXTURE");else{const t=o.texture.label||"(anon texture)";e.push(`texture: "${t}"`)}return e},Ft=(o,e)=>o.label&&o.label!==e?` "${o.label}"`:"",Wt=(o,e="",t=!0,i=!0,n=[])=>{const s=[];i&&s.push("");const r=Pt(o);let l=St(r);n.forEach((c,m)=>{c.mask===o&&(m===0?l+="ðŸ˜·":l+=`ðŸ˜·^${m+1}`)});const a=Ft(o,r),d=Tt(o),f=i?"":e+(t?"â””â”€â”€ ":"â”œâ”€â”€ ");if(s.push(`${f}${l} ${r}${a}`),d.length>0){const c=o.children.length>0,m=i?c?"â”‚  ":"   ":e+(t?"    ":"â”‚   ")+(c?"â”‚  ":"   ");d.forEach(u=>{s.push(`${m}â†’ ${u}`)})}const y=i?"":e+(t?"    ":"â”‚   ");return o.children.forEach((c,m)=>{const u=m===o.children.length-1;s.push(Wt(c,y,u,!1,[o,...n]))}),s.join(`
`)+(i?`
`:"")};export{Ot as a,qt as b,Ze as c,Lt as d,Xt as e,Vt as f,Ho as g,ki as h,Si as i,Ti as j,Wt as p,Dt as r,yi as s};
