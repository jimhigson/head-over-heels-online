import{g as $,h as O,j as A,b as C,k as B,m as x,n as u,q as v,r as D,x as X,y,A as k,B as I,C as E,D as F,E as L,F as N,H as P,I as V,l as Y,J as Z,K as q,L as K,M as Q,N as U,O as _,P as T,Q as G,R as S,S as j,T as tt,U as R,W as H,X as ot,Y as it,Z as et,_ as z}from"./App-BYUSQGEa.js";const st=1e3/25,J=t=>{const o=$.animations[t],s=o.length,{animationSpeed:i}=o;return s*st/i};J("bubbles.white");const at=J("head.fadeOut"),nt=({touchedItem:t,room:o,gameState:s})=>{O({room:o,item:t});const i=A({itemType:"bubbles",config:{style:"white",was:t.type==="pickup"?{type:"pickup",gives:t.config.gives}:t.type==="hushPuppy"?{type:"hushPuppy"}:{type:"disappearing"}},position:C,room:o,gameState:s}),e=B(t);i.state.position=x(e,u(i.aabb,.5)),i.state.expires=o.roomTime+at},rt=(t,o)=>{const s=v(t.items).filter(D("hushPuppy"));for(const i of s)nt({touchedItem:i,gameState:o,room:t})},dt=.5,M=(t,o,s,i)=>{const e=s.x+i.x-t.x,r=s.y+i.y-t.y,l=s.z+i.z-t.z,f=t.x+o.x-s.x,p=t.y+o.y-s.y,h=t.z+o.z-s.z,d=Math.abs(e)<Math.abs(f)?e:-f,m=Math.abs(r)<Math.abs(p)?r:-p,a=Math.abs(l)<Math.abs(h)?l:-h,n=Math.abs(d),c=Math.abs(m),w=Math.abs(a)*dt;return n<c&&n<w?{x:d,y:0,z:0}:c<w?{x:0,y:m,z:0}:{x:0,y:0,z:a}},W=({subjectItem:t,posDelta:o,gameState:s,room:i,pusher:e,deltaMS:r,forceful:l=D("lift")(t)&&e===void 0,recursionDepth:f=0,onTouch:p})=>{if(X(o,C))return;const{state:{position:h}}=t;if(t.state.position=y(h,o),k(t)){const{actedOnAt:a}=t.state;a.roomTime===i.roomTime?e&&(a.by[e.id]=!0):(a.by=e?{[e.id]:!0}:{},a.roomTime=i.roomTime)}const d=I(o,E(t,F(i.items)));let m=!1;for(const a of d){if(!L(t,a))continue;const n=N(a);if(e!==a&&!(m&&n)&&p!==void 0&&(p({movingItem:t,touchedItem:a,movementVector:x(t.state.position,h),gameState:s,deltaMS:r,room:i}),m=m||n),i.items[t.id]===void 0)return;if(i.items[a.id]===void 0||!P(a,t)||!P(t))continue;const c=M(t.state.position,t.aabb,a.state.position,a.aabb),w=V(Y(M(h,t.aabb,a.state.position,a.aabb)),0);if(Z(t,a,l)&&a!==e){const g=l||_(a)?-1:-.5,b=u(c,g);if(t.state.position=y(t.state.position,c,b),f<q&&W({subjectItem:a,posDelta:b,pusher:t,gameState:s,room:i,deltaMS:r,forceful:l,recursionDepth:f+1,onTouch:p}),i.items[a.id]===void 0)continue;t.state.position=y(t.state.position,M(t.state.position,t.aabb,a.state.position,a.aabb))}else t.state.position=y(t.state.position,c);if(k(t)&&c.z>0&&(t.state.standingOnItemId===null||!d.includes(K(t.state.standingOnItemId,i)))&&(Q(t,i),U({above:t,below:a})),k(t)&&!w){const{collidedWith:g}=t.state;g.roomTime===i.roomTime?e&&(g.by[a.id]=!0):(g.by={[a.id]:!0},g.roomTime=i.roomTime)}}},ct=(t,o,{changeType:s,sourceItem:i})=>{switch(s){case"portal":return v(t.items).find(e=>z(e)&&e.config.toRoom===o.id&&(i.config.toDoor===void 0||e.jsonItemId===i.config.toDoor)&&X(u(i.config.direction,-1),e.config.direction));case"level-select":return v(t.items).find(e=>z(e)&&e.config.toRoom===o.id&&e.config.direction.z===0)??v(t.items).find(e=>z(e)&&e.config.direction.z===0)??v(t.items).find(e=>z(e)&&e.config.direction.z>0)??v(t.items).find(z)}},lt=(t,o,s,i)=>{const e=1*H.w;t.state.position=y(t.state.position,u(o,e));for(let r=0;r<e;r++)W({subjectItem:t,posDelta:u(o,-1),gameState:s,room:i,deltaMS:16,forceful:!0,onTouch:void 0})},pt=t=>{const{playableItem:o,gameState:s,toRoomId:i,changeType:e,sourceItem:r}=t,l=s.characterRooms[o.id];if(l===void 0)throw new Error(`${o.id} is not in a room on the gameState`);if(i===l.id)throw new Error(`Can't move ${o.id} to the same room "${i}""`);let f;switch(e){case"portal":{const{config:{relativePoint:n},state:{position:c}}=r;f=x(o.state.position,y(c,n));break}case"teleport":{const{state:{position:n}}=r;f=x(o.state.position,n);break}case"level-select":f={x:0,y:0,z:0};break;default:throw new Error}const p=o.type==="headOverHeels"?void 0:s.characterRooms[T(o.id)],h=s.campaign.rooms[i];if(h===void 0)throw new Error(`room ${i} does not exist in campaign`);const d=p?.id===i?p:G({roomJson:h,roomPickupsCollected:s.pickupsCollected[i]??j,scrollsRead:S.getState().gameMenus.scrollsRead});O({room:l,item:o});const m=tt(o);if(m!==void 0&&(m.carrying=null),o.state.latentMovement=[],(o.type==="head"||o.type==="headOverHeels")&&rt(d,s),O({room:d,item:o}),d.items[o.id]=o,s.characterRooms[o.id]=d,t.changeType==="teleport"){const{config:{toPosition:n}}=t.sourceItem;o.state.position=y(R(n),f)}else{const n=ct(d,l,t);if(console.log("putting",o.id,"into",i,"at portal",n,"because",e,"sourceportal",r),n===void 0)if(t.changeType==="level-select")o.state.position=R({x:1,y:1,z:8});else throw new Error(`trying to move ${o.id} from ${l.id} --to-> ${i} but no destination portal found to locate with`);else{o.state.position=y(n.state.position,n.config.relativePoint,f,e==="portal"&&r.config.direction.z>0?{z:H.h}:{});const{config:{direction:c}}=n;c.z===0&&(o.state.autoWalk=!0,o.state.facing=u(c,-1),o.state.action==="idle"&&(o.state.action="moving"),lt(o,c,s,d))}}const a=E(o,F(d.items));a.length>0&&console.warn("on entering room",i,"character",o.id,"at",o.state.position,"collides with",a),s.entryState[o.id]=ot(o),o.id==="headOverHeels"?(delete s.entryState.head,delete s.entryState.heels):(s.entryState[T(o.id)]||(s.entryState[T(o.id)]=s.entryState.headOverHeels),delete s.entryState.headOverHeels),S.dispatch(it(i)),S.dispatch(et({characterName:o.type,roomId:i}))};export{W as a,nt as b,pt as c,at as f,M as m,st as o,rt as r};
