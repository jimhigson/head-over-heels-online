import{R as J,T as b,P as A,U as C,W as L,l as x,X as u,Y as v,A as X,Z as E,q as m,E as T,_ as V,$,a0 as D,a1 as Y,a2 as Z,a3 as O,a4 as q,a5 as B,a6 as N,a7 as Q,a8 as U,a9 as _,aa as G,ab as I,L as k,ac as K,ad as P,ae as j,af as tt,ag as R,Q as F,ah as it,ai as ot,x as et,aj as z}from"./App-Dt5T8S_5.js";const at=1e3/25,H=t=>{const i=J.animations[t],e=i.length,{animationSpeed:o}=i;return e*at/o};H("bubbles.white");const st=H("head.fadeOut"),nt=({touchedItem:t,room:i,gameState:e})=>{b({room:i,item:t});const o=A({itemType:"bubbles",config:{style:"white",was:t.type==="pickup"?{type:"pickup",gives:t.config.gives}:t.type==="hushPuppy"?{type:"hushPuppy"}:{type:"disappearing"}},position:C,room:i,gameState:e}),a=L(t);o.state.position=x(a,u(o.aabb,.5)),o.state.expires=i.roomTime+st},rt=(t,i)=>{const e=v(t.items).filter(X("hushPuppy"));for(const o of e)nt({touchedItem:o,gameState:i,room:t})},dt=.5,S=(t,i,e,o)=>{const a=e.x+o.x-t.x,r=e.y+o.y-t.y,l=e.z+o.z-t.z,f=t.x+i.x-e.x,p=t.y+i.y-e.y,h=t.z+i.z-e.z,d=Math.abs(a)<Math.abs(f)?a:-f,y=Math.abs(r)<Math.abs(p)?r:-p,s=Math.abs(l)<Math.abs(h)?l:-h,n=Math.abs(d),c=Math.abs(y),w=Math.abs(s)*dt;return n<c&&n<w?{x:d,y:0,z:0}:c<w?{x:0,y,z:0}:{x:0,y:0,z:s}},W=({subjectItem:t,posDelta:i,gameState:e,room:o,pusher:a,deltaMS:r,forceful:l=X("lift")(t)&&a===void 0,recursionDepth:f=0,onTouch:p})=>{if(E(i,C))return;const{state:{position:h}}=t;if(t.state.position=m(h,i),T(t)){const{actedOnAt:s}=t.state;s.roomTime===o.roomTime?a&&(s.by[a.id]=!0):(s.by=a?{[a.id]:!0}:{},s.roomTime=o.roomTime)}const d=V(i,$(t,D(o.items)));let y=!1;for(const s of d){if(!Y(t,s))continue;const n=Z(s);if(a!==s&&!(y&&n)&&p!==void 0&&(p({movingItem:t,touchedItem:s,movementVector:x(t.state.position,h),gameState:e,deltaMS:r,room:o}),y=y||n),o.items[t.id]===void 0)return;if(o.items[s.id]===void 0||!O(s,t)||!O(t))continue;const c=S(t.state.position,t.aabb,s.state.position,s.aabb),w=q(B(S(h,t.aabb,s.state.position,s.aabb)),0);if(N(t,s,l)&&s!==a){const g=l||I(s)?-1:-.5,M=u(c,g);if(t.state.position=m(t.state.position,c,M),f<Q&&W({subjectItem:s,posDelta:M,pusher:t,gameState:e,room:o,deltaMS:r,forceful:l,recursionDepth:f+1,onTouch:p}),o.items[s.id]===void 0)continue;t.state.position=m(t.state.position,S(t.state.position,t.aabb,s.state.position,s.aabb))}else t.state.position=m(t.state.position,c);if(T(t)&&c.z>0&&(t.state.standingOnItemId===null||!d.includes(U(t.state.standingOnItemId,o)))&&(_(t,o),G({above:t,below:s})),T(t)&&!w){const{collidedWith:g}=t.state;g.roomTime===o.roomTime?a&&(g.by[s.id]=!0):(g.by={[s.id]:!0},g.roomTime=o.roomTime)}}},ct=(t,i,{changeType:e,sourceItem:o})=>{switch(e){case"portal":return v(t.items).find(a=>z(a)&&a.config.toRoom===i.id&&E(u(o.config.direction,-1),a.config.direction));case"level-select":return v(t.items).find(a=>z(a)&&a.config.toRoom===i.id&&a.config.direction.z===0)??v(t.items).find(a=>z(a)&&a.config.direction.z===0)??v(t.items).find(a=>z(a)&&a.config.direction.z>0)??v(t.items).find(z)}},lt=(t,i,e,o)=>{const a=1*F.w;t.state.position=m(t.state.position,u(i,a));for(let r=0;r<a;r++)W({subjectItem:t,posDelta:u(i,-1),gameState:e,room:o,deltaMS:16,forceful:!0,onTouch:void 0})},pt=t=>{const{playableItem:i,gameState:e,toRoomId:o,changeType:a,sourceItem:r}=t,l=e.characterRooms[i.id];if(l===void 0)throw new Error(`${i.id} is not in a room on the gameState`);if(o===l.id)throw new Error(`Can't move ${i.id} to the same room "${o}""`);let f;switch(a){case"portal":{const{config:{relativePoint:n},state:{position:c}}=r;f=x(i.state.position,m(c,n));break}case"teleport":{const{state:{position:n}}=r;f=x(i.state.position,n);break}case"level-select":f={x:0,y:0,z:0};break;default:throw new Error}const p=i.type==="headOverHeels"?void 0:e.characterRooms[k(i.id)],h=e.campaign.rooms[o];if(h===void 0)throw new Error(`room ${o} does not exist in campaign`);const d=p?.id===o?p:K({roomJson:h,roomPickupsCollected:e.pickupsCollected[o]??j,scrollsRead:P.getState().gameMenus.scrollsRead});b({room:l,item:i});const y=tt(i);if(y!==void 0&&(y.carrying=null),i.state.latentMovement=[],(i.type==="head"||i.type==="headOverHeels")&&rt(d,e),b({room:d,item:i}),d.items[i.id]=i,e.characterRooms[i.id]=d,t.changeType==="teleport"){const{config:{toPosition:n}}=t.sourceItem;i.state.position=m(R(n),f)}else{const n=ct(d,l,t);if(console.log("putting",i.id,"into",o,"at portal",n,"because",a,"sourceportal",r),n===void 0)if(t.changeType==="level-select")i.state.position=R({x:1,y:1,z:8});else throw new Error(`trying to move ${i.id} from ${l.id} --to-> ${o} but no destination portal found to locate with`);else{i.state.position=m(n.state.position,n.config.relativePoint,f,a==="portal"&&r.config.direction.z>0?{z:F.h}:{});const{config:{direction:c}}=n;c.z===0&&(i.state.autoWalk=!0,i.state.facing=u(c,-1),i.state.action==="idle"&&(i.state.action="moving"),lt(i,c,e,d))}}const s=$(i,D(d.items));s.length>0&&console.warn("on entering room",o,"character",i.id,"at",i.state.position,"collides with",s),e.entryState[i.id]=it(i),i.id==="headOverHeels"?(delete e.entryState.head,delete e.entryState.heels):(e.entryState[k(i.id)]||(e.entryState[k(i.id)]=e.entryState.headOverHeels),delete e.entryState.headOverHeels),P.dispatch(ot(o)),P.dispatch(et({characterName:i.type,roomId:o}))};export{W as a,nt as b,pt as c,st as f,S as m,at as o,rt as r};
