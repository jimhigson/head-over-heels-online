import{l as $,o as B,u as J,g as X,b as W,c as Y,e as F}from"./App-Byvpw329.js";function q(r){var e="";return o(r),e;function o(i){if(i===null||typeof i!="object"||i.toJSON!=null)e+=JSON.stringify(i);else if(Array.isArray(i)){e+="[";var a=!1;i.forEach(function(d){a&&(e+=","),a=!0,d===void 0&&(d=null),o(d)}),e+="]"}else{e+="{";var u=Object.keys(i).filter(function(d){return i[d]!==void 0}).sort();u.forEach(function(d,g){return n(i,d,g)}),e+="}"}}function n(i,a,u){u>0&&(e+=","),e+=JSON.stringify(a),e+=":",o(i[a])}}const K=r=>$(R(r))>0,R=r=>{switch(r.type){case"deadlyBlock":return J;case"conveyor":if(r.config.disappearing)return B;switch(r.config.direction){case"left":case"right":return{x:1,y:0,z:0};case"away":case"towards":return{x:0,y:1,z:0};default:throw r.config.direction,new Error}case"hushPuppy":return J;case"teleporter":return{x:1,y:1,z:0};case"floor":case"spikes":return{x:1,y:1,z:0};case"block":return J;case"barrier":if(r.config.disappearing)return B;switch(r.config.axis){case"x":return{x:1,y:0,z:1};case"y":return{x:0,y:1,z:1};default:throw r.config.axis,new Error}case"wall":switch(r.config.direction){case"left":case"right":return{x:0,y:1,z:1};case"away":case"towards":return{x:1,y:0,z:1};default:throw r.config,new Error}default:return B}};class N{#i;#e;#t;constructor(e,o){this.#e={x:-e.x,y:-e.y,z:-e.z},this.#t={x:o.x-e.x+1,y:o.y-e.y+1,z:o.z-e.z+1},this.#i=Array.from({length:this.#t.x},()=>Array.from({length:this.#t.y},()=>Array.from({length:this.#t.z},()=>new Set)))}static fromItems(e){let o=1/0,n=1/0,i=1/0,a=-1/0,u=-1/0,d=-1/0;const g=[...e];for(const[,S]of g){const{x:A,y:t,z:y}=S.position,f=X(S);o=Math.min(o,A),n=Math.min(n,t),i=Math.min(i,y),a=Math.max(a,A+f.x-1),u=Math.max(u,t+f.y-1),d=Math.max(d,y+f.z-1)}if(g.length===0)return new N({x:0,y:0,z:0},{x:0,y:0,z:0});const T=new N({x:o,y:n,z:i},{x:a,y:u,z:d});for(const S of g){const[,A]=S,{x:t,y,z:f}=A.position,s=X(A);for(let b=0;b<s.x;b++)for(let w=0;w<s.y;w++)for(let M=0;M<s.z;M++)T.add({x:t+b,y:y+w,z:f+M},S)}return T}get(e){const o=e.x+this.#e.x,n=e.y+this.#e.y,i=e.z+this.#e.z;if(this.#o(o,n,i))return this.#i[o][n][i]}set(e,o){const n=e.x+this.#e.x,i=e.y+this.#e.y,a=e.z+this.#e.z;this.#o(n,i,a)&&(this.#i[n][i][a]=o)}add(e,o){const n=this.get(e);n&&n.add(o)}remove(e,o){const n=this.get(e);n&&n.delete(o)}get size(){return{...this.#t}}get minBounds(){return{x:-this.#e.x,y:-this.#e.y,z:-this.#e.z}}get maxBounds(){const e=this.minBounds;return{x:e.x+this.#t.x-1,y:e.y+this.#t.y-1,z:e.z+this.#t.z-1}}*iterate(){const{minBounds:e}=this;for(let o=0;o<this.#t.x;o++)for(let n=0;n<this.#t.y;n++)for(let i=0;i<this.#t.z;i++)yield[{x:o+e.x,y:n+e.y,z:i+e.z},this.#i[o][n][i]]}extractUniqueItems(){const e=new Set,o=[];for(const[,n]of this.iterate())for(const i of n)e.has(i)||(e.add(i),o.push(i));return o}#o(e,o,n){return e>=0&&e<this.#t.x&&o>=0&&o<this.#t.y&&n>=0&&n<this.#t.z}}const E=r=>r.type==="wall"?`wall/${r.config.direction}`:r.type==="teleporter"?q({type:r.type,config:Y(r.config,"toPosition","times")}):q({type:r.type,config:Y(r.config,"times")}),H=r=>K(r[1]),U=r=>({x:Math.floor(r.x%1*W.x),y:Math.floor(r.y%1*W.y)}),V=(r,e)=>`${r},${e}`,Z=(r,e)=>{let o=r,n=o.length;for(;;){const i=[...L(o,e)];if(i.length===n)return i;n=i.length,o=i}},D=(r,e=()=>!0)=>{const o=new Map,n=[];for(const a of r){const[,u]=a;if(!e(a))n.push(a);else if(K(u)){const d=U(u.position),g=V(d.x,d.y);o.has(g)||o.set(g,[]),o.get(g).push(a)}else n.push(a)}const i=[];for(const[a,u]of o)if(u.length>0){const d=u.map(([y,f])=>[y,{...f,position:{x:Math.floor(f.position.x),y:Math.floor(f.position.y),z:f.position.z}}]),g=Z(d,e),[T,S]=a.split(",").map(Number),A=T/W.x,t=S/W.y;for(const[y,f]of g)i.push([y,{...f,position:{x:f.position.x+A,y:f.position.y+t,z:f.position.z}}])}return[...i,...n]},L=(r,e=()=>!0)=>{const o=[],n=[];for(const t of r)e(t)&&H(t)?o.push(t):n.push(t);const i=N.fromItems(o),a=i.size,{minBounds:u}=i,d=new Map,g=new Map;for(const[,t]of i.iterate())for(const[,y]of t){const f=E(y);g.has(f)||g.set(f,y)}for(const[t]of g)d.set(t,Array.from({length:a.x},()=>Array.from({length:a.y},()=>Array(a.z).fill(!1))));const T=(t,y)=>{const f=X(y),s={x:t.x+f.x-1,y:t.y+f.y-1,z:t.z+f.z-1},b=R(y),w=E(y),M=new Set;M.add(y);const C=l=>{const z=new Set;let m=!1;for(let{x:c}=t;c<=l.x;c++)for(let{y:x}=t;x<=l.y;x++)for(let{z:h}=t;h<=l.z;h++){const k=i.get({x:c,y:x,z:h});let O=!1,P=!1;if(k)for(const[,v]of k)E(v)===w?(O=!0,z.add(v)):K(v)&&v.type!=="wall"&&(P=!0);P&&!O&&(m=!0),(!k||k.size===0)&&(m=!0),O||(m=!0)}if(m)return!1;let I=!1;for(const c of z)M.has(c)||(I=!0,M.add(c));if(!I)return!1;for(const c of z){const x=X(c),h={x:c.position.x+x.x-1,y:c.position.y+x.y-1,z:c.position.z+x.z-1};if(c.position.x<t.x||c.position.y<t.y||c.position.z<t.z||h.x>l.x||h.y>l.y||h.z>l.z)return!1}return!0};let p=!0;for(;p;){if(p=!1,b.x>0&&s.x+1<u.x+a.x){let l=s.x;for(let{y:z}=t;z<=s.y;z++)for(let{z:m}=t;m<=s.z;m++){const I=i.get({x:s.x+1,y:z,z:m});if(I){for(const[,c]of I)if(E(c)===w){const x=X(c),h=c.position.x+x.x-1;l=Math.max(l,h)}}}l>s.x&&C({...s,x:l})&&(s.x=l,p=!0)}if(b.y>0&&s.y+1<u.y+a.y){let l=s.y;for(let{x:z}=t;z<=s.x;z++)for(let{z:m}=t;m<=s.z;m++){const I=i.get({x:z,y:s.y+1,z:m});if(I){for(const[,c]of I)if(E(c)===w){const x=X(c),h=c.position.y+x.y-1;l=Math.max(l,h)}}}l>s.y&&C({...s,y:l})&&(s.y=l,p=!0)}if(b.z>0&&s.z+1<u.z+a.z){let l=s.z;for(let{x:z}=t;z<=s.x;z++)for(let{y:m}=t;m<=s.y;m++){const I=i.get({x:z,y:m,z:s.z+1});if(I){for(const[,c]of I)if(E(c)===w){const x=X(c),h=c.position.z+x.z-1;l=Math.max(l,h)}}}l>s.z&&C({...s,z:l})&&(s.z=l,p=!0)}}return s},S=(t,y)=>{if(t.type==="wall"){if(y.type!=="wall")throw new Error("only walls can join walls");if(t.config.direction!==y.config.direction)throw new Error("walls must have the same direction to join");return t.config.direction==="right"||t.config.direction==="towards"?t:{...t,config:{...t.config,tiles:[...t.config.tiles,...y.config.tiles]}}}return t},A=({x:t,y,z:f},{x:s,y:b,z:w},M)=>{const[C,p]=M,l=E(p),z=s-t+1,m=b-y+1,I=w-f+1;let c=p;if(z+m+I>3){const x={...p.config};if(p.type==="wall")switch(p.config.direction){case"away":case"left":break;case"towards":z!==1&&(x.times={x:z});break;case"right":m!==1&&(x.times={y:m});break}else{const h={...F(X(p))};z!==1&&(h.x=z),m!==1&&(h.y=m),I!==1&&(h.z=I),x.times=h}c={...p,config:x}}for(let x=t;x<=s;x++)for(let h=y;h<=b;h++)for(let k=f;k<=w;k++)if(d.get(l)[x-u.x][h-u.y][k-u.z]=!0,x!==t||h!==y||k!==f){const O=i.get({x,y:h,z:k});if(O)t:for(const P of O){const[,v]=P;if(E(v)===l){v.position.x===x&&v.position.y===h&&v.position.z===k&&(c=S(c,v)),i.remove({x,y:h,z:k},P);break t}}}return[C,c]};for(const[t,y]of i.iterate())for(const f of y){const[,s]=f;if(s.position.x===t.x&&s.position.y===t.y&&s.position.z===t.z){const b=E(s),w=d.get(b),M=t.x-u.x,C=t.y-u.y,p=t.z-u.z;if(w&&!w[M][C][p]){const l=T(t,s),z=A(t,l,f);i.remove(t,f),i.add(t,z)}}}return[...i.extractUniqueItems(),...n]},_=(r,e)=>Object.fromEntries(D(Object.entries(r),e));export{_ as c,R as g};
