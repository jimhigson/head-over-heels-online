import{s as L,b as T,c as V,e as F,f as N,g as w,h as v,j as u,k as H,l as S,x as X,n as m,q as x,r as J,t as $,u as q,w as I,y as M,z as Y,A as Z,C as K,E as Q,F as U,H as G,I as _,J as j,K as P,L as tt,M as et,N as it,O as C,P as W,Q as ot,R,S as st,T as at,U as z}from"./App-BGbxHmwR.js";const nt=1e3/25,A=t=>{const e=L.animations[t],o=e.length,{animationSpeed:i}=e;return o*nt/i};A("bubbles.white");const rt=A("head.fadeOut"),dt=({touchedItem:t,room:e,gameState:o})=>{T({room:e,item:t});const i=V({itemType:"bubbles",config:{style:"white",was:t.type==="pickup"?{type:"pickup",gives:t.config.gives}:t.type==="hushPuppy"?{type:"hushPuppy"}:{type:"disappearing"}},position:F,room:e,gameState:o}),s=N(t);i.state.position=w(s,v(i.aabb,.5)),i.state.expires=e.roomTime+rt},lt=(t,e)=>{const o=u(t.items).filter(H("hushPuppy"));for(const i of o)dt({touchedItem:i,gameState:e,room:t})},ct=.5,b=(t,e,o,i)=>{const s=o.x+i.x-t.x,r=o.y+i.y-t.y,d=o.z+i.z-t.z,p=t.x+e.x-o.x,f=t.y+e.y-o.y,y=t.z+e.z-o.z,l=Math.abs(s)<Math.abs(p)?s:-p,h=Math.abs(r)<Math.abs(f)?r:-f,a=Math.abs(d)<Math.abs(y)?d:-y,n=Math.abs(l),c=Math.abs(h),k=Math.abs(a)*ct;return n<c&&n<k?{x:l,y:0,z:0}:c<k?{x:0,y:h,z:0}:{x:0,y:0,z:a}},D=(t,e)=>({x:t.x>0?e.state.position.x:e.state.position.x+e.aabb.x,y:t.y>0?e.state.position.y:e.state.position.y+e.aabb.y,z:t.z>0?e.state.position.z:e.state.position.z+e.aabb.z}),E={stopAutowalk:5,portal:5,wall:5,doorLegs:5,sceneryPlayer:5,bubbles:5,switch:10,doorFrame:15,ball:18,block:20,barrier:20,floor:20,floorEdge:20,hushPuppy:20,teleporter:20,lift:30,movingPlatform:30,pushableBlock:30,portableBlock:30,sceneryCrown:30,slidingBlock:30,spring:30,joystick:40,charles:40,conveyor:40,head:50,heels:50,headOverHeels:50,pickup:80,firedDoughnut:90,spikes:98,slidingDeadly:100,moveableDeadly:100,deadlyBlock:100,monster:100,floatingText:200,particle:200,emitter:200},pt=(t,e)=>E[t.type]-E[e.type],ft=(t,e)=>e.toSorted((o,i)=>{const s=pt(o,i);if(s!==0)return s;const r=S(t,D(t,o)),d=S(t,D(t,i));return Math.abs(r-d)<1e-4?o.id<i.id?-1:1:r-d}),B=({subjectItem:t,posDelta:e,gameState:o,room:i,pusher:s,deltaMS:r,forceful:d=H("lift")(t)&&s===void 0,recursionDepth:p=0,onTouch:f})=>{if(X(e,F))return;const{state:{position:y}}=t;if(t.state.position=m(y,e),x(t)){const{actedOnAt:a}=t.state;a.roomTime===i.roomTime?s&&(a.by[s.id]=!0):(a.by=s?{[s.id]:!0}:{},a.roomTime=i.roomTime)}const l=ft(e,J(t,$(i.items)));let h=!1;for(const a of l){if(!q(t,a))continue;const n=I(a);if(s!==a&&!(h&&n)&&f!==void 0&&(f({movingItem:t,touchedItem:a,movementVector:w(t.state.position,y),gameState:o,deltaMS:r,room:i}),h=h||n),i.items[t.id]===void 0)return;if(i.items[a.id]===void 0||!M(a,t)||!M(t))continue;const c=b(t.state.position,t.aabb,a.state.position,a.aabb),k=Y(Z(b(y,t.aabb,a.state.position,a.aabb)),0);if(K(t,a,d)&&a!==s){const g=d||j(a)?-1:-.5,O=v(c,g);if(t.state.position=m(t.state.position,c,O),p<Q&&B({subjectItem:a,posDelta:O,pusher:t,gameState:o,room:i,deltaMS:r,forceful:d,recursionDepth:p+1,onTouch:f}),i.items[a.id]===void 0)continue;t.state.position=m(t.state.position,b(t.state.position,t.aabb,a.state.position,a.aabb))}else t.state.position=m(t.state.position,c);if(x(t)&&c.z>0&&(t.state.standingOnItemId===null||!l.includes(U(t.state.standingOnItemId,i)))&&(G(t,i),_({above:t,below:a})),x(t)&&!k){const{collidedWith:g}=t.state;g.roomTime===i.roomTime?s&&(g.by[a.id]=!0):(g.by={[a.id]:!0},g.roomTime=i.roomTime)}}},yt=(t,e,{changeType:o,sourceItem:i})=>{switch(o){case"portal":return u(t.items).find(s=>z(s)&&s.config.toRoom===e.id&&X(v(i.config.direction,-1),s.config.direction));case"level-select":return u(t.items).find(s=>z(s)&&s.config.toRoom===e.id&&s.config.direction.z===0)??u(t.items).find(s=>z(s)&&s.config.direction.z===0)??u(t.items).find(s=>z(s)&&s.config.direction.z>0)??u(t.items).find(z)}},ht=(t,e,o,i)=>{const s=1*W.w;t.state.position=m(t.state.position,v(e,s));for(let r=0;r<s;r++)B({subjectItem:t,posDelta:v(e,-1),gameState:o,room:i,deltaMS:16,forceful:!0,onTouch:void 0})},gt=t=>{const{playableItem:e,gameState:o,toRoomId:i,changeType:s,sourceItem:r}=t,d=o.characterRooms[e.id];if(d===void 0)throw new Error(`${e.id} is not in a room on the gameState`);if(i===d.id)throw new Error(`Can't move ${e.id} to the same room "${i}""`);let p;switch(s){case"portal":{const{config:{relativePoint:n},state:{position:c}}=r;p=w(e.state.position,m(c,n));break}case"teleport":{const{state:{position:n}}=r;p=w(e.state.position,n);break}case"level-select":p={x:0,y:0,z:0};break;default:throw new Error}const f=e.type==="headOverHeels"?void 0:o.characterRooms[P(e.id)],y=o.campaign.rooms[i];if(y===void 0)throw new Error(`room ${i} does not exist in campaign`);const l=f?.id===i?f:tt({roomJson:y,roomPickupsCollected:o.pickupsCollected[i]??et});T({room:d,item:e});const h=it(e);if(h!==void 0&&(h.carrying=null),e.state.latentMovement=[],(e.type==="head"||e.type==="headOverHeels")&&lt(l,o),T({room:l,item:e}),l.items[e.id]=e,o.characterRooms[e.id]=l,t.changeType==="teleport"){const{config:{toPosition:n}}=t.sourceItem;e.state.position=m(C(n),p)}else{const n=yt(l,d,t);if(console.log("putting",e.id,"into",i,"at portal",n,"because",s,"sourceportal",r),n===void 0)if(t.changeType==="level-select")e.state.position=C({x:1,y:1,z:8});else throw new Error(`trying to move ${e.id} from ${d.id} --to-> ${i} but no destination portal found to locate with`);else{e.state.position=m(n.state.position,n.config.relativePoint,p,s==="portal"&&r.config.direction.z>0?{z:W.h}:{});const{config:{direction:c}}=n;c.z===0&&(e.state.autoWalk=!0,e.state.facing=v(c,-1),e.state.action==="idle"&&(e.state.action="moving"),ht(e,c,o,l))}}const a=J(e,$(l.items));a.length>0&&console.warn("on entering room",i,"character",e.id,"at",e.state.position,"collides with",a),o.entryState[e.id]=ot(e),e.id==="headOverHeels"?(delete o.entryState.head,delete o.entryState.heels):(o.entryState[P(e.id)]||(o.entryState[P(e.id)]=o.entryState.headOverHeels),delete o.entryState.headOverHeels),R.dispatch(st(i)),R.dispatch(at({characterName:e.type,roomId:i}))};export{pt as a,B as b,gt as c,dt as d,rt as f,b as m,nt as o,lt as r};
