import{l as H,o as W,u as N,g as E,b as J,c as U}from"./App-CALJhFQe.js";function q(c){var e="";return n(c),e;function n(s){if(s===null||typeof s!="object"||s.toJSON!=null)e+=JSON.stringify(s);else if(Array.isArray(s)){e+="[";var y=!1;s.forEach(function(m){y&&(e+=","),y=!0,m===void 0&&(m=null),n(m)}),e+="]"}else{e+="{";var k=Object.keys(s).filter(function(m){return s[m]!==void 0}).sort();k.forEach(function(m,S){return i(s,m,S)}),e+="}"}}function i(s,y,k){k>0&&(e+=","),e+=JSON.stringify(y),e+=":",n(s[y])}}const R=c=>H(B(c))>0,B=c=>{switch(c.type){case"deadlyBlock":return N;case"conveyor":if(c.config.disappearing)return W;switch(c.config.direction){case"left":case"right":return{x:1,y:0,z:0};case"away":case"towards":return{x:0,y:1,z:0};default:throw c.config.direction,new Error}case"hushPuppy":return N;case"teleporter":return{x:1,y:1,z:0};case"floor":case"spikes":return{x:1,y:1,z:0};case"block":return c.config.disappearing?W:N;case"barrier":if(c.config.disappearing)return W;switch(c.config.axis){case"x":return{x:1,y:0,z:1};case"y":return{x:0,y:1,z:1};default:throw c.config.axis,new Error}case"wall":switch(c.config.direction){case"left":case"right":return{x:0,y:1,z:1};case"away":case"towards":return{x:1,y:0,z:1};default:throw c.config,new Error}default:return W}};class X{#i;#e;#t;constructor(e,n){this.#e={x:-e.x,y:-e.y,z:-e.z},this.#t={x:n.x-e.x+1,y:n.y-e.y+1,z:n.z-e.z+1},this.#i=Array.from({length:this.#t.x},()=>Array.from({length:this.#t.y},()=>Array.from({length:this.#t.z},()=>new Set)))}static fromItems(e){let n=1/0,i=1/0,s=1/0,y=-1/0,k=-1/0,m=-1/0;const S=[...e];for(const[,T]of S){const{x:t,y:h,z:u}=T.position,o=E(T);n=Math.min(n,t),i=Math.min(i,h),s=Math.min(s,u),y=Math.max(y,t+o.x-1),k=Math.max(k,h+o.y-1),m=Math.max(m,u+o.z-1)}if(S.length===0)return new X({x:0,y:0,z:0},{x:0,y:0,z:0});const P=new X({x:n,y:i,z:s},{x:y,y:k,z:m});for(const T of S){const[,t]=T,{x:h,y:u,z:o}=t.position,w=E(t);for(let p=0;p<w.x;p++)for(let M=0;M<w.y;M++)for(let b=0;b<w.z;b++)P.add({x:h+p,y:u+M,z:o+b},T)}return P}get(e){const n=e.x+this.#e.x,i=e.y+this.#e.y,s=e.z+this.#e.z;if(this.#o(n,i,s))return this.#i[n][i][s]}set(e,n){const i=e.x+this.#e.x,s=e.y+this.#e.y,y=e.z+this.#e.z;this.#o(i,s,y)&&(this.#i[i][s][y]=n)}add(e,n){const i=this.get(e);i&&i.add(n)}remove(e,n){const i=this.get(e);i&&i.delete(n)}get size(){return{...this.#t}}get minBounds(){return{x:-this.#e.x,y:-this.#e.y,z:-this.#e.z}}get maxBounds(){const e=this.minBounds;return{x:e.x+this.#t.x-1,y:e.y+this.#t.y-1,z:e.z+this.#t.z-1}}*iterate(){const{minBounds:e}=this;for(let n=0;n<this.#t.x;n++)for(let i=0;i<this.#t.y;i++)for(let s=0;s<this.#t.z;s++)yield[{x:n+e.x,y:i+e.y,z:s+e.z},this.#i[n][i][s]]}extractUniqueItems(){const e=new Set,n=[];for(const[,i]of this.iterate())for(const s of i)e.has(s)||(e.add(s),n.push(s));return n}#o(e,n,i){return e>=0&&e<this.#t.x&&n>=0&&n<this.#t.y&&i>=0&&i<this.#t.z}}const A=c=>c.type==="wall"?`wall/${c.config.direction}`:c.type==="teleporter"?q({type:c.type,config:J(c.config,"toPosition","times")}):q({type:c.type,config:J(c.config,"times")}),V=c=>R(c[1]),Y=c=>{let e=[...c],n=e.length;for(;;){const i=[...Z(e)];if(i.length===n)return i;n=i.length,e=i}},Z=c=>{const e=[],n=[];for(const t of c)V(t)?e.push(t):n.push(t);const i=X.fromItems(e),s=i.size,{minBounds:y}=i,k=new Map,m=new Map;for(const[,t]of i.iterate())for(const[,h]of t){const u=A(h);m.has(u)||m.set(u,h)}for(const[t]of m)k.set(t,Array.from({length:s.x},()=>Array.from({length:s.y},()=>Array(s.z).fill(!1))));const S=(t,h)=>{const u=E(h),o={x:t.x+u.x-1,y:t.y+u.y-1,z:t.z+u.z-1},w=B(h),p=A(h),M=new Set;M.add(h);const b=f=>{const x=new Set;let z=!1;for(let{x:r}=t;r<=f.x;r++)for(let{y:l}=t;l<=f.y;l++)for(let{z:a}=t;a<=f.z;a++){const I=i.get({x:r,y:l,z:a});let C=!1,O=!1;if(I)for(const[,v]of I)A(v)===p?(C=!0,x.add(v)):R(v)&&v.type!=="wall"&&(O=!0);O&&!C&&(z=!0),(!I||I.size===0)&&(z=!0),C||(z=!0)}if(z)return!1;let g=!1;for(const r of x)M.has(r)||(g=!0,M.add(r));if(!g)return!1;for(const r of x){const l=E(r),a={x:r.position.x+l.x-1,y:r.position.y+l.y-1,z:r.position.z+l.z-1};if(r.position.x<t.x||r.position.y<t.y||r.position.z<t.z||a.x>f.x||a.y>f.y||a.z>f.z)return!1}return!0};let d=!0;for(;d;){if(d=!1,w.x>0&&o.x+1<y.x+s.x){let f=o.x;for(let{y:x}=t;x<=o.y;x++)for(let{z}=t;z<=o.z;z++){const g=i.get({x:o.x+1,y:x,z});if(g){for(const[,r]of g)if(A(r)===p){const l=E(r),a=r.position.x+l.x-1;f=Math.max(f,a)}}}f>o.x&&b({...o,x:f})&&(o.x=f,d=!0)}if(w.y>0&&o.y+1<y.y+s.y){let f=o.y;for(let{x}=t;x<=o.x;x++)for(let{z}=t;z<=o.z;z++){const g=i.get({x,y:o.y+1,z});if(g){for(const[,r]of g)if(A(r)===p){const l=E(r),a=r.position.y+l.y-1;f=Math.max(f,a)}}}f>o.y&&b({...o,y:f})&&(o.y=f,d=!0)}if(w.z>0&&o.z+1<y.z+s.z){let f=o.z;for(let{x}=t;x<=o.x;x++)for(let{y:z}=t;z<=o.y;z++){const g=i.get({x,y:z,z:o.z+1});if(g){for(const[,r]of g)if(A(r)===p){const l=E(r),a=r.position.z+l.z-1;f=Math.max(f,a)}}}f>o.z&&b({...o,z:f})&&(o.z=f,d=!0)}}return o},P=(t,h)=>{if(t.type==="wall"){if(h.type!=="wall")throw new Error("only walls can join walls");if(t.config.direction!==h.config.direction)throw new Error("walls must have the same direction to join");return t.config.direction==="right"||t.config.direction==="towards"?t:{...t,config:{...t.config,tiles:[...t.config.tiles,...h.config.tiles]}}}return t},T=({x:t,y:h,z:u},{x:o,y:w,z:p},M)=>{const[b,d]=M,f=A(d),x=o-t+1,z=w-h+1,g=p-u+1;let r=d;if(x+z+g>3){const l={...d.config};if(d.type==="wall")switch(d.config.direction){case"away":case"left":break;case"towards":x!==1&&(l.times={x});break;case"right":z!==1&&(l.times={y:z});break}else{const a={...U(E(d))};x!==1&&(a.x=x),z!==1&&(a.y=z),g!==1&&(a.z=g),l.times=a}r={...d,config:l}}for(let l=t;l<=o;l++)for(let a=h;a<=w;a++)for(let I=u;I<=p;I++)if(k.get(f)[l-y.x][a-y.y][I-y.z]=!0,l!==t||a!==h||I!==u){const C=i.get({x:l,y:a,z:I});if(C)t:for(const O of C){const[,v]=O;if(A(v)===f){v.position.x===l&&v.position.y===a&&v.position.z===I&&(r=P(r,v)),i.remove({x:l,y:a,z:I},O);break t}}}return[b,r]};for(const[t,h]of i.iterate())for(const u of h){const[,o]=u;if(o.position.x===t.x&&o.position.y===t.y&&o.position.z===t.z){const w=A(o),p=k.get(w),M=t.x-y.x,b=t.y-y.y,d=t.z-y.z;if(p&&!p[M][b][d]){const f=S(t,o),x=T(t,f,u);i.remove(t,u),i.add(t,x)}}}return[...i.extractUniqueItems(),...n]},$=c=>Object.fromEntries(Y(Object.entries(c)));export{$ as c,B as g};
