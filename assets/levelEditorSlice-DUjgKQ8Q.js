import{am as D,an as v,j as A,k as x,X as k,ao as y,$ as P,ap as $,aq as X,ar as F,as as L}from"./App-BtBKEGvx.js";import"./index-DeceLqjn.js";const O={jail:["bars"],blacktooth:["plain","plain","armour","shield","shield","armour"],bookworld:["book","book","cowboy"],egyptus:["hieroglyphics","hieroglyphics","hieroglyphics","sarcophagus","sarcophagus"],market:["passage","more-fruits","more-fruits","more-fruits","fruits"],moonbase:["coil","window1","window2","window3"],penitentiary:["loop","loop","skeleton"],safari:["wall","shield","wall","window","window","wall","shield"]},U=(o,e)=>{const t=O[o];return t[e%t.length]},h=(o,e)=>new Array(e).fill(0).map((t,s)=>U(o,s)),j={awayWall:{type:"wall",config:{direction:"away",times:{x:8},tiles:h("blacktooth",8)},position:{x:0,y:8,z:0}},leftWall:{type:"wall",config:{direction:"left",times:{y:8},tiles:h("blacktooth",8)},position:{x:8,y:0,z:0}},towardsWall:{type:"wall",config:{direction:"towards",times:{x:8}},position:{x:0,y:0,z:0}},rightWall:{type:"wall",config:{direction:"right",times:{y:8}},position:{x:0,y:0,z:0}}},S={x:8,y:8},T={planet:"blacktooth",color:{hue:"cyan",shade:"basic"},items:{...j,floor:{type:"floor",config:{floorType:"standable",scenery:"blacktooth",times:S},position:{x:0,y:0,z:0}}},size:S},u=o=>o.campaignInProgress.rooms[o.currentlyEditingRoomId];function*M(o,e,t){for(const s of v(o)){const[r,l]=s;if(l.type!=="wall"){yield s;continue}if(l.config.direction!==e){yield s;continue}const{position:p,config:a}=l,d={x:1,y:1,...a.times},n=A(x(a.direction)),g=x(a.direction),c=k(t,p);if(c[g]!==0){yield s;continue}if(c[n]<-1){yield s;continue}if(c[n]>d[n]){yield s;continue}if(d[n]===2)continue;c[n]===0&&(yield[r,y(l,m=>{m.position=P(p,{[n]:2});const i=m.config;i.times={[n]:d[n]-2},i.tiles&&(i.tiles=i.tiles.slice(2))})]),c[n]===d[n]-2&&(yield[r,y(l,m=>{const i=m.config;i.times={[n]:d[n]-2},i.tiles&&(i.tiles=i.tiles.slice(0,i.tiles.length-2))})]),yield[`${r}/beforeDoor`,y(l,m=>{const i=m.config;i.times={[n]:c[n]},i.tiles&&(i.tiles=i.tiles.slice(0,c[n]))})],yield[`${r}/afterDoor`,y(l,m=>{m.position={...p,[n]:t[n]+2};const i=m.config;i.times={[n]:d[n]-c[n]-2},i.tiles&&(i.tiles=i.tiles.slice(c[n]+2))})]}}const C=(o,e,t)=>{o.items=D(M(o.items,e,t))},I=o=>{const e=structuredClone($(u(o))),{history:t}=o;t.redo=[],t.undo.push(e)},q={undo(o){const e=o,{campaignInProgress:t,history:{undo:s,redo:r},currentlyEditingRoomId:l}=e;s.length!==0&&(r.push(t.rooms[l]),t.rooms[l]=s.pop())},redo(o){const e=o,{campaignInProgress:t,history:{redo:s,undo:r},currentlyEditingRoomId:l}=e;s.length!==0&&(r.push(t.rooms[l]),t.rooms[l]=s.pop())}},H={selectCanUndo:o=>o.history.undo.length>0,selectCanRedo:o=>o.history.redo.length>0},b=(o,e)=>{o.planet=e;for(const t of Object.values(o.items))t.type==="floor"&&t.config.floorType==="standable"&&(t.config.scenery=e),t.type==="wall"&&(t.config.direction==="away"||t.config.direction==="left")&&(t.config.tiles=h(e,t.config.tiles.length))},z=(o,e)=>`${e}#${o.nextItemId++}`,E=(o,e,t,s)=>{const r=z(o,e),l=u(o);o.nextItemId++,l.items[r]={type:e,config:t,position:s}},_=o=>o.type==="door",B={applyToolToRoomJson(o,{payload:{blockPosition:e,pointedAtItem:t}}){const s=o,{tool:r}=s;switch(r?.type){case"item":{const l=r.item;if(_(l)&&t.type==="wall"){I(s);const p=u(s),a=t.config.direction;C(p,a,e);const d=`room#${s.nextRoomId++}`;console.log(d,"toRoomId"),E(s,l.type,{...r.item.config,toRoom:d,direction:a},e);const n={id:d,...structuredClone(T),color:p.color};b(n,p.planet),s.campaignInProgress.rooms[d]=n;const g=z(s,"door"),c={x:a==="left"?0:a==="right"?n.size.x:Math.floor(n.size.x/2),y:a==="away"?0:a==="towards"?n.size.x:Math.floor(n.size.x/2),z:e.z},f=X(a),w={type:"door",config:{toRoom:p.id,direction:f},position:c};n.items[g]=w,C(n,f,c)}else I(s),E(s,r.item.type,r.item.config,e);s.selectedJsonItemIds=[];break}}}},R="room#0",G={...structuredClone(T),id:R},J={campaignInProgress:{name:"new campaign",rooms:{[R]:G}},nextRoomId:1,nextItemId:0,currentlyEditingRoomId:R,tool:{type:"pointer"},selectedJsonItemIds:[],history:{undo:[],redo:[]}},W=F({name:"levelEditor",initialState:J,reducers:{setTool(o,{payload:e}){const t=o;t.tool=e},changeRoomColour(o,{payload:e}){const t=o,s=t.campaignInProgress.rooms[t.currentlyEditingRoomId].color;Object.assign(s,e)},changeRoomScenery(o,{payload:e}){const s=u(o);b(s,e)},changeToRoom(o,{payload:e}){const t=o;t.currentlyEditingRoomId=e,t.history=J.history},setSelectedItemInRoom(o,{payload:{jsonItemId:e,additive:t}}){if(t)if(e===void 0)o.selectedJsonItemIds=[];else{const s=o.selectedJsonItemIds.indexOf(e);s===-1?o.selectedJsonItemIds.push(e):o.selectedJsonItemIds.splice(s,1)}else o.selectedJsonItemIds=e===void 0?[]:[e]},deleteSelected(o){const e=o,t=u(e);I(e),e.selectedJsonItemIds.forEach(s=>{delete t.items[s]}),e.selectedJsonItemIds=[]},injected(){},...q,...B},selectors:{selectCurrentEditingRoomJson:u,selectCurrentEditingRoomColour:o=>u(o).color,selectCurrentEditingRoomScenery:o=>u(o).planet,selectTool:o=>o.tool,selectSelectedJsonItemIds:o=>o.selectedJsonItemIds,...H}}),{applyToolToRoomJson:V,changeRoomColour:Y,changeRoomScenery:Z,changeToRoom:N,deleteSelected:oo,injected:eo,redo:to,setSelectedItemInRoom:so,setTool:no,undo:io}=W.actions,{selectCurrentEditingRoomJson:lo,selectTool:ro,selectCurrentEditingRoomColour:co,selectCurrentEditingRoomScenery:ao,selectSelectedJsonItemIds:mo,selectCanRedo:po,selectCanUndo:uo}=W.selectors,yo=L.withTypes();export{V as applyToolToRoomJson,Y as changeRoomColour,Z as changeRoomScenery,N as changeToRoom,oo as deleteSelected,J as initialLevelEditorSliceState,eo as injected,W as levelEditorSlice,to as redo,po as selectCanRedo,uo as selectCanUndo,co as selectCurrentEditingRoomColour,lo as selectCurrentEditingRoomJson,ao as selectCurrentEditingRoomScenery,mo as selectSelectedJsonItemIds,ro as selectTool,so as setSelectedItemInRoom,no as setTool,io as undo,yo as useAppSelectorWithLevelEditorSlice};
