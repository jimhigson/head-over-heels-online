import{f as J,h as $,j as N,o as C,k as A,m as T,n as x,q as v,r as E,x as R,y as g,A as S,B as I,C as D,D as X,E as B,F as q,H as M,I as L,l as U,J as V,K as Y,L as Z,M as _,N as G,O as K,P as k,Q,R as w,S as j,T as tt,U as P,W as F,X as et,Y as it,Z as ot,_ as st,$ as z,a0 as at}from"./App-CrX7FKjU.js";const nt=1e3/25,H=t=>{const e=J.animations[t],o=e.length,{animationSpeed:i}=e;return o*nt/i};H("bubbles.white");const rt=H("head.fadeOut"),lt=({touchedItem:t,room:e,gameState:o})=>{$({room:e,item:t});const i=N({itemType:"bubbles",config:{style:"white",was:t.type==="pickup"?{type:"pickup",gives:t.config.gives}:t.type==="hushPuppy"?{type:"hushPuppy"}:{type:"disappearing"}},position:C,room:e,gameState:o}),s=A(t);i.state.position=T(s,x(i.aabb,.5)),i.state.expires=e.roomTime+rt},dt=(t,e)=>{const o=v(t.items).filter(E("hushPuppy"));for(const i of o)lt({touchedItem:i,gameState:e,room:t})},ct=.5,b=(t,e,o,i)=>{const s=o.x+i.x-t.x,d=o.y+i.y-t.y,c=o.z+i.z-t.z,p=t.x+e.x-o.x,h=t.y+e.y-o.y,f=t.z+e.z-o.z,r=Math.abs(s)<Math.abs(p)?s:-p,m=Math.abs(d)<Math.abs(h)?d:-h,a=Math.abs(c)<Math.abs(f)?c:-f,n=Math.abs(r),l=Math.abs(m),y=Math.abs(a)*ct;return n<l&&n<y?{x:r,y:0,z:0}:l<y?{x:0,y:m,z:0}:{x:0,y:0,z:a}},W=({subjectItem:t,posDelta:e,gameState:o,room:i,pusher:s,deltaMS:d,forceful:c=E("lift")(t)&&s===void 0,recursionDepth:p=0,onTouch:h})=>{if(R(e,C))return;const{state:{position:f}}=t;if(t.state.position=g(f,e),S(t)){const{actedOnAt:a}=t.state;a.roomTime===i.roomTime?s&&(a.by[s.id]=!0):(a.by=s?{[s.id]:!0}:{},a.roomTime=i.roomTime)}const r=I(e,D(t,X(i.items)));let m=!1;for(const a of r){if(!B(t,a))continue;const n=q(a);if(s!==a&&!(m&&n)&&h!==void 0&&(h({movingItem:t,touchedItem:a,movementVector:T(t.state.position,f),gameState:o,deltaMS:d,room:i}),m=m||n),i.items[t.id]===void 0)return;if(i.items[a.id]===void 0||!M(a,t)||!M(t))continue;const l=b(t.state.position,t.aabb,a.state.position,a.aabb),y=L(U(b(f,t.aabb,a.state.position,a.aabb)),0);if(V(t,a,c)&&a!==s){const u=c||K(a)?-1:-.5,O=x(l,u);if(t.state.position=g(t.state.position,l,O),p<Y&&W({subjectItem:a,posDelta:O,pusher:t,gameState:o,room:i,deltaMS:d,forceful:c,recursionDepth:p+1,onTouch:h}),i.items[a.id]===void 0)continue;t.state.position=g(t.state.position,b(t.state.position,t.aabb,a.state.position,a.aabb))}else t.state.position=g(t.state.position,l);if(S(t)&&l.z>0&&(t.state.standingOnItemId===null||!r.includes(Z(t.state.standingOnItemId,i)))&&(_(t,i),G({above:t,below:a})),S(t)&&!y){const{collidedWith:u}=t.state;u.roomTime===i.roomTime?s&&(u.by[a.id]=!0):(u.by={[a.id]:!0},u.roomTime=i.roomTime)}}},pt=(t,e,{changeType:o,sourceItem:i})=>{switch(o){case"portal":return v(t.items).find(s=>z(s)&&s.config.toRoom===e.id&&(i.config.toDoor===void 0||s.jsonItemId===i.config.toDoor)&&R(x(i.config.direction,-1),s.config.direction));case"level-select":return v(t.items).find(s=>z(s)&&s.config.toRoom===e.id&&s.config.direction.z===0)??v(t.items).find(s=>z(s)&&s.config.direction.z===0)??v(t.items).find(s=>z(s)&&s.config.direction.z>0)??v(t.items).find(z)}},ht=(t,e,o,i)=>{const s=1*F.w;t.state.position=g(t.state.position,x(e,s));for(let d=0;d<s;d++)W({subjectItem:t,posDelta:x(e,-1),gameState:o,room:i,deltaMS:16,forceful:!0,onTouch:void 0})},gt=t=>{const{playableItem:e,gameState:o,toRoomId:i,changeType:s,sourceItem:d}=t,c=o.characterRooms[e.id];if(c===void 0)throw new Error(`${e.id} is not in a room on the gameState`);if(i===c.id)throw new Error(`Can't move ${e.id} to the same room "${i}""`);let p;switch(s){case"portal":{const{config:{relativePoint:n},state:{position:l}}=d;p=T(e.state.position,g(l,n));break}case"teleport":{const{state:{position:n}}=d;p=T(e.state.position,n);break}case"level-select":p={x:0,y:0,z:0};break;default:throw new Error}const h=e.type==="headOverHeels"?void 0:o.characterRooms[k(e.id)],f=o.campaign.rooms[i];if(f===void 0)throw new Error(`room ${i} does not exist in campaign`);const r=h?.id===i?h:Q({roomJson:f,roomPickupsCollected:o.pickupsCollected[i]??j,scrollsRead:w.getState().gameMenus.scrollsRead});$({room:c,item:e});const m=tt(e);if(m!==void 0&&(m.carrying=null),e.state.latentMovement=[],(e.type==="head"||e.type==="headOverHeels")&&dt(r,o),$({room:r,item:e}),r.items[e.id]=e,o.characterRooms[e.id]=r,t.changeType==="teleport"){const{config:{toPosition:n}}=t.sourceItem;e.state.position=g(P(n),p)}else{const n=pt(r,c,t);if(console.log("putting",e.id,"into",i,"at portal",n,"because",s,"sourceportal",d),n===void 0)if(t.changeType==="level-select")e.state.position=P({x:1,y:1,z:8});else throw new Error(`trying to move ${e.id} from ${c.id} --to-> ${i} but no destination portal found to locate with`);else{e.state.position=g(n.state.position,n.config.relativePoint,p,s==="portal"&&d.config.direction.z>0?{z:F.h}:{});const{config:{direction:l}}=n;l.z===0&&(e.state.autoWalk=!0,e.state.facing=x(l,-1),e.state.action==="idle"&&(e.state.action="moving"),ht(e,l,o,r))}}const a=D(e,et(X(r.items)).filter(n=>n.type!=="portal"));a.length>0&&console.warn("on entering room",i,"character",e.id,"at",e.state.position,"collides with",a),o.entryState[e.id]=it(e),e.id==="headOverHeels"?(delete o.entryState.head,delete o.entryState.heels):(o.entryState[k(e.id)]||(o.entryState[k(e.id)]=o.entryState.headOverHeels),delete o.entryState.headOverHeels),w.dispatch(ot(i)),w.dispatch(st({characterName:e.type,roomId:i}))},ft={Container:"📦",Sprite:"🖼️",UniqueTextureSprite:"✨",Graphics:"🎨",Text:"📝",AnimatedSprite:"🎬",TilingSprite:"🔲",BitmapText:"🔤",Mesh:"🔺",NineSliceSprite:"🔳"},mt=(t,e="",o=!0,i=!0,s=[])=>{const d=[];i&&d.push("");const c=t.constructor.name,p=c.startsWith("_")?c.slice(1):c;let h=ft[p]||"📌";s.forEach((n,l)=>{n.mask===t&&(l===0?h+="😷":h+=`😷^${l+1}`)});const f=t.label&&t.label!==p?` "${t.label}"`:"",r=[];try{(t.x!==0||t.y!==0)&&r.push(`@(${t.x}, ${t.y})`)}catch{r.push("@(ERROR)")}if(t.children.length>2&&r.push(`children: ${t.children.length}`),t.visible||r.push("hidden"),t.alpha<1&&r.push(`alpha: ${t.alpha.toFixed(2)}`),t.mask&&r.push("😷 masked"),t instanceof at){const n=t;if(n.texture===null||n.texture===void 0)r.push("texture: NO TEXTURE");else{const l=n.texture.label||"(anon texture)";r.push(`texture: "${l}"`)}}const m=i?"":e+(o?"└── ":"├── ");if(d.push(`${m}${h} ${p}${f}`),r.length>0){const n=t.children.length>0,l=i?n?"│  ":"   ":e+(o?"    ":"│   ")+(n?"│  ":"   ");r.forEach(y=>{d.push(`${l}→ ${y}`)})}const a=i?"":e+(o?"    ":"│   ");return t.children.forEach((n,l)=>{const y=l===t.children.length-1;d.push(mt(n,a,y,!1,[t,...s]))}),d.join(`
`)+(i?`
`:"")};export{W as a,lt as b,gt as c,rt as f,b as m,nt as o,mt as p,dt as r};
